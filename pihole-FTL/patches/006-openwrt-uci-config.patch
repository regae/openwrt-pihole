--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -324,6 +324,12 @@ if(CONNTRACK_SUPPORT)
     target_link_libraries(pihole-FTL ${LIBNETFILTER_CONNTRACK} ${LIBNFNETLINK})
 endif()
 
+find_library(LIBUCI uci)
+if(NOT LIBUCI)
+    message(FATAL_ERROR "libuci not found")
+endif()
+target_link_libraries(pihole-FTL ${LIBUCI})
+
 if(NFT_SUPPORT)
     find_library(LIBNFTABLES nftables)
     target_link_libraries(pihole-FTL ${LIBNFTABLES})
--- a/src/api/config.c
+++ b/src/api/config.c
@@ -764,6 +764,10 @@ static int api_config_patch(struct ftl_c
 		// Memorize that at least one config item actually changed
 		config_changed = true;
 
+		// Set to uci config
+		if(uci_set_value(new_item, NULL, false))
+			log_err("Failed to save new config for: %s", new_item->k);
+
 		// If we reach this point, a valid setting was found and changed
 
 		// Check if this item requires a config-rewrite + restart of dnsmasq
@@ -930,6 +934,7 @@ static int api_config_put_delete(struct
 			{
 				// Add new item to array
 				JSON_COPY_STR_TO_ARRAY(new_item->v.json, new_item_str);
+				uci_add_sec_foreach(uci_dhcp, new_item->k, new_item_str);
 				found = true;
 			}
 		}
@@ -939,6 +944,7 @@ static int api_config_put_delete(struct
 			{
 				// Remove item from array
 				cJSON_DeleteItemFromArray(new_item->v.json, idx);
+				uci_del_sec_foreach(uci_dhcp, new_item_str);
 			}
 			else
 			{
--- a/src/api/dhcp.c
+++ b/src/api/dhcp.c
@@ -12,6 +12,7 @@
 #include "webserver/http-common.h"
 #include "webserver/json_macros.h"
 #include "api.h"
+#include "config/config.h"
 #include "config/dnsmasq_config.h"
 // rotate_files()
 #include "files.h"
@@ -23,7 +24,7 @@ int api_dhcp_leases_GET(struct ftl_conn
 	cJSON *json = JSON_NEW_OBJECT();
 	JSON_ADD_ITEM_TO_OBJECT(json, "leases", leases);
 
-	FILE *fp = fopen(DHCPLEASESFILE, "r");
+	FILE *fp = fopen(config.dhcp.leaseFile.v.s, "r");
 	if(fp == NULL)
 	{
 		// File does not exist or not readable, send empty array
--- a/src/api/stats.c
+++ b/src/api/stats.c
@@ -14,8 +14,6 @@
 #include "api.h"
 #include "../shmem.h"
 #include "../datastructure.h"
-// read_setupVarsconf()
-#include "../config/setupVars.h"
 // logging routines
 #include "../log.h"
 // config struct
@@ -195,7 +193,7 @@ int api_stats_top_domains(struct ftl_con
 	qsort(temparray, domains, sizeof(int[2]), cmpdesc);
 
 	// Get filter
-	const char* filter = read_setupVarsconf("API_QUERY_LOG_SHOW");
+	const char* filter = uci_get_string(uci_pihole, "@pihole[0]", "api_query_log_show");
 	bool showpermitted = true, showblocked = true;
 	if(filter != NULL)
 	{
@@ -209,7 +207,6 @@ int api_stats_top_domains(struct ftl_con
 			showblocked = false;
 		}
 	}
-	clearSetupVarsArray();
 
 	// Get domains which the user doesn't want to see
 	unsigned int excludeDomains = cJSON_GetArraySize(config.webserver.api.excludeDomains.v.json);
--- a/src/config/CMakeLists.txt
+++ b/src/config/CMakeLists.txt
@@ -13,6 +13,7 @@ set(sources
         cli.h
         config.c
         config.h
+        config_uci.c
         dnsmasq_config.c
         dnsmasq_config.h
         inotify.c
--- a/src/config/cli.c
+++ b/src/config/cli.c
@@ -24,7 +24,7 @@
 #include "capabilities.h"
 
 // Read a TOML value from a table depending on its type
-static bool readStringValue(struct conf_item *conf_item, const char *value, struct config *newconf)
+bool readStringValue(struct conf_item *conf_item, const char *value, struct config *newconf)
 {
 	if(conf_item == NULL || value == NULL)
 	{
@@ -36,26 +36,26 @@ static bool readStringValue(struct conf_
 	{
 		case CONF_BOOL:
 		{
-			if(strcasecmp(value, "true") == 0 || strcasecmp(value, "yes") == 0)
+			if(strcasecmp(value, "true") == 0 || strcmp(value, "1") == 0)
 				conf_item->v.b = true;
-			else if(strcasecmp(value, "false") == 0 || strcasecmp(value, "no") == 0)
+			else if(strcasecmp(value, "false") == 0 || strcmp(value, "0") == 0)
 				conf_item->v.b = false;
 			else
 			{
-				log_err("Config setting %s is invalid, allowed options are: [ true, false, yes, no ]", conf_item->k);
+				log_err("Config setting %s is invalid, allowed options are: [ true, false, 1, 0 ]", conf_item->k);
 				return false;
 			}
 			break;
 		}
 		case CONF_ALL_DEBUG_BOOL:
 		{
-			if(strcasecmp(value, "true") == 0 || strcasecmp(value, "yes") == 0)
+			if(strcasecmp(value, "true") == 0 || strcmp(value, "1") == 0)
 			{
 				set_all_debug(newconf, true);
 				conf_item->v.b = true;
 				set_debug_flags(newconf);
 			}
-			else if(strcasecmp(value, "false") == 0 || strcasecmp(value, "no") == 0)
+			else if(strcasecmp(value, "false") == 0 || strcmp(value, "0") == 0)
 			{
 				set_all_debug(newconf, false);
 				conf_item->v.b = false;
@@ -63,7 +63,7 @@ static bool readStringValue(struct conf_
 			}
 			else
 			{
-				log_err("Config setting %s is invalid, allowed options are: [ true, false, yes, no ]", conf_item->k);
+				log_err("Config setting %s is invalid, allowed options are: [ true, false, 1, 0 ]", conf_item->k);
 				return false;
 			}
 			break;
@@ -386,6 +386,7 @@ int set_config_from_CLI(const char *key,
 			printf("Permission error: User %s is not allowed to edit Pi-hole's config\n", current_user->pw_name);
 
 		printf("Please run this command using sudo\n\n");
+		clean_all();
 		return EXIT_FAILURE;
 	}
 
@@ -406,6 +407,7 @@ int set_config_from_CLI(const char *key,
 		{
 			log_err("Config option %s is read-only (set via environmental variable)", key);
 			free_config(&newconf);
+			clean_all();
 			return 5;
 		}
 
@@ -424,6 +426,7 @@ int set_config_from_CLI(const char *key,
 	{
 		log_err("Unknown config option: %s", key);
 		free_config(&newconf);
+		clean_all();
 		return 4;
 	}
 
@@ -431,6 +434,7 @@ int set_config_from_CLI(const char *key,
 	if(!readStringValue(new_item, value, &newconf))
 	{
 		free_config(&newconf);
+		clean_all();
 		return 2;
 	}
 
@@ -451,6 +455,7 @@ int set_config_from_CLI(const char *key,
 				// Test failed
 				log_debug(DEBUG_CONFIG, "Config item %s: dnsmasq config test failed", conf_item->k);
 				free_config(&newconf);
+				clean_all();
 				return 3;
 			}
 		}
@@ -461,6 +466,10 @@ int set_config_from_CLI(const char *key,
 			write_custom_list();
 		}
 
+		// save to uci config
+		if(uci_set_value(new_item, value, true))
+			log_err("Failed to save new config for: %s=%s", new_item->k, value);
+
 		// Install new configuration
 		replace_config(&newconf);
 
@@ -479,6 +488,7 @@ int set_config_from_CLI(const char *key,
 
 	putchar('\n');
 	writeFTLtoml(false);
+	clean_all();
 	return EXIT_SUCCESS;
 }
 
@@ -539,6 +549,7 @@ int get_config_from_CLI(const char *key,
 	if(conf_item == NULL)
 	{
 		log_err("Unknown config option: %s", key);
+		clean_all();
 		return 2;
 	}
 
@@ -547,5 +558,6 @@ int get_config_from_CLI(const char *key,
 	if(quiet && conf_item != NULL && conf_item->t == CONF_BOOL)
 		return conf_item->v.b ? EXIT_SUCCESS : EXIT_FAILURE;
 
+	clean_all();
 	return EXIT_SUCCESS;
 }
--- a/src/config/config.c
+++ b/src/config/config.c
@@ -31,14 +31,12 @@
 #include "signals.h"
 // sha256sum()
 #include "files.h"
+#include <uci.h>
 
 struct config config = { 0 };
 static bool config_initialized = false;
 uint8_t last_checksum[SHA256_DIGEST_SIZE] = { 0 };
 
-// Private prototypes
-static bool port_in_use(const in_port_t port);
-
 // Set debug flags from config struct to global debug_flags array
 // This is called whenever the config is reloaded and debug flags may have
 // changed
@@ -485,7 +483,7 @@ void initConfig(struct config *conf)
 	conf->dns.domain.a = cJSON_CreateStringReference("<any valid domain>");
 	conf->dns.domain.t = CONF_STRING;
 	conf->dns.domain.f = FLAG_RESTART_FTL | FLAG_ADVANCED_SETTING;
-	conf->dns.domain.d.s = (char*)"lan";
+	conf->dns.domain.d.s = (char*)"";
 
 	conf->dns.bogusPriv.k = "dns.bogusPriv";
 	conf->dns.bogusPriv.h = "Should all reverse lookups for private IP ranges (i.e., 192.168.x.y, etc) which are not found in /etc/hosts or the DHCP leases file be answered with \"no such domain\" rather than being forwarded upstream?";
@@ -497,14 +495,7 @@ void initConfig(struct config *conf)
 	conf->dns.dnssec.h = "Validate DNS replies using DNSSEC?";
 	conf->dns.dnssec.t = CONF_BOOL;
 	conf->dns.dnssec.f = FLAG_RESTART_FTL;
-	conf->dns.dnssec.d.b = true;
-
-	conf->dns.interface.k = "dns.interface";
-	conf->dns.interface.h = "Interface to use for DNS (see also dnsmasq.listening.mode) and DHCP (if enabled)";
-	conf->dns.interface.a = cJSON_CreateStringReference("a valid interface name");
-	conf->dns.interface.t = CONF_STRING;
-	conf->dns.interface.f = FLAG_RESTART_FTL | FLAG_ADVANCED_SETTING;
-	conf->dns.interface.d.s = (char*)"";
+	conf->dns.dnssec.d.b = false;
 
 	conf->dns.hostRecord.k = "dns.hostRecord";
 	conf->dns.hostRecord.h = "Add A, AAAA and PTR records to the DNS. This adds one or more names to the DNS with associated IPv4 (A) and IPv6 (AAAA) records";
@@ -534,7 +525,7 @@ void initConfig(struct config *conf)
 	conf->dns.queryLogging.h = "Log DNS queries and replies to pihole.log";
 	conf->dns.queryLogging.t = CONF_BOOL;
 	conf->dns.queryLogging.f = FLAG_RESTART_FTL;
-	conf->dns.queryLogging.d.b = true;
+	conf->dns.queryLogging.d.b = false;
 
 	conf->dns.cnameRecords.k = "dns.cnameRecords";
 	conf->dns.cnameRecords.h = "List of CNAME records which indicate that <cname> is really <target>. If the <TTL> is given, it overwrites the value of local-ttl";
@@ -692,48 +683,14 @@ void initConfig(struct config *conf)
 	conf->dhcp.active.h = "Is the embedded DHCP server enabled?";
 	conf->dhcp.active.t = CONF_BOOL;
 	conf->dhcp.active.f = FLAG_RESTART_FTL;
-	conf->dhcp.active.d.b = false;
+	conf->dhcp.active.d.b = true;
 
-	conf->dhcp.start.k = "dhcp.start";
-	conf->dhcp.start.h = "Start address of the DHCP address pool";
-	conf->dhcp.start.a = cJSON_CreateStringReference("<valid IPv4 address> or empty string (\"\"), e.g., \"192.168.0.10\"");
-	conf->dhcp.start.t = CONF_STRUCT_IN_ADDR;
-	conf->dhcp.start.f = FLAG_RESTART_FTL;
-	memset(&conf->dhcp.start.d.in_addr, 0, sizeof(struct in_addr));
-
-	conf->dhcp.end.k = "dhcp.end";
-	conf->dhcp.end.h = "End address of the DHCP address pool";
-	conf->dhcp.end.a = cJSON_CreateStringReference("<valid IPv4 address> or empty string (\"\"), e.g., \"192.168.0.250\"");
-	conf->dhcp.end.t = CONF_STRUCT_IN_ADDR;
-	conf->dhcp.end.f = FLAG_RESTART_FTL;
-	memset(&conf->dhcp.end.d.in_addr, 0, sizeof(struct in_addr));
-
-	conf->dhcp.router.k = "dhcp.router";
-	conf->dhcp.router.h = "Address of the gateway to be used (typically the address of your router in a home installation)";
-	conf->dhcp.router.a = cJSON_CreateStringReference("<valid IPv4 address> or empty string (\"\"), e.g., \"192.168.0.1\"");
-	conf->dhcp.router.t = CONF_STRUCT_IN_ADDR;
-	conf->dhcp.router.f = FLAG_RESTART_FTL;
-	memset(&conf->dhcp.router.d.in_addr, 0, sizeof(struct in_addr));
-
-	conf->dhcp.netmask.k = "dhcp.netmask";
-	conf->dhcp.netmask.h = "The netmask used by your Pi-hole. For directly connected networks (i.e., networks on which the machine running Pi-hole has an interface) the netmask is optional and may be set to an empty string (\"\"): it will then be determined from the interface configuration itself. For networks which receive DHCP service via a relay agent, we cannot determine the netmask itself, so it should explicitly be specified, otherwise Pi-hole guesses based on the class (A, B or C) of the network address.";
-	conf->dhcp.netmask.a = cJSON_CreateStringReference("<any valid netmask> (e.g., \"255.255.255.0\") or empty string (\"\") for auto-discovery");
-	conf->dhcp.netmask.t = CONF_STRUCT_IN_ADDR;
-	conf->dhcp.netmask.f = FLAG_RESTART_FTL | FLAG_ADVANCED_SETTING;
-	memset(&conf->dhcp.netmask.d.in_addr, 0, sizeof(struct in_addr));
-
-	conf->dhcp.leaseTime.k = "dhcp.leaseTime";
-	conf->dhcp.leaseTime.h = "If the lease time is given, then leases will be given for that length of time. If not given, the default lease time is one hour for IPv4 and one day for IPv6.";
-	conf->dhcp.leaseTime.a = cJSON_CreateStringReference("The lease time can be in seconds, or minutes (e.g., \"45m\") or hours (e.g., \"1h\") or days (like \"2d\") or even weeks (\"1w\"). You may also use \"infinite\" as string but be aware of the drawbacks");
-	conf->dhcp.leaseTime.t = CONF_STRING;
-	conf->dhcp.leaseTime.f = FLAG_RESTART_FTL | FLAG_ADVANCED_SETTING;
-	conf->dhcp.leaseTime.d.s = (char*)"";
-
-	conf->dhcp.ipv6.k = "dhcp.ipv6";
-	conf->dhcp.ipv6.h = "Should Pi-hole make an attempt to also satisfy IPv6 address requests (be aware that IPv6 works a whole lot different than IPv4)";
-	conf->dhcp.ipv6.t = CONF_BOOL;
-	conf->dhcp.ipv6.f = FLAG_RESTART_FTL;
-	conf->dhcp.ipv6.d.b = false;
+	conf->dhcp.leaseFile.k = "dhcp.leaseFile";
+	conf->dhcp.leaseFile.h = "The file which contains DHCP Lease information.";
+	conf->dhcp.leaseFile.a = cJSON_CreateStringReference("<any writable file>");
+	conf->dhcp.leaseFile.t = CONF_STRING;
+	conf->dhcp.leaseFile.f = FLAG_RESTART_FTL | FLAG_ADVANCED_SETTING;
+	conf->dhcp.leaseFile.d.s = (char*)"/etc/pihole/dhcp.leases";
 
 	conf->dhcp.multiDNS.k = "dhcp.multiDNS";
 	conf->dhcp.multiDNS.h = "Advertise DNS server multiple times to clients. Some devices will add their own proprietary DNS servers to the list of DNS servers, which can cause issues with Pi-hole. This option will advertise the Pi-hole DNS server multiple times to clients, which should prevent this from happening.";
@@ -842,9 +799,9 @@ void initConfig(struct config *conf)
 	conf->webserver.port.k = "webserver.port";
 	conf->webserver.port.h = "Ports to be used by the webserver.\n Comma-separated list of ports to listen on. It is possible to specify an IP address to bind to. In this case, an IP address and a colon must be prepended to the port number. For example, to bind to the loopback interface on port 80 (IPv4) and to all interfaces port 8080 (IPv4), use \"127.0.0.1:80,8080\". \"[::]:80\" can be used to listen to IPv6 connections to port 80. IPv6 addresses of network interfaces can be specified as well, e.g. \"[::1]:80\" for the IPv6 loopback interface. [::]:80 will bind to port 80 IPv6 only.\n In order to use port 80 for all interfaces, both IPv4 and IPv6, use either the configuration \"80,[::]:80\" (create one socket for IPv4 and one for IPv6 only), or \"+80\" (create one socket for both, IPv4 and IPv6). The + notation to use IPv4 and IPv6 will only work if no network interface is specified. Depending on your operating system version and IPv6 network environment, some configurations might not work as expected, so you have to test to find the configuration most suitable for your needs. In case \"+80\" does not work for your environment, you need to use \"80,[::]:80\".\n If the port is TLS/SSL, a letter 's' must be appended, for example, \"80,443s\" will open port 80 and port 443, and connections on port 443 will be encrypted. For non-encrypted ports, it is allowed to append letter 'r' (as in redirect). Redirected ports will redirect all their traffic to the first configured SSL port. For example, if webserver.port is \"80r,443s\", then all HTTP traffic coming at port 80 will be redirected to HTTPS port 443. If this value is not set (empty string), the web server will not be started and, hence, the API will not be available.";
 	conf->webserver.port.a = cJSON_CreateStringReference("comma-separated list of <[ip_address:]port>");
-	conf->webserver.port.f = FLAG_ADVANCED_SETTING | FLAG_RESTART_FTL;
+	conf->webserver.port.f = FLAG_ADVANCED_SETTING;
 	conf->webserver.port.t = CONF_STRING;
-	conf->webserver.port.d.s = (char*)"80,[::]:80,443s,[::]:443s";
+	conf->webserver.port.d.s = (char*)"8080";
 
 	conf->webserver.tls.rev_proxy.k = "webserver.tls.rev_proxy";
 	conf->webserver.tls.rev_proxy.h = "Is Pi-hole running behind a reverse proxy? If yes, Pi-hole will not consider HTTP-only connections being insecure. This is useful if you are running Pi-hole in a trusted environment, for example, in a local network, and you are using a reverse proxy to provide TLS encryption, e.g., by using Traefik (docker). If you are using a reverse proxy, you can alternatively set webserver.tls.cert to the path of the TLS certificate file and let Pi-hole handle true end-to-end encryption.";
@@ -1099,12 +1056,6 @@ void initConfig(struct config *conf)
 	conf->misc.addr2line.f = FLAG_ADVANCED_SETTING;
 	conf->misc.addr2line.d.b = true;
 
-	conf->misc.etc_dnsmasq_d.k = "misc.etc_dnsmasq_d";
-	conf->misc.etc_dnsmasq_d.h = "Should FTL load additional dnsmasq configuration files from /etc/dnsmasq.d/?";
-	conf->misc.etc_dnsmasq_d.t = CONF_BOOL;
-	conf->misc.etc_dnsmasq_d.f = FLAG_RESTART_FTL | FLAG_ADVANCED_SETTING;
-	conf->misc.etc_dnsmasq_d.d.b = false;
-
 	conf->misc.dnsmasq_lines.k = "misc.dnsmasq_lines";
 	conf->misc.dnsmasq_lines.h = "Additional lines to inject into the generated dnsmasq configuration.\n Warning: This is an advanced setting and should only be used with care. Incorrectly formatted or duplicated lines as well as lines conflicting with the automatic configuration of Pi-hole can break the embedded dnsmasq and will stop DNS resolution from working.\n Use this option with extra care.";
 	conf->misc.dnsmasq_lines.a = cJSON_CreateStringReference("array of valid dnsmasq config line options");
@@ -1381,6 +1332,17 @@ bool readFTLconf(struct config *conf, co
 	// Initialize config with default values
 	initConfig(conf);
 
+	if(!rewrite)
+	{
+		if(uci_ctx == NULL)
+			uci_ctx = uci_alloc_context();
+
+		uci_load_package(false);
+	}
+
+	// read uci value
+	uci_get_config_value(conf);
+
 	// First try to read TOML config file
 	// If we cannot parse /etc/pihole.toml (due to missing or invalid syntax),
 	// we try to read the rotated files in /etc/pihole/config_backup starting at
@@ -1397,6 +1359,12 @@ bool readFTLconf(struct config *conf, co
 				writeFTLtoml(true);
 				write_dnsmasq_config(conf, false, NULL);
 				write_custom_list();
+				write_hosts_file();
+			}
+			else if (uci_ctx)
+			{
+				uci_free_context(uci_ctx);
+				uci_ctx = NULL;
 			}
 			return true;
 		}
@@ -1435,41 +1403,21 @@ bool readFTLconf(struct config *conf, co
 		rename(GLOBALTOMLPATH, new_name);
 	}
 
-	// Determine default webserver ports
-	// Check if ports 80/TCP and 443/TCP are already in use
-	const in_port_t http_port = port_in_use(80) ? 8080 : 80;
-	const in_port_t https_port = port_in_use(443) ? 8443 : 443;
-
-	// Create a string with the default ports
-	// Allocate memory for the string
-	char *ports = calloc(32, sizeof(char));
-	if(ports == NULL)
-	{
-		log_err("Unable to allocate memory for default ports string");
-		return false;
-	}
-	// Create the string
-	snprintf(ports, 32, "%d,%ds", http_port, https_port);
-
-	// Append IPv6 ports if IPv6 is enabled
-	const bool have_ipv6 = ipv6_enabled();
-	if(have_ipv6)
-		snprintf(ports + strlen(ports), 32 - strlen(ports),
-		         ",[::]:%d,[::]:%ds", http_port, https_port);
-
-	// Set default values for webserver ports
-	if(conf->webserver.port.t == CONF_STRING_ALLOCATED)
-		free(conf->webserver.port.v.s);
-	conf->webserver.port.v.s = ports;
-	conf->webserver.port.t = CONF_STRING_ALLOCATED;
-
-	log_info("Initialised webserver ports at %d (HTTP) and %d (HTTPS), IPv6 support is %s",
-	         http_port, https_port, have_ipv6 ? "enabled" : "disabled");
+	log_info("Initialised webserver ports at %s", conf->webserver.port.v.s);
 
 	// Initialize the TOML config file
 	writeFTLtoml(true);
+	if(rewrite)
+	{
 	write_dnsmasq_config(conf, false, NULL);
 	write_custom_list();
+		write_hosts_file();
+	}
+	else if (uci_ctx)
+	{
+		uci_free_context(uci_ctx);
+		uci_ctx = NULL;
+	}
 
 	return false;
 }
@@ -1645,43 +1593,22 @@ void reread_config(void)
 	// at any time and is automatically reloaded by dnsmasq
 	write_custom_list();
 
+	// reload uci config
+	if(!uci_load_package(true))
+	{
+		log_err("failed to reload uci config");
+		return;
+	}
+
+	uci_get_config_value(&config);
+	write_hosts_file();
+
 	// If we need to restart FTL, we do so now
 	if(restart)
 	{
-		log_info("Restarting FTL due to pihole.toml change");
+		log_info("Restarting FTL due to config change");
 		exit_code = RESTART_FTL_CODE;
 		// Send SIGTERM to FTL
 		kill(main_pid(), SIGTERM);
 	}
 }
-
-// Very simple test of a port's availability by trying to bind a TCP socket to
-// it at 0.0.0.0 (this tests only IPv4 availability)
-static bool port_in_use(const in_port_t port)
-{
-	// Create a socket
-	const int sock = socket(AF_INET, SOCK_STREAM, 0);
-	if(sock < 0)
-	{
-		log_err("Unable to create port testing socket: %s", strerror(errno));
-		return false;
-	}
-
-	// Bind the socket to the desired port
-	struct sockaddr_in addr = { 0 };
-	addr.sin_family = AF_INET;
-	addr.sin_port = htons(port);
-	addr.sin_addr.s_addr = htonl(INADDR_ANY);
-
-	// Try to bind the socket
-	if(bind(sock, (struct sockaddr*)&addr, sizeof(addr)) < 0 && errno == EADDRINUSE)
-	{
-		// If we cannot bind the socket, the port is in use
-		close(sock);
-		return true;
-	}
-
-	// If we can bind the socket, the port is not in use
-	close(sock);
-	return false;
-}
--- a/src/config/config.h
+++ b/src/config/config.h
@@ -137,7 +137,6 @@ struct config {
 		struct conf_item domain;
 		struct conf_item bogusPriv;
 		struct conf_item dnssec;
-		struct conf_item interface;
 		struct conf_item hostRecord;
 		struct conf_item listeningMode;
 		struct conf_item queryLogging;
@@ -184,12 +183,7 @@ struct config {
 
 	struct {
 		struct conf_item active;
-		struct conf_item start;
-		struct conf_item end;
-		struct conf_item router;
-		struct conf_item netmask;
-		struct conf_item leaseTime;
-		struct conf_item ipv6;
+		struct conf_item leaseFile;
 		struct conf_item rapidCommit;
 		struct conf_item multiDNS;
 		struct conf_item hosts;
@@ -273,7 +267,6 @@ struct config {
 		struct conf_item delay_startup;
 		struct conf_item nice;
 		struct conf_item addr2line;
-		struct conf_item etc_dnsmasq_d;
 		struct conf_item dnsmasq_lines;
 		struct conf_item extraLogging;
 		struct {
@@ -344,6 +337,32 @@ const char *get_conf_type_str(const enum
 void replace_config(struct config *newconf);
 void reread_config(void);
 
+// Defined in config_uci.c
+extern struct uci_package *uci_dhcp;
+extern struct uci_package *uci_pihole;
+extern struct uci_package *uci_network;
+extern struct uci_context *uci_ctx;
+
+struct uci_section *get_uci_section_type(struct uci_package *pkg, const char *s);
+const char *uci_get_string(struct uci_package *pkg, const char *sec, const char *opt);
+int split_comma(const char *txt, char delim, char ***ptr);
+bool uci_load_package(bool reload);
+int uci_config_set(struct uci_package *pkg, const char *sec,
+				   const char *opt, const char *val, const bool list);
+int uci_add_sec_foreach(struct uci_package *pkg, const char *key, const char *target);
+int uci_del_sec_foreach(struct uci_package *pkg, const char *target);
+int uci_set_value(struct conf_item *item, const char *value, bool cli);
+int uci_get_value(struct conf_item *conf_item, const char *sec, const char *opt);
+bool uci_read_bool(struct uci_package *pkg, const char *sec, const char *opt, bool fallback);
+bool is_in_uci_list(struct uci_package *pkg, const char *section, const char *option, const char* is_in);
+void uci_get_config_value(struct config *conf);
+bool uci_init(void);
+void uci_clean(void);
+void clean_all(void);
+
+// Defined in cli.c
+bool readStringValue(struct conf_item *conf_item, const char *value, struct config *newconf);
+
 // Defined in toml_reader.c
 bool readDebugSettings(void);
 void init_config_mutex(void);
--- /dev/null
+++ b/src/config/config_uci.c
@@ -0,0 +1,928 @@
+#include "FTL.h"
+#include "log.h"
+#include "config.h"
+#include "../datastructure.h"
+#include "password.h"
+#include <uci.h>
+#include <uci_blob.h>
+
+static struct blob_buf uci_b;
+static struct uci_ptr uci_ptr;
+struct uci_package *uci_dhcp;
+struct uci_package *uci_network;
+struct uci_package *uci_pihole;
+struct uci_context *uci_ctx;
+
+enum custom_domain_s {
+	DOMAIN_HOST_IP,
+	DOMAIN_HOST_NAME,
+	DOMAIN_HOST_MAX
+} __attribute__ ((packed));
+
+static const struct blobmsg_policy custom_domain_attrs[DOMAIN_HOST_MAX] = {
+	[DOMAIN_HOST_IP] = { .name = "ip", .type = BLOBMSG_TYPE_STRING },
+	[DOMAIN_HOST_NAME] = { .name = "name", .type = BLOBMSG_TYPE_STRING },
+};
+
+const struct uci_blob_param_list custom_domain_attr_list = {
+	.n_params = DOMAIN_HOST_MAX,
+	.params = custom_domain_attrs,
+};
+
+enum cname_s {
+	CNAME_NAME,
+	CNAME_TARGET,
+	CNAME_TTL,
+	CNAME_MAX
+} __attribute__ ((packed));
+
+static const struct blobmsg_policy cname_attrs[CNAME_MAX] = {
+	[CNAME_NAME] = { .name = "cname", .type = BLOBMSG_TYPE_STRING },
+	[CNAME_TARGET] = { .name = "target", .type = BLOBMSG_TYPE_STRING },
+	[CNAME_TTL] = { .name = "ttl", .type = BLOBMSG_TYPE_STRING },
+};
+
+static const struct uci_blob_param_list cname_attr_list = {
+	.n_params = CNAME_MAX,
+	.params = cname_attrs,
+};
+
+enum static_host_s {
+	STATIC_HOST_MAC,
+	STATIC_HOST_IP,
+	STATIC_HOST_NAME,
+	STATIC_HOST_LEASETIME,
+	STATIC_HOST_MAX
+} __attribute__ ((packed));
+
+static const struct blobmsg_policy static_hosts_attrs[STATIC_HOST_MAX] = {
+	[STATIC_HOST_MAC] = { .name = "mac", .type = BLOBMSG_TYPE_STRING },
+	[STATIC_HOST_IP] = { .name = "ip", .type = BLOBMSG_TYPE_STRING },
+	[STATIC_HOST_NAME] = { .name = "name", .type = BLOBMSG_TYPE_STRING },
+	[STATIC_HOST_LEASETIME] = { .name = "leasetime", .type = BLOBMSG_TYPE_STRING },
+};
+
+const struct uci_blob_param_list static_hosts_attr_list = {
+	.n_params = STATIC_HOST_MAX,
+	.params = static_hosts_attrs,
+};
+
+extern void watch_config(bool watch);
+
+// from libuci.c
+static const char *uci_errstr[] = {
+	[UCI_OK] =            "Success",
+	[UCI_ERR_MEM] =       "Out of memory",
+	[UCI_ERR_INVAL] =     "Invalid argument",
+	[UCI_ERR_NOTFOUND] =  "Entry not found",
+	[UCI_ERR_IO] =        "I/O error",
+	[UCI_ERR_PARSE] =     "Parse error",
+	[UCI_ERR_DUPLICATE] = "Duplicate entry",
+	[UCI_ERR_UNKNOWN] =   "Unknown error",
+};
+
+static int uci_init_ptr(struct uci_package *pkg,
+						const char *sec, const char *opt, const char *val)
+{
+	if (!pkg)
+		return -1;
+
+	memset(&uci_ptr, 0, sizeof(uci_ptr));
+	uci_ptr.p = pkg;
+	uci_ptr.section = sec;
+
+	if (uci_ptr.section && *sec == '@')
+		uci_ptr.flags |= UCI_LOOKUP_EXTENDED;
+
+	if (!opt || !opt[0]) {
+		uci_ptr.target = UCI_TYPE_SECTION;
+		goto lookup;
+	}
+
+	uci_ptr.target = UCI_TYPE_OPTION;
+	uci_ptr.option = opt;
+	uci_ptr.value = val;
+
+lookup:
+	int ret = uci_lookup_ptr(uci_ctx, &uci_ptr, NULL, true);
+	if(ret)
+		log_err("uci_init_ptr: section: %s, option: %s, value %s (%s)",
+				 sec, opt, val, uci_errstr[ret]);
+
+	return ret;
+}
+
+static int uci_del_section(struct uci_section *section)
+{
+	if (!section)
+		return -1;
+
+	struct uci_ptr ptr = {
+		.p = section->package,
+		.s = section,
+	};
+
+	if(uci_lookup_ptr(uci_ctx, &ptr, NULL, true) != UCI_OK)
+		return UCI_ERR_PARSE;
+
+	int ret = uci_delete(uci_ctx, &ptr);
+	if(ret)
+		log_err("uci_del_section: section: %s (%s)", ptr.s->type, uci_errstr[ret]);
+
+	return ret;
+}
+
+static void _uci_commit(struct uci_package **pkg)
+{
+	if (!pkg)
+		return;
+
+	watch_config(false);
+	if (uci_commit(uci_ctx, pkg, false))
+		log_err("failed to commit config");
+
+	watch_config(true);
+	uci_load_package(true);
+}
+
+static void uci_read_foreach_to_json(struct conf_item *item, const struct uci_blob_param_list *list,
+									 const char *section)
+{
+	if (item->t != CONF_JSON_STRING_ARRAY)
+		return;
+
+	cJSON_Delete(item->v.json);
+	item->v.json = cJSON_CreateArray();
+
+	struct uci_element *e;
+	// only search in config dhcp
+	uci_foreach_element(&uci_dhcp->sections, e)
+	{
+		// e->name (named section)
+		struct uci_section *s = uci_to_section(e);
+		if (strcmp(s->type, section) != 0)
+			continue;
+
+		// syslog(LOG_INFO, "%s", s->e.name);
+		const char *delim = ",";
+		if(!strcmp(section, "domain"))
+			delim = " ";
+
+		struct blob_attr *tb[STATIC_HOST_MAX], *c;
+		blob_buf_init(&uci_b, 0);
+		uci_to_blob(&uci_b, s, list);
+		blobmsg_parse(list->params, list->n_params, tb, blob_data(uci_b.head), blob_len(uci_b.head));
+
+		static char buffer[512];
+		unsigned pos = 0;
+		buffer[0] = 0;
+
+		for(int i = 0; i < list->n_params; i++)
+		{
+			if ((c = tb[i]))
+				pos += snprintf(&buffer[pos], sizeof(buffer) - pos, "%s%s", blobmsg_get_string(c), delim);
+		}
+
+		// remove last delim
+		if (pos)
+			buffer[pos - 1] = 0;
+
+		cJSON *str = cJSON_CreateString(buffer);
+		cJSON_AddItemToArray(item->v.json, str);
+
+		// not really needed
+		blob_buf_free(&uci_b);
+	}
+}
+
+int uci_config_set(struct uci_package *pkg, const char *sec,
+				   const char *opt, const char *val, const bool list)
+{
+	int ret = uci_init_ptr(pkg, sec, opt, (val) ? (val) : (""));
+	if (ret != UCI_OK)
+		return ret;
+
+	list ? (ret = uci_add_list(uci_ctx, &uci_ptr)) : (ret = uci_set(uci_ctx, &uci_ptr));
+	if(ret == UCI_OK)
+		_uci_commit(&uci_ptr.p);
+	else
+		log_err("uci_config_set: %s.%s=%s (%s)", sec, opt, val, uci_errstr[ret]);
+
+	return ret;
+}
+
+int uci_add_sec_foreach(struct uci_package *pkg, const char *key, const char *target)
+{
+	struct uci_ptr ptr = { .p = pkg, };
+	if(uci_lookup_ptr(uci_ctx, &ptr, NULL, true) != UCI_OK)
+		return UCI_ERR_INVAL;
+
+	const char *section = NULL;
+	const char *delim = ",";
+	if(!strcmp(key, "dns.hosts")) {
+		delim = " ";
+		section = "domain";
+	}
+	else if(!strcmp(key, "dns.cnameRecords"))
+		section = "cname";
+	else
+		return UCI_ERR_INVAL;
+
+	// ptr.section = ptr.s->e.name;
+	if(uci_add_section(uci_ctx, ptr.p, section, &ptr.s) != 0)
+		return UCI_ERR_INVAL;
+
+	char *tmp = NULL;
+	char* strtmp = strdup(target);
+	char *token = strtok_r(strtmp, delim, &tmp);
+	int ret = UCI_ERR_INVAL;
+	for(int i = 0; token != NULL; i++)
+	{
+		if(!strcmp(key, "dns.cnameRecords")) {
+			ptr.value = token;
+			// cname, target, ttl
+			if(i == 0) ptr.option = cname_attrs[i].name;
+			else if(i == 1) ptr.option = cname_attrs[i].name;
+			else if(i == 2) ptr.option = cname_attrs[i].name;
+			else if(i > 2) {
+				log_err("something went wrong with cnameRecords, this should not be happening");
+				free(strtmp);
+				if(!ret)
+					uci_revert(uci_ctx, &ptr);
+				return ret;
+			}
+		} else if(!strcmp(key, "dns.hosts")) {
+			ptr.value = token;
+			// ip, name
+			if(i == 0) ptr.option = custom_domain_attrs[i].name;
+			else if(i == 1) ptr.option = custom_domain_attrs[i].name;
+			else if(i > 1) {
+				log_err("something went wrong with dns hosts, this should not be happening");
+				free(strtmp);
+				if(!ret)
+					uci_revert(uci_ctx, &ptr);
+				return ret;
+			}
+		}
+
+		if(ptr.value && ptr.option)
+			ret = uci_set(uci_ctx, &ptr);
+
+		token = strtok_r(NULL, delim, &tmp);
+	}
+
+	if(ret == UCI_OK)
+		_uci_commit(&ptr.p);
+
+	free(strtmp);
+	return ret;
+}
+
+int uci_del_sec_foreach(struct uci_package *pkg, const char *target)
+{
+	if(!pkg)
+		return -1;
+
+	char* strtmp = strdup(target);
+	const char *a = NULL;
+	const char *b = NULL;
+	if(strchr(strtmp, ',') != NULL) {
+		a = strtok(strtmp, ",");
+		b = strtok(NULL, ",");
+	} else {
+		a = strtok(strtmp, " ");
+		b = strtok(NULL, " ");
+	}
+
+	if(a == NULL || b == NULL) {
+		log_err("failed to delete section for target: %s", target);
+		free(strtmp);
+		return -1;
+	}
+
+	struct uci_element *e;
+	uci_foreach_element(&pkg->sections, e) {
+		const char *tmp1 = NULL;
+		const char *tmp2 = NULL;
+		struct uci_section *s = uci_to_section(e);
+		// only find cname and domain section
+		if (strcmp(s->type, "cname") == 0) {
+			tmp1 = "cname";
+			tmp2 = "target";
+		} else if (strcmp(s->type, "domain") == 0) {
+			tmp1 = "ip";
+			tmp2 = "name";
+		} else
+			continue;
+
+		const char* tmp = uci_lookup_option_string(uci_ctx, s, tmp1);
+		if(!tmp)
+			continue;
+
+		// at least 2 options is belong to this section
+		if(strcmp(tmp, a) == 0)
+		{
+			tmp = uci_lookup_option_string(uci_ctx, s, tmp2);
+			if(tmp && strcmp(tmp, b) == 0)
+			{
+				if(uci_del_section(s) == UCI_OK) {
+					_uci_commit(&pkg);
+					break;
+				}
+			}
+		}
+	}
+
+	free(strtmp);
+	return 0;
+}
+
+bool uci_read_bool(struct uci_package *pkg, const char *sec, const char *opt, bool fallback)
+{
+	if(uci_init_ptr(pkg, sec, opt, NULL) != UCI_OK)
+		return fallback;
+
+	if(!(uci_ptr.flags & UCI_LOOKUP_COMPLETE))
+		return fallback;
+
+	if(uci_ptr.o->type == UCI_TYPE_STRING)
+	{
+		if(strcasecmp(uci_ptr.o->v.string, "false") == 0 || strcmp(uci_ptr.o->v.string, "0") == 0)
+			return false;
+		else if(strcasecmp(uci_ptr.o->v.string, "true") == 0 || strcmp(uci_ptr.o->v.string, "1") == 0)
+			return true;
+	}
+
+	return fallback;
+}
+
+// from https://stackoverflow.com/questions/8465006/
+static char* concat(int count, ...)
+{
+	va_list ap;
+	int i;
+
+	// Find required length to store merged string
+	int len = 1; // room for NULL
+	va_start(ap, count);
+	for(i=0 ; i<count ; i++)
+		len += strlen(va_arg(ap, char*));
+	va_end(ap);
+
+	// Allocate memory to concat strings
+	char *merged = calloc(sizeof(char),len);
+	int null_pos = 0;
+
+	// Actually concatenate strings
+	va_start(ap, count);
+	for(i=0 ; i<count ; i++)
+	{
+		char *s = va_arg(ap, char*);
+		strcpy(merged+null_pos, s);
+		null_pos += strlen(s);
+	}
+	va_end(ap);
+
+	return merged;
+}
+
+// use this function or add a new key in struct conf_item
+static void set_uci_type_name(struct conf_item *item, const char **section, char **option)
+{
+	unsigned int level = config_path_depth(item->p);
+
+	const char *delim = "_";
+	*section = "pihole";
+	if(item->f & FLAG_RESTART_FTL)
+	{
+		*section = "dnsmasq";
+		if(item == &config.dns.cache.size)
+			*option = strdup("cachesize");
+		else if(item == &config.files.log.dnsmasq)
+			*option = strdup("logfacility");
+		else if(strcmp(item->k, "dns.upstreams") == 0)
+			*option = strdup("server");
+		else {
+			char *tmp_opt= malloc(strlen(item->p[level-1]) + 1);
+			strcpy(tmp_opt, item->p[level-1]);
+			strtolower(tmp_opt);
+			*option = strdup(tmp_opt);
+			free(tmp_opt);
+		}
+	}
+	else if(item == &config.files.pid)
+		*option = strdup("pidfile");
+	else if(item == &config.files.log.ftl)
+		*option = strdup("logfile");
+	else if(item == &config.files.log.webserver) {
+		*section = "webserver";
+		*option = strdup("logfile");
+	}
+	else if(level == 4)
+	{
+		// webserver.api.xxx.xxx
+		if(strcmp(item->p[level - 4], "webserver") == 0) {
+			*section = "api";
+			*option = concat(3, item->p[level - 2], delim, item->p[level - 1]);
+		} else
+			// dns.reply.xxx.xxx
+			*option = concat(5, item->p[level - 3], delim, item->p[level - 2], delim, item->p[level - 1]);
+	}
+	else if(level == 3)
+	{
+		if(strcmp(item->p[level - 3], "webserver") == 0)
+		{
+			if(strcmp(item->p[level - 2], "api") == 0)
+				*section = "api";
+			else
+				*section = "webserver";
+
+			*option = strdup(item->p[level - 1]);
+		}
+		// database.network.xxx
+		else if(strcmp(item->p[level - 3], "database") == 0) {
+			*section = "database";
+			*option = concat(3, item->p[level - 2], delim, item->p[level - 1]);
+		}
+		else
+			*option = concat(3, item->p[level - 2], delim, item->p[level - 1]);
+	}
+	else
+	{
+		if(strcmp(item->p[level - 2], "debug") == 0)
+			*section = "debug";
+		else if(strcmp(item->p[level - 2], "webserver") == 0)
+			*section = "webserver";
+		else if(strcmp(item->p[level - 2], "database") == 0 ||
+				strcmp(item->p[level - 2], "files") == 0)
+			*section = "database";
+
+		*option = strdup(item->p[level - 1]);
+	}
+}
+
+int uci_set_value(struct conf_item *item, const char *value, bool cli)
+{
+	if(cli)
+	{
+		if(uci_ctx == NULL)
+			uci_ctx = uci_alloc_context();
+
+		uci_load_package(false);
+	}
+
+	const char *sec = NULL;
+	char *opt = NULL;
+	set_uci_type_name(item, &sec, &opt);
+
+	struct uci_ptr ptr = {
+		.option = opt,
+		.target = UCI_TYPE_OPTION,
+	};
+
+	if(item->f & FLAG_RESTART_FTL)
+		ptr.p = uci_dhcp;
+	else
+		ptr.p = uci_pihole;
+
+	// create section if not exist
+	struct uci_section *s = get_uci_section_type(ptr.p, sec);
+	if(!s && uci_add_section(uci_ctx, ptr.p, sec, &s)) {
+		log_err("failed to create section: %s", sec);
+		free(opt);
+		return -1;
+	}
+
+	ptr.s = s;
+
+	switch(item->t)
+	{
+		case CONF_BOOL:
+		case CONF_ALL_DEBUG_BOOL:
+			ptr.value = item->v.b ? "1" : "0";
+			break;
+		case CONF_STRING:
+		case CONF_STRING_ALLOCATED:
+			ptr.value = item->v.s;
+			break;
+		case CONF_ENUM_BLOCKING_MODE:
+			ptr.value = get_blocking_mode_str(item->v.blocking_mode);
+			break;
+		case CONF_ENUM_WEB_THEME:
+			ptr.value = get_web_theme_str(item->v.web_theme);
+			break;
+		case CONF_ENUM_PTR_TYPE:
+			ptr.value = get_ptr_type_str(item->v.ptr_type);
+			break;
+		case CONF_ENUM_LISTENING_MODE:
+			ptr.value = get_listeningMode_str(item->v.listeningMode);
+			break;
+		case CONF_ENUM_BUSY_TYPE:
+			ptr.value = get_busy_reply_str(item->v.busy_reply);
+			break;
+		case CONF_ENUM_REFRESH_HOSTNAMES:
+			ptr.value = get_refresh_hostnames_str(item->v.refresh_hostnames);
+			break;
+		case CONF_INT:
+		case CONF_ENUM_PRIVACY_LEVEL:
+		case CONF_ENUM_TEMP_UNIT:
+		{
+			char *buf;
+			if (asprintf(&buf, "%i", item->v.i) > 0)
+				ptr.value = buf;
+			free(buf);
+			break;
+		}
+		case CONF_UINT:
+		{
+			char *buf;
+			if (asprintf(&buf, "%u", item->v.ui) > 0)
+				ptr.value = buf;
+			free(buf);
+			break;
+		}
+		case CONF_DOUBLE:
+		{
+			char *buf;
+			if (asprintf(&buf, "%f", item->v.d) > 0)
+				ptr.value = buf;
+			free(buf);
+			break;
+		}
+		case CONF_UINT16:
+		{
+			char *buf;
+			if (asprintf(&buf, "%u", item->v.ui) > 0)
+				ptr.value = buf;
+			free(buf);
+			break;
+		}
+		case CONF_LONG:
+		{
+			char *buf;
+			if (asprintf(&buf, "%li", item->v.l) > 0)
+				ptr.value = buf;
+			free(buf);
+			break;
+		}
+		case CONF_ULONG:
+		{
+			char *buf;
+			if (asprintf(&buf, "%lu", item->v.ul) > 0)
+				ptr.value = buf;
+			free(buf);
+			break;
+		}
+		case CONF_STRUCT_IN_ADDR:
+		{
+			char addr4[INET_ADDRSTRLEN] = { 0 };
+			inet_ntop(AF_INET, &item->v.in_addr, addr4, INET_ADDRSTRLEN);
+			ptr.value = addr4;
+
+			break;
+		}
+		case CONF_STRUCT_IN6_ADDR:
+		{
+			char addr6[INET6_ADDRSTRLEN] = { 0 };
+			inet_ntop(AF_INET6, &item->v.in6_addr, addr6, INET6_ADDRSTRLEN);
+			ptr.value = addr6;
+
+			break;
+		}
+		case CONF_PASSWORD:
+		case CONF_JSON_STRING_ARRAY:
+			break;
+	}
+
+	int ret = UCI_ERR_INVAL;
+	if(item->t == CONF_JSON_STRING_ARRAY && !uci_lookup_ptr(uci_ctx, &ptr, NULL, true))
+	{
+		ret = uci_delete(uci_ctx, &ptr);
+		for(int i = 0; i < cJSON_GetArraySize(item->v.json); i++)
+		{
+			cJSON *server = cJSON_GetArrayItem(item->v.json, i);
+			if(server != NULL && cJSON_IsString(server)) {
+				ptr.value = server->valuestring;
+				if(!uci_lookup_ptr(uci_ctx, &ptr, NULL, true))
+					ret = uci_add_list(uci_ctx, &ptr);
+			}
+		}
+	} else if(item->t == CONF_PASSWORD) {
+		// from cli.c
+		item--;
+		char *pwhash = strlen(value) > 0 ? create_password(value) : strdup("");
+		if(verify_password(value, pwhash, false)) {
+			ptr.option = "pwhash";
+			ptr.value = pwhash;
+			if(!uci_lookup_ptr(uci_ctx, &ptr, NULL, true))
+				ret = uci_set(uci_ctx, &ptr);
+		}
+
+		free(pwhash);
+	} else if(!uci_lookup_ptr(uci_ctx, &ptr, NULL, true))
+		ret = uci_set(uci_ctx, &ptr);
+
+	if(ret == UCI_OK)
+		_uci_commit(&ptr.p);
+	else
+		log_err("uci_set_value: %s", uci_errstr[ret]);
+
+	if(cli)
+		uci_clean();
+
+	free(opt);
+	return ret;
+}
+
+void uci_get_config_value(struct config *conf)
+{
+	for(unsigned int i = 0; i < CONFIG_ELEMENTS; i++)
+	{
+		struct conf_item *cfg_item = get_conf_item(conf, i);
+		if(cfg_item == &config.dns.cnameRecords ||
+		   cfg_item == &config.dns.hosts ||
+		   cfg_item == &config.dhcp.hosts)
+			continue;
+
+		const char *sec = NULL;
+		char *opt = NULL;
+		set_uci_type_name(cfg_item, &sec, &opt);
+
+		uci_get_value(cfg_item, sec, opt);
+
+		free(opt);
+	}
+
+	uci_read_foreach_to_json(&config.dns.hosts, &custom_domain_attr_list, "domain");
+	uci_read_foreach_to_json(&config.dns.cnameRecords, &cname_attr_list, "cname");
+	uci_read_foreach_to_json(&config.dhcp.hosts, &static_hosts_attr_list, "host");
+
+	set_debug_flags(conf);
+}
+
+int uci_get_value(struct conf_item *conf_item, const char *sec, const char *opt)
+{
+	struct uci_ptr ptr = {
+		.option = opt,
+	};
+
+	if(conf_item->f & FLAG_RESTART_FTL)
+		ptr.p = uci_dhcp;
+	else
+		ptr.p = uci_pihole;
+
+	struct uci_section *s = get_uci_section_type(ptr.p, sec);
+	if(!s) {
+		log_warn("there is no section: %s, using default value for: %s", sec, opt);
+		return UCI_ERR_INVAL;
+	}
+
+	ptr.s = s;
+
+	if(uci_lookup_ptr(uci_ctx, &ptr, NULL, true) != UCI_OK)
+		return UCI_ERR_PARSE;
+
+	if(!(ptr.flags & UCI_LOOKUP_COMPLETE))
+		return UCI_ERR_NOTFOUND;
+
+	if(conf_item->t == CONF_JSON_STRING_ARRAY && ptr.o->type == UCI_TYPE_LIST)
+	{
+		struct uci_element *e;
+		struct uci_list *list = &ptr.o->v.list;
+		cJSON_Delete(conf_item->v.json);
+		conf_item->v.json = cJSON_CreateArray();
+		uci_foreach_element(list, e)
+		{
+			if(!e->name)
+				continue;
+
+			cJSON *item = cJSON_CreateString(e->name);
+			cJSON_AddItemToArray(conf_item->v.json, item);
+		}
+	}
+	else if(ptr.o->type == UCI_TYPE_STRING && ptr.o->v.string &&
+		    conf_item->t != CONF_JSON_STRING_ARRAY)
+		return readStringValue(conf_item, ptr.o->v.string, &config) ? 0 : UCI_ERR_PARSE;
+
+	return 0;
+}
+
+const char *uci_get_string(struct uci_package *pkg, const char *sec, const char *opt)
+{
+	if(!sec || !opt)
+		return NULL;
+
+	if(uci_init_ptr(pkg, sec, opt, NULL) != UCI_OK)
+		return NULL;
+
+	if(!(uci_ptr.flags & UCI_LOOKUP_COMPLETE))
+		return NULL;
+
+	if(uci_ptr.o->type == UCI_TYPE_STRING && uci_ptr.o->v.string)
+		return uci_ptr.o->v.string;
+	else if(uci_ptr.o->type == UCI_TYPE_LIST)
+	{
+		struct uci_element *e = NULL;
+		struct uci_list *list = &uci_ptr.o->v.list;
+		static char buffer[512];
+		unsigned pos = 0;
+
+		buffer[0] = 0;
+		uci_foreach_element(list, e)
+			if (e->name)
+				pos += snprintf(&buffer[pos], sizeof(buffer) - pos, "%s%s", e->name, ",");
+
+		if (pos)
+			buffer[pos - 1] = 0;
+
+		return buffer;
+	}
+
+	return NULL;
+}
+
+bool is_in_uci_list(struct uci_package *pkg, const char *sec, const char *opt, const char* is_in)
+{
+	if(uci_init_ptr(pkg, sec, opt, NULL) != UCI_OK)
+		return false;
+
+	if(!(uci_ptr.flags & UCI_LOOKUP_COMPLETE))
+		return false;
+
+	if (uci_ptr.o && uci_ptr.o->type == UCI_TYPE_LIST)
+	{
+		struct uci_element *e;
+		struct uci_list *list = &uci_ptr.o->v.list;
+		uci_foreach_element(list, e)
+			if(is_in != NULL && strcasecmp(e->name, is_in) == 0)
+				return true;
+	}
+
+	return false;
+}
+
+static void unload_packages(void)
+{
+	uci_pihole = uci_lookup_package(uci_ctx, "pihole");
+	if (uci_pihole)
+		uci_unload(uci_ctx, uci_pihole);
+
+	uci_network = uci_lookup_package(uci_ctx, "network");
+	if (uci_network)
+		uci_unload(uci_ctx, uci_network);
+
+	uci_dhcp = uci_lookup_package(uci_ctx, "dhcp");
+	if (uci_dhcp)
+		uci_unload(uci_ctx, uci_dhcp);
+}
+
+bool uci_load_package(bool reload)
+{
+	if(reload)
+		unload_packages();
+
+	int ret = uci_load(uci_ctx, "dhcp", &uci_dhcp);
+	if(ret)
+		log_err("failed to load dhcp config (%s)", uci_errstr[ret]);
+
+	ret = uci_load(uci_ctx, "pihole", &uci_pihole);
+	if(ret)
+		log_err("failed to load pihole config (%s)", uci_errstr[ret]);
+
+	ret = uci_load(uci_ctx, "network", &uci_network);
+	if(ret)
+		log_err("failed to load pihole config (%s)", uci_errstr[ret]);
+
+	return (ret == 0) ? true : false;
+}
+
+bool uci_init(void)
+{
+	if (uci_ctx == NULL) {
+		uci_ctx = uci_alloc_context();
+		if (!uci_ctx)
+			return false;
+	}
+
+	return uci_load_package(false);
+}
+
+extern char *username;
+extern const char **argv_dnsmasq;
+void clean_all(void)
+{
+	// clean all "still reachable" that valgrind detects
+	// is this really needed ?
+	for(unsigned int i = 0; i < CONFIG_ELEMENTS; i++)
+	{
+		struct conf_item *copy_item = get_conf_item(&config, i);
+
+		if(copy_item->a != NULL)
+			cJSON_Delete(copy_item->a);
+
+		if(copy_item->p != NULL)
+		{
+			free_config_path(copy_item->p);
+			free(copy_item->p);
+		}
+
+		switch(copy_item->t)
+		{
+			case CONF_BOOL:
+			case CONF_INT:
+			case CONF_UINT:
+			case CONF_UINT16:
+			case CONF_LONG:
+			case CONF_ULONG:
+			case CONF_DOUBLE:
+			case CONF_STRING:
+			case CONF_PASSWORD:
+			case CONF_ENUM_PTR_TYPE:
+			case CONF_ENUM_BUSY_TYPE:
+			case CONF_ENUM_BLOCKING_MODE:
+			case CONF_ENUM_REFRESH_HOSTNAMES:
+			case CONF_ENUM_PRIVACY_LEVEL:
+			case CONF_ENUM_LISTENING_MODE:
+			case CONF_ENUM_WEB_THEME:
+			case CONF_ENUM_TEMP_UNIT:
+			case CONF_STRUCT_IN_ADDR:
+			case CONF_STRUCT_IN6_ADDR:
+			case CONF_ALL_DEBUG_BOOL:
+				break;
+			case CONF_STRING_ALLOCATED:
+				free(copy_item->v.s);
+				break;
+			case CONF_JSON_STRING_ARRAY:
+				cJSON_Delete(copy_item->d.json);
+				cJSON_Delete(copy_item->v.json);
+				break;
+		}
+	}
+
+	if(argv_dnsmasq != NULL)
+		free(argv_dnsmasq);
+
+	if(username != NULL)
+		free(username);
+}
+
+void uci_clean(void)
+{
+	unload_packages();
+
+	if (uci_ctx)
+		uci_free_context(uci_ctx);
+
+	uci_ctx = NULL;
+}
+
+struct uci_section * __attribute__((pure)) get_uci_section_type(struct uci_package *pkg, const char *s)
+{
+	if(!pkg)
+		return NULL;
+
+	struct uci_element *e;
+	uci_foreach_element(&pkg->sections, e)
+	{
+		struct uci_section *section = uci_to_section(e);
+		if (strcmp(section->type, s) == 0)
+			return section;
+	}
+
+	return NULL;
+}
+
+// https://stackoverflow.com/questions/9210528/split-string-with-delimiters-in-c
+int split_comma(const char *txt, char delim, char ***ptr)
+{
+    int *tklen, *t, count = 1;
+    char **arr, *p = (char *)txt;
+
+    while (*p != '\0') {
+		if (*p++ == delim)
+			count += 1;
+    }
+
+    t = tklen = calloc(count, sizeof(int));
+
+    for (p = (char *)txt; *p != '\0'; p++)
+		*p == delim ? *t++ : (*t)++;
+
+    *ptr = arr = malloc(count * sizeof(char *));
+    t = tklen;
+    p = *arr++ = calloc(*(t++) + 1, sizeof(char *));
+
+    while (*txt != '\0')
+    {
+        if (*txt == delim)
+        {
+            p = *arr++ = calloc(*(t++) + 1, sizeof(char *));
+            txt++;
+        }
+        else
+			*p++ = *txt++;
+    }
+
+    free (tklen);
+    return count;
+}
--- a/src/config/dnsmasq_config.c
+++ b/src/config/dnsmasq_config.c
@@ -35,6 +35,9 @@
 #include <unistd.h>
 // wait
 #include <sys/wait.h>
+#include <uci.h>
+ 
+extern const char *hostname(void);
 
 #define HEADER_WIDTH 80
 
@@ -212,12 +215,11 @@ static void write_config_header(FILE *fp
 	CONFIG_CENTER(fp, HEADER_WIDTH, "%s", "ANY CHANGES MADE TO THIS FILE WILL BE LOST WHEN THE CONFIGURATION CHANGES");
 	CONFIG_CENTER(fp, HEADER_WIDTH, "%s", "");
 	CONFIG_CENTER(fp, HEADER_WIDTH, "%s", "IF YOU WISH TO CHANGE ANY OF THESE VALUES, CHANGE THEM IN");
-	CONFIG_CENTER(fp, HEADER_WIDTH, "%s", "/etc/pihole/pihole.toml");
+	CONFIG_CENTER(fp, HEADER_WIDTH, "%s", "/etc/config/pihole or /etc/config/dhcp");
 	CONFIG_CENTER(fp, HEADER_WIDTH, "%s", "and restart pihole-FTL");
 	CONFIG_CENTER(fp, HEADER_WIDTH, "%s", "");
 	CONFIG_CENTER(fp, HEADER_WIDTH, "%s", "ANY OTHER CHANGES SHOULD BE MADE IN A SEPARATE CONFIG FILE");
 	CONFIG_CENTER(fp, HEADER_WIDTH, "%s", "WITHIN /tmp/dnsmasq.d/yourname.conf");
-	CONFIG_CENTER(fp, HEADER_WIDTH, "%s", "(make sure misc.etc_dnsmasq_d is set to true in /etc/pihole/pihole.toml)");
 	CONFIG_CENTER(fp, HEADER_WIDTH, "%s", "");
 	CONFIG_CENTER(fp, HEADER_WIDTH, "Last updated: %s", timestring);
 	CONFIG_CENTER(fp, HEADER_WIDTH, "by FTL version %s", FTL_VERSION);
@@ -225,75 +227,170 @@ static void write_config_header(FILE *fp
 	CONFIG_CENTER(fp, HEADER_WIDTH, "%s", "################################################################################");
 }
 
-bool __attribute__((const)) write_dnsmasq_config(struct config *conf, bool test_config, char errbuf[ERRBUF_SIZE])
+static int ipv4_mask_to_prfx(const char *prefix)
 {
-	// Early config checks
-	if(conf->dhcp.active.v.b)
-	{
-		// Check if the addresses are valid
-		// The addresses should neither be 0.0.0.0 nor 255.255.255.255
-		if((ntohl(conf->dhcp.start.v.in_addr.s_addr) == 0) ||
-		   (ntohl(conf->dhcp.start.v.in_addr.s_addr) == 0xFFFFFFFF))
-		{
-			strncpy(errbuf, "DHCP start address is not valid", ERRBUF_SIZE);
-			log_err("Unable to update dnsmasq configuration: %s", errbuf);
-			return false;
-		}
-		if((ntohl(conf->dhcp.end.v.in_addr.s_addr) == 0) ||
-		   (ntohl(conf->dhcp.end.v.in_addr.s_addr) == 0xFFFFFFFF))
-		{
-			strncpy(errbuf, "DHCP end address is not valid", ERRBUF_SIZE);
-			log_err("Unable to update dnsmasq configuration: %s", errbuf);
-			return false;
-		}
-		if((ntohl(conf->dhcp.router.v.in_addr.s_addr) == 0) ||
-		   (ntohl(conf->dhcp.router.v.in_addr.s_addr) == 0xFFFFFFFF))
-		{
-			strncpy(errbuf, "DHCP router address is not valid", ERRBUF_SIZE);
-			log_err("Unable to update dnsmasq configuration: %s", errbuf);
-			return false;
-		}
-		// The addresses should neither end in .0 or .255 in the last octet
-		if((ntohl(conf->dhcp.start.v.in_addr.s_addr) & 0xFF) == 0 ||
-		   (ntohl(conf->dhcp.start.v.in_addr.s_addr) & 0xFF) == 0xFF)
-		{
-			strncpy(errbuf, "DHCP start address is not valid", ERRBUF_SIZE);
-			log_err("Unable to update dnsmasq configuration: %s", errbuf);
-			return false;
-		}
-		if((ntohl(conf->dhcp.end.v.in_addr.s_addr) & 0xFF) == 0 ||
-		   (ntohl(conf->dhcp.end.v.in_addr.s_addr) & 0xFF) == 0xFF)
-		{
-			strncpy(errbuf, "DHCP end address is not valid", ERRBUF_SIZE);
-			log_err("Unable to update dnsmasq configuration: %s", errbuf);
-			return false;
-		}
-		if((ntohl(conf->dhcp.router.v.in_addr.s_addr) & 0xFF) == 0 ||
-		   (ntohl(conf->dhcp.router.v.in_addr.s_addr) & 0xFF) == 0xFF)
-		{
-			strncpy(errbuf, "DHCP router address is not valid", ERRBUF_SIZE);
-			log_err("Unable to update dnsmasq configuration: %s", errbuf);
-			return false;
-		}
+	struct in_addr in;
+	if (inet_pton(AF_INET, prefix, &in) == 0)
+		return -1;
 
-		// Check if the DHCP range is valid (start needs to be smaller than end)
-		if(ntohl(conf->dhcp.start.v.in_addr.s_addr) >= ntohl(conf->dhcp.end.v.in_addr.s_addr))
-		{
-			strncpy(errbuf, "DHCP range start address is larger than or equal to the end address", ERRBUF_SIZE);
-			log_err("Unable to update dnsmasq configuration: %s", errbuf);
-			return false;
+	int c = 0;
+	unsigned int seen_one = 0;
+	uint32_t i = ntohl(in.s_addr);
+
+	while (i > 0) {
+		if (i & 1) {
+			seen_one = 1;
+			c++;
+		} else {
+			if (seen_one) {
+				return -1;
+			}
 		}
+		i >>= 1;
+	}
+
+	return c;
+}
+
+static void write_config_dhcp(FILE *fp)
+{
+	if(!config.dhcp.active.v.b)
+		return;
+
+	if(uci_read_bool(uci_dhcp, "@dnsmasq[0]", "quietdhcp", false))
+		fputs("quiet-dhcp\n", fp);
+
+	if(uci_read_bool(uci_dhcp, "@dnsmasq[0]", "fqdn", false))
+		fputs("dhcp-fqdn\n", fp);
+
+	if(uci_read_bool(uci_dhcp, "@dnsmasq[0]", "logdhcp", false))
+		fputs("log-dhcp\n", fp);
+
+	if(uci_read_bool(uci_dhcp, "@dnsmasq[0]", "sequential_ip", false))
+		fputs("dhcp-sequential-ip\n", fp);
+
+	struct uci_element *ep;
+	uci_foreach_element(&uci_dhcp->sections, ep)
+	{
+		struct uci_section *s = uci_to_section(ep);
+		if (strcmp(s->type, "host") == 0)
+			continue;
 
-		// Check if the router address is within the DHCP range
-		if(ntohl(conf->dhcp.router.v.in_addr.s_addr) >= ntohl(conf->dhcp.start.v.in_addr.s_addr) &&
-		   ntohl(conf->dhcp.router.v.in_addr.s_addr) <= ntohl(conf->dhcp.end.v.in_addr.s_addr))
+		if(strcmp(ep->name, "wan") == 0) {
+			const char *proto = uci_get_string(uci_network, "wan", "proto");
+			if(proto && strcmp(proto, "pppoe") == 0 && uci_read_bool(uci_dhcp, ep->name, "ignore", false))
+				fputs("no-dhcp-interface=pppoe-wan\n", fp);
+		}
+
+		bool skipped_dhcp = false;
+		int dhcp_start = 0, dhcp_limit = 0;
+		const char *iface = NULL;
+		const char *domain_iface = NULL;
+		const char *leasetime = NULL;
+		struct uci_element *eo;
+		uci_foreach_element(&s->options, eo)
 		{
-			strncpy(errbuf, "DHCP router address should not be within DHCP range", ERRBUF_SIZE);
-			log_err("Unable to update dnsmasq configuration: %s", errbuf);
-			return false;
+			struct uci_option* opt = uci_to_option(eo);
+			if(opt->type == UCI_TYPE_STRING && opt->v.string)
+			{
+				if (strcmp(s->type, "dhcp") == 0)
+				{
+					if(strcmp(opt->e.name, "ignore") == 0 && strcmp(opt->v.string, "1") == 0) {
+						skipped_dhcp = true;
+						break;
+					}
+
+					if(strcmp(opt->e.name, "interface") == 0)
+						iface = opt->v.string;
+					else if(strcmp(opt->e.name, "start") == 0)
+						dhcp_start = atoi(opt->v.string);
+					else if(strcmp(opt->e.name, "limit") == 0)
+						dhcp_limit = atoi(opt->v.string);
+					else if(strcmp(opt->e.name, "leasetime") == 0)
+						leasetime = opt->v.string;
+					else if(strcmp(opt->e.name, "domain_iface") == 0)
+						domain_iface = opt->v.string;
+				}
+				else if (strcmp(s->type, "dnsmasq") == 0)
+				{
+					if(strcmp(opt->e.name, "dhcpleasemax") == 0)
+						fprintf(fp, "dhcp-lease-max=%s\n", opt->v.string);
+					else if(strcmp(opt->e.name, "dhcp_boot") == 0)
+						fprintf(fp, "dhcp-boot=%s\n", opt->v.string);
+				}
+			}
+			else if(opt->type == UCI_TYPE_LIST)
+			{
+				const char *networkid = NULL;
+				const char *vendorclass = NULL;
+				if (strcmp(s->type, "vendorclass") == 0)
+				{
+					networkid = uci_lookup_option_string(uci_ctx, s, "networkid");
+					vendorclass = uci_lookup_option_string(uci_ctx, s, "vendorclass");
+					if(networkid && vendorclass)
+						fprintf(fp, "dhcp-vendorclass=set:%s,%s\n", networkid, vendorclass);
+				}
+
+				struct uci_element *el;
+				uci_foreach_element(&opt->v.list, el) {
+					if (!el->name)
+						continue;
+
+					if(strcmp(s->type, "vendorclass") == 0 && networkid && vendorclass)
+						fprintf(fp, "dhcp-option=%s,%s\n", networkid, el->name);
+
+					if(iface != NULL && strcmp(opt->e.name, "dhcp_option") == 0)
+						fprintf(fp, "dhcp-option=%s,%s\n", iface, el->name);
+				}
+			}
 		}
+
+		if(iface == NULL)
+			continue;
+
+		const char *ipaddr = uci_get_string(uci_network, iface, "ipaddr");
+		const char *netmask = uci_get_string(uci_network, iface, "netmask");
+		if(skipped_dhcp || !ipaddr || !netmask)
+			continue;
+
+		struct in_addr addr4, mask, net;
+		memset(&addr4, 0, sizeof(addr4));
+		if(!inet_pton(AF_INET, ipaddr, &addr4))
+			continue;
+
+		int prfx = ipv4_mask_to_prfx(netmask);
+		char ip_net[INET_ADDRSTRLEN] = { 0 },
+		     ip_start[INET_ADDRSTRLEN] = { 0 },
+		     ip_end[INET_ADDRSTRLEN] = { 0 };
+		mask.s_addr = htonl(~((1 << (32 - prfx)) - 1));
+		memset(&net, 0, sizeof(net));
+		net.s_addr = addr4.s_addr & mask.s_addr;
+
+		addr4.s_addr = htonl(ntohl(net.s_addr));
+		inet_ntop(AF_INET, &addr4.s_addr, ip_net, INET_ADDRSTRLEN);
+
+		addr4.s_addr = htonl(ntohl(net.s_addr) + dhcp_start);
+		inet_ntop(AF_INET, &addr4.s_addr, ip_start, INET_ADDRSTRLEN);
+
+		addr4.s_addr = htonl(ntohl(net.s_addr) + dhcp_start + dhcp_limit - 1);
+		inet_ntop(AF_INET, &addr4.s_addr, ip_end, INET_ADDRSTRLEN);
+
+		// dhcp-range=set:lan,192.168.0.10,192.168.0.19,255.255.255.0,24h
+		fprintf(fp, "dhcp-range=set:%s,%s,%s,%s,%s\n", iface, ip_start,
+				ip_end, netmask, leasetime);
+
+		fprintf(fp, "dhcp-option=%s,option:router,%s\n", iface, ipaddr);
+
+		// domain=lan,192.168.0.0/24,local
+		// domain=lan,192.168.0.1,192,168.0.50,local
+		// needs expandhosts in order to work without manually adding domain to host
+		if(config.dns.domainNeeded.v.b && domain_iface != NULL)
+			fprintf(fp, "domain=%s,%s/%i,local\n", domain_iface, ip_net, prfx);
 	}
+}
 
+bool __attribute__((const)) write_dnsmasq_config(struct config *conf, bool test_config, char errbuf[ERRBUF_SIZE])
+{
 	log_debug(DEBUG_CONFIG, "Opening "DNSMASQ_TEMP_CONF" for writing");
 	FILE *pihole_conf = fopen(DNSMASQ_TEMP_CONF, "w");
 	// Return early if opening failed
@@ -312,7 +409,6 @@ bool __attribute__((const)) write_dnsmas
 	}
 
 	write_config_header(pihole_conf, "Dnsmasq config for Pi-hole's FTLDNS");
-	fputs("addn-hosts=/etc/pihole/local.list\n", pihole_conf);
 	fputs("hostsdir="DNSMASQ_HOSTSDIR"\n", pihole_conf);
 	fputs("\n", pihole_conf);
 	fputs("# Don't read /etc/resolv.conf. Get upstream servers only from the configuration\n", pihole_conf);
@@ -365,7 +461,7 @@ bool __attribute__((const)) write_dnsmas
 		fputs("\n", pihole_conf);
 	}
 
-	if(strlen(conf->files.log.dnsmasq.v.s) > 0)
+	if(conf->files.log.dnsmasq.v.s != NULL && strlen(conf->files.log.dnsmasq.v.s) > 0)
 	{
 		fputs("# Specify the log file to use\n", pihole_conf);
 		fputs("# We set this even if logging is disabled to store warnings\n", pihole_conf);
@@ -424,10 +520,17 @@ bool __attribute__((const)) write_dnsmas
 		fputs("\n", pihole_conf);
 	}
 
-	const char *interface = conf->dns.interface.v.s;
-	// Use eth0 as fallback interface if the interface is missing
-	if(strlen(interface) == 0)
-		interface = "eth0";
+	fputs("\n", pihole_conf);
+ 
+	const char *interface = uci_get_string(uci_dhcp, "@dnsmasq[0]", "interface");
+	// Use br-lan as fallback interface if the interface is missing
+	if(interface == NULL)
+		interface = "br-lan";
+
+	// with split_comma approach instead of uci_foreach_element,
+	// we have a fallback interface in case there is no interface option
+	char **comma;
+	int count = split_comma(interface, ',', &comma);
 
 	switch(conf->dns.listeningMode.v.listeningMode)
 	{
@@ -442,12 +545,15 @@ bool __attribute__((const)) write_dnsmas
 			break;
 		case LISTEN_SINGLE:
 			fputs("# Listen on one interface\n", pihole_conf);
-			fprintf(pihole_conf, "interface=%s\n", interface);
+			fprintf(pihole_conf, "interface=%s\n", comma[0]);
 			break;
 		case LISTEN_BIND:
-			fputs("# Bind to one interface\n", pihole_conf);
-			fprintf(pihole_conf, "interface=%s\n", interface);
+			// interface is handled later
+			fputs("# Bind to interface(s)\n", pihole_conf);
 			fputs("bind-interfaces\n", pihole_conf);
+			for (int i = 0; i < count; i++)
+				fprintf(pihole_conf, "interface=%s\n", comma[i]);
+
 			break;
 		case LISTEN_NONE:
 			fputs("# No interface configuration applied, make sure to cover this yourself\n", pihole_conf);
@@ -455,6 +561,11 @@ bool __attribute__((const)) write_dnsmas
 	}
 	fputs("\n", pihole_conf);
 
+	// always freeing char pointer when using split_comma
+	for (int i = 0; i < count; i++)
+		free (comma[i]);
+	free (comma);
+
 	if(conf->dns.revServer.active.v.b)
 	{
 		fputs("# Reverse server setting\n", pihole_conf);
@@ -479,13 +590,19 @@ bool __attribute__((const)) write_dnsmas
 	// ticked, we add `local=/domain/` to signal that this domain is purely
 	// local and FTL may answer queries from /etc/hosts or DHCP but should
 	// never forward queries on that domain to any upstream servers
-	if(conf->dns.domainNeeded.v.b)
+	const char *local_dom = uci_get_string(uci_dhcp, "@dnsmasq[0]", "local");
+	if(conf->dns.domainNeeded.v.b && (local_dom != NULL || strlen(conf->dns.domain.v.s) > 0))
 	{
 		fputs("# Never forward A or AAAA queries for plain names, without\n",pihole_conf);
 		fputs("# dots or domain parts, to upstream nameservers. If the name\n", pihole_conf);
 		fputs("# is not known from /etc/hosts or DHCP a NXDOMAIN is returned\n", pihole_conf);
-		if(strlen(conf->dns.domain.v.s))
+		if(strlen(conf->dns.domain.v.s)) {
+			if(local_dom != NULL) {
+				fprintf(pihole_conf, "local=%s\n", local_dom);
+			} else {
 			fprintf(pihole_conf, "local=/%s/\n\n", conf->dns.domain.v.s);
+			}
+		}
 		else
 			fputs("\n", pihole_conf);
 	}
@@ -498,30 +615,169 @@ bool __attribute__((const)) write_dnsmas
 		fprintf(pihole_conf, "domain=%s\n\n", conf->dns.domain.v.s);
 	}
 
+	bool rebind_protection = uci_read_bool(uci_dhcp, "@dnsmasq[0]", "rebind_protection", true);
+	if(rebind_protection)
+	{
+		fputs("# Discard upstream RFC1918 responses!\n", pihole_conf);
+		fputs("stop-dns-rebind\n", pihole_conf);
+		fputs("\n", pihole_conf);
+		if(uci_read_bool(uci_dhcp, "@dnsmasq[0]", "rebind_localhost", false))
+		{
+			fputs("# Allowing 127.0.0.0/8 responses\n", pihole_conf);
+			fputs("rebind-localhost-ok\n", pihole_conf);
+		}
+	}
+	fputs("\n", pihole_conf);
+
+	if(!conf->dns.dnssec.v.b)
+	{
+		if(uci_read_bool(uci_dhcp, "@dnsmasq[0]", "proxydnssec", false)) {
+			fputs("proxy-dnssec\n", pihole_conf);
+			const char *cpe_id = uci_get_string(uci_dhcp, "@dnsmasq[0]", "proto");
+			if(cpe_id != NULL)
+				fprintf(pihole_conf, "add-cpe-id=%s\n", cpe_id);
+		}
+	}
+
+	if(uci_read_bool(uci_dhcp, "@dnsmasq[0]", "ubus", true))
+		fputs("enable-ubus\n", pihole_conf);
+
+	if(uci_read_bool(uci_dhcp, "@dnsmasq[0]", "nonwildcard", true))
+		fputs("bind-dynamic\n", pihole_conf);
+
+	if(uci_read_bool(uci_dhcp, "@dnsmasq[0]", "tftp_no_fail", false))
+		fputs("tftp-no-fail\n", pihole_conf);
+
+	if(uci_read_bool(uci_dhcp, "@dnsmasq[0]", "noresolv", false))
+		fputs("no-resolv\n", pihole_conf);
+
+	if(uci_read_bool(uci_dhcp, "@dnsmasq[0]", "no_id", false))
+		fputs("no-ident\n", pihole_conf);
+
+	if(uci_read_bool(uci_dhcp, "@dnsmasq[0]", "filterwin2k", false))
+		fputs("filterwin2k\n", pihole_conf);
+
+	if(uci_read_bool(uci_dhcp, "@dnsmasq[0]", "nohosts", false))
+		fputs("no-hosts\n", pihole_conf);
+
+	if(uci_read_bool(uci_dhcp, "@dnsmasq[0]", "strictorder", false))
+		fputs("strict-order\n", pihole_conf);
+
+	if(uci_read_bool(uci_dhcp, "@dnsmasq[0]", "readethers", false))
+		fputs("read-ethers\n", pihole_conf);
+
+	if(uci_read_bool(uci_dhcp, "@dnsmasq[0]", "dbus", false))
+		fputs("enable-dbus\n", pihole_conf);
+
+	if(uci_read_bool(uci_dhcp, "@dnsmasq[0]", "tftp_no_fail", false))
+		fputs("tftp-no-fail\n", pihole_conf);
+
+	if(uci_read_bool(uci_dhcp, "@dnsmasq[0]", "allservers", false))
+		fputs("all-servers\n", pihole_conf);
+
+	if(uci_read_bool(uci_dhcp, "@dnsmasq[0]", "noping", false))
+		fputs("no-ping\n", pihole_conf);
+
+	if(uci_read_bool(uci_dhcp, "@dnsmasq[0]", "filter_a", false))
+		fputs("filter-A\n", pihole_conf);
+
+	if(uci_read_bool(uci_dhcp, "@dnsmasq[0]", "filter_aaaa", false))
+		fputs("filter-AAAA\n", pihole_conf);
+
+	if(uci_read_bool(uci_dhcp, "@dnsmasq[0]", "scriptarp", false))
+		fputs("script-arp\n", pihole_conf);
+
+	if(!uci_read_bool(uci_dhcp, "@dnsmasq[0]", "scriptarp", false))
+		fputs("dnssec-check-unsigned=no\n", pihole_conf);
+
+	// since FTL doesn't support multiple instances
+	// find the first dnsmasq section in dhcp config
+	struct uci_section *s = get_uci_section_type(uci_dhcp, "dnsmasq");
+	struct uci_element *elem;
+	uci_foreach_element(&s->options, elem)
+	{
+		struct uci_option* opt = uci_to_option(elem);
+		if(opt->type == UCI_TYPE_STRING && opt->v.string)
+		{
+			if(strcmp(opt->e.name, "tftp_root") == 0)
+			{
+				fprintf(pihole_conf, "tftp-root=%s\n", opt->v.string);
+				if(uci_read_bool(uci_dhcp, "@dnsmasq[0]", "enable_tftp", false))
+					fputs("enable-tftp\n", pihole_conf);
+			}
+			else if(strcmp(opt->e.name, "tftp_unique_root") == 0) 
+				fprintf(pihole_conf, "ftp-unique-root=%s\n", opt->v.string);
+			else if(strcmp(opt->e.name, "ednspacket_max") == 0) 
+				fprintf(pihole_conf, "edns-packet-max=%s\n", opt->v.string);
+			else if(strcmp(opt->e.name, "dnsforwardmax") == 0)
+				fprintf(pihole_conf, "dns-forward-max=%s\n", opt->v.string);
+			else if(strcmp(opt->e.name, "queryport") == 0)
+				fprintf(pihole_conf, "query-port=%s\n", opt->v.string);
+			else if(strcmp(opt->e.name, "minport") == 0)
+				fprintf(pihole_conf, "min-port=%s\n", opt->v.string);
+			else if(strcmp(opt->e.name, "maxport") == 0)
+				fprintf(pihole_conf, "max-port=%s\n", opt->v.string);
+			else if(strcmp(opt->e.name, "local_ttl") == 0)
+				fprintf(pihole_conf, "local-ttl=%s\n", opt->v.string);
+			else if(strcmp(opt->e.name, "max_ttl") == 0)
+				fprintf(pihole_conf, "max-ttl=%s\n", opt->v.string);
+			else if(strcmp(opt->e.name, "min_cache_ttl") == 0)
+				fprintf(pihole_conf, "min-cache-ttl=%s\n", opt->v.string);
+			else if(strcmp(opt->e.name, "max_cache_ttl") == 0)
+				fprintf(pihole_conf, "max-cache-ttl=%s\n", opt->v.string);
+			else if(strcmp(opt->e.name, "serversfile") == 0)
+				fprintf(pihole_conf, "servers-file=%s\n", opt->v.string);
+		}
+		else if(opt->type == UCI_TYPE_LIST)
+		{
+			struct uci_element *el;
+			uci_foreach_element(&opt->v.list, el)
+			{
+				if (!el->name)
+					continue;
+
+				if(rebind_protection && strcmp(opt->e.name, "rebind_domain") == 0)
+					fprintf(pihole_conf, "rebind-domain-ok=%s\n", el->name);
+				else if(strcmp(opt->e.name, "notinterface") == 0)
+					fprintf(pihole_conf, "except-interface=%s\n", el->name);
+				else if(strcmp(opt->e.name, "addnhosts") == 0)
+					fprintf(pihole_conf, "addn-hosts=%s\n", el->name);
+				else if(strcmp(opt->e.name, "bogusnxdomain") == 0)
+					fprintf(pihole_conf, "bogus-nxdomain=%s\n", el->name);
+#if 0
+				else if(strcmp(opt->e.name, "interface") == 0)
+				{
+					if(conf->dns.listeningMode.v.listeningMode == LISTEN_BIND)
+						fprintf(pihole_conf, "interface=%s\n", el->name);
+					else if(conf->dns.listeningMode.v.listeningMode == LISTEN_SINGLE)
+					{
+						fputs("# Listen on one interface\n", pihole_conf);
+						fprintf(pihole_conf, "interface=%s\n", el->name);
+						continue;
+					}
+				}
+#endif
+			}
+		}
+	}
+
+	const char *filter_rr = uci_get_string(uci_dhcp, "@dnsmasq[0]", "filter_rr");
+	if(filter_rr != NULL)
+		fprintf(pihole_conf, "filter-rr=%s\n", filter_rr);
+
+	fputs("\n", pihole_conf);
+
 	if(conf->dhcp.active.v.b)
 	{
 		fputs("# DHCP server setting\n", pihole_conf);
 		fputs("dhcp-authoritative\n", pihole_conf);
-		fputs("dhcp-leasefile="DHCPLEASESFILE"\n", pihole_conf);
-		char start[INET_ADDRSTRLEN] = { 0 },
-		     end[INET_ADDRSTRLEN] = { 0 },
-		     router[INET_ADDRSTRLEN] = { 0 };
-		inet_ntop(AF_INET, &conf->dhcp.start.v.in_addr, start, INET_ADDRSTRLEN);
-		inet_ntop(AF_INET, &conf->dhcp.end.v.in_addr, end, INET_ADDRSTRLEN);
-		inet_ntop(AF_INET, &conf->dhcp.router.v.in_addr, router, INET_ADDRSTRLEN);
-		fprintf(pihole_conf, "dhcp-range=%s,%s", start, end);
-		// Net mask is optional, only add if it is not 0.0.0.0
-		const struct in_addr inaddr_empty = {0};
-		if(memcmp(&conf->dhcp.netmask.v.in_addr, &inaddr_empty, sizeof(inaddr_empty)) != 0)
-		{
-			char netmask[INET_ADDRSTRLEN] = { 0 };
-			inet_ntop(AF_INET, &conf->dhcp.netmask.v.in_addr, netmask, INET_ADDRSTRLEN);
-			fprintf(pihole_conf, ",%s", netmask);
-		}
-		// Lease time is optional, only add it if it is set
-		if(strlen(conf->dhcp.leaseTime.v.s) > 0)
-			fprintf(pihole_conf, ",%s", conf->dhcp.leaseTime.v.s);
-		fprintf(pihole_conf, "\ndhcp-option=option:router,%s\n", router);
+		fputs("dhcp-broadcast=tag:needs-broadcast\n", pihole_conf);
+		fprintf(pihole_conf, "dhcp-leasefile=%s\n", config.dhcp.leaseFile.v.s);
+		fputs("dhcp-ignore-names=tag:dhcp_bogus_hostname\n", pihole_conf);
+		fputs("dhcp-name-match=set:dhcp_bogus_hostname,localhost\n", pihole_conf);
+		fputs("dhcp-name-match=set:dhcp_bogus_hostname,wpad\n", pihole_conf);
+
+		write_config_dhcp(pihole_conf);
 
 		if(conf->dhcp.rapidCommit.v.b)
 			fputs("dhcp-rapid-commit\n", pihole_conf);
@@ -541,16 +797,6 @@ bool __attribute__((const)) write_dnsmas
 			fputs("dhcp-option=option:dns-server,0.0.0.0,0.0.0.0,0.0.0.0\n", pihole_conf);
 		}
 
-		if(conf->dhcp.ipv6.v.b)
-		{
-			// Add dns-server option only if not already done above (dhcp.multiDNS)
-			if(conf->dhcp.multiDNS.v.b)
-				fputs("dhcp-option=option6:dns-server,[::],[::],[fd00::],[fd00::],[fe80::],[fe80::]\n", pihole_conf);
-			else
-				fputs("dhcp-option=option6:dns-server,[::]\n", pihole_conf);
-			fputs("# Enable IPv6 DHCP variant\n", pihole_conf);
-			fprintf(pihole_conf, "dhcp-range=::,constructor:%s,ra-names,ra-stateless,64\n", interface);
-		}
 		fputs("\n", pihole_conf);
 		if(cJSON_GetArraySize(conf->dhcp.hosts.v.json) > 0)
 		{
@@ -606,7 +852,7 @@ bool __attribute__((const)) write_dnsmas
 	fputs("server=/onion/\n", pihole_conf);
 	fputs("\n", pihole_conf);
 
-	if(directory_exists("/tmp/dnsmasq.d") && conf->misc.etc_dnsmasq_d.v.b)
+	if(directory_exists("/tmp/dnsmasq.d"))
 	{
 		// Load additional user scripts from /tmp/dnsmasq.d if the
 		// directory exists (it may not, e.g., in a container)
@@ -616,9 +862,11 @@ bool __attribute__((const)) write_dnsmas
 	}
 
 	// Add option for caching all DNS records
+	if(conf->dns.cache.size.v.ui > 0) {
 	fputs("# Cache all DNS records\n", pihole_conf);
 	fputs("cache-rr=ANY\n", pihole_conf);
 	fputs("\n", pihole_conf);
+	}
 
 	// Add option for PCAP file recording
 	if(strlen(conf->files.pcap.v.s) > 0)
@@ -702,6 +950,85 @@ bool __attribute__((const)) write_dnsmas
 	return true;
 }
 
+bool write_hosts_file(void)
+{
+	const char *host_file = "/tmp/hosts/host_static";
+	FILE *hostfile = fopen(host_file, "w");
+	if(!hostfile)
+	{
+		log_err("Cannot open %s for writing, unable to update host_static: %s", host_file, strerror(errno));
+		return false;
+	}
+
+	if(flock(fileno(hostfile), LOCK_EX) != 0)
+	{
+		log_err("Cannot open %s in exclusive mode: %s", host_file, strerror(errno));
+		fclose(hostfile);
+		return false;
+	}
+
+	write_config_header(hostfile, "Static DHCP (HOSTS file)");
+	fputc('\n', hostfile);
+
+	int i = 0;
+	struct uci_element *e;
+	uci_foreach_element(&uci_dhcp->sections, e)
+	{
+		struct uci_section *s = uci_to_section(e);
+		if (strcmp(s->type, "host") != 0)
+			continue;
+
+		const char *ip = uci_lookup_option_string(uci_ctx, s, "ip");
+		const char *name = uci_lookup_option_string(uci_ctx, s, "name");
+		if(name != NULL && ip != NULL)
+		{
+			fprintf(hostfile, "%s %s\n", ip, name);
+			i++;
+		}
+	}
+
+	e = NULL;
+	uci_foreach_element(&uci_network->sections, e)
+	{
+		struct uci_section *s = uci_to_section(e);
+		if (strcmp(s->type, "interface") != 0)
+			continue;
+
+		const char *proto = uci_lookup_option_string(uci_ctx, s, "proto");
+		if(!proto || strcmp(proto, "static") != 0)
+			continue;
+
+		const char *ipaddr = uci_lookup_option_string(uci_ctx, s, "ipaddr");
+		const char *domain_iface = uci_get_string(uci_dhcp, e->name, "domain_iface");
+
+		if(ipaddr != NULL && strcmp(ipaddr, "127.0.0.1") != 0)
+		{
+			if(domain_iface != NULL)
+				fprintf(hostfile, "%s %s.%s\n", ipaddr, hostname(), domain_iface);
+			else
+				fprintf(hostfile, "%s %s\n", hostname(), ipaddr);
+
+			i++;
+		}
+	}
+
+	fprintf(hostfile, "\n# %d entrie(s) in this file\n", i);
+
+	if(flock(fileno(hostfile), LOCK_UN) != 0)
+	{
+		log_err("Cannot release lock on host_static: %s", strerror(errno));
+		fclose(hostfile);
+		return false;
+	}
+
+	if(fclose(hostfile) != 0)
+	{
+		log_err("Cannot close host_static: %s", strerror(errno));
+		return false;
+	}
+	return true;
+}
+
 bool read_legacy_dhcp_static_config(void)
 {
 	// Check if file exists, if not, there is nothing to do
@@ -904,19 +1231,19 @@ bool write_custom_list(void)
 		}
 	}
 
-	log_debug(DEBUG_CONFIG, "Opening "DNSMASQ_CUSTOM_LIST_LEGACY".tmp for writing");
-	FILE *custom_list = fopen(DNSMASQ_CUSTOM_LIST_LEGACY".tmp", "w");
+	log_debug(DEBUG_CONFIG, "Opening "DNSMASQ_CUSTOM_LIST" for writing");
+	FILE *custom_list = fopen(DNSMASQ_CUSTOM_LIST"", "w");
 	// Return early if opening failed
 	if(!custom_list)
 	{
-		log_err("Cannot open "DNSMASQ_CUSTOM_LIST_LEGACY".tmp for writing, unable to update custom.list: %s", strerror(errno));
+		log_err("Cannot open "DNSMASQ_CUSTOM_LIST" for writing, unable to update custom.list: %s", strerror(errno));
 		return false;
 	}
 
 	// Lock file, may block if the file is currently opened
 	if(flock(fileno(custom_list), LOCK_EX) != 0)
 	{
-		log_err("Cannot open "DNSMASQ_CUSTOM_LIST_LEGACY".tmp in exclusive mode: %s", strerror(errno));
+		log_err("Cannot open "DNSMASQ_CUSTOM_LIST" in exclusive mode: %s", strerror(errno));
 		fclose(custom_list);
 		return false;
 	}
--- a/src/config/dnsmasq_config.h
+++ b/src/config/dnsmasq_config.h
@@ -21,14 +21,13 @@ bool read_legacy_dhcp_static_config(void
 bool read_legacy_cnames_config(void);
 bool read_legacy_custom_hosts_config(void);
 bool write_custom_list(void);
+bool write_hosts_file(void);
 
-#define DNSMASQ_PH_CONFIG "/etc/pihole/dnsmasq.conf"
-#define DNSMASQ_TEMP_CONF "/etc/pihole/dnsmasq.conf.temp"
+#define DNSMASQ_PH_CONFIG "/tmp/etc/dnsmasq.conf"
+#define DNSMASQ_TEMP_CONF "/tmp/etc/dnsmasq.conf.temp"
 #define DNSMASQ_STATIC_LEASES "/etc/pihole/04-pihole-static-dhcp.conf"
 #define DNSMASQ_CNAMES "/etc/pihole/05-pihole-custom-cname.conf"
-#define DNSMASQ_HOSTSDIR "/etc/pihole/hosts"
-#define DNSMASQ_CUSTOM_LIST DNSMASQ_HOSTSDIR"/custom.list"
-#define DNSMASQ_CUSTOM_LIST_LEGACY "/etc/pihole/custom.list"
-#define DHCPLEASESFILE "/etc/pihole/dhcp.leases"
+#define DNSMASQ_HOSTSDIR "/tmp/hosts"
+#define DNSMASQ_CUSTOM_LIST DNSMASQ_HOSTSDIR"/host_custom"
 
 #endif //DNSMASQ_CONFIG_H
--- a/src/config/inotify.c
+++ b/src/config/inotify.c
@@ -14,7 +14,7 @@
 // NAME_MAX
 #include <limits.h>
 
-#define WATCHDIR "/etc/pihole"
+#define WATCHDIR "/etc/config"
 
 static int inotify_fd = -1;
 static int inotify_wd = -1;
@@ -108,7 +108,7 @@ bool check_inotify_event(void)
 		{
 			// File opened for writing was closed
 			log_debug(DEBUG_INOTIFY, "File written: "WATCHDIR"/%s", event->name);
-			if(strcmp(event->name, "pihole.toml") == 0)
+			if(strcmp(event->name, "pihole") == 0 || strcmp(event->name, "dhcp") == 0)
 				config_changed = true;
 		}
 		else if(event->mask & IN_CREATE)
@@ -125,7 +125,7 @@ bool check_inotify_event(void)
 		{
 			// File was moved (target)
 			log_debug(DEBUG_INOTIFY, "File moved to: "WATCHDIR"/%s", event->name);
-			if(strcmp(event->name, "pihole.toml") == 0)
+			if(strcmp(event->name, "pihole") == 0)
 				config_changed = true;
 		}
 		else if(event->mask & IN_DELETE)
--- a/src/config/toml_reader.c
+++ b/src/config/toml_reader.c
@@ -26,7 +26,6 @@
 
 // Private prototypes
 static toml_table_t *parseTOML(const unsigned int version);
-static void reportDebugFlags(void);
 
 bool readFTLtoml(struct config *oldconf, struct config *newconf,
                  toml_table_t *toml, const bool verbose, bool *restart,
@@ -197,7 +196,7 @@ bool getLogFilePathTOML(void)
 	return true;
 }
 
-static void reportDebugFlags(void)
+void reportDebugFlags(void)
 {
 	// Print debug settings
 	log_debug(DEBUG_ANY, "************************");
--- a/src/config/toml_reader.h
+++ b/src/config/toml_reader.h
@@ -17,5 +17,6 @@ bool readFTLtoml(struct config *oldconf,
                  toml_table_t *toml, const bool verbose, bool *restart,
                  const unsigned int version);
 bool getLogFilePathTOML(void);
+void reportDebugFlags(void);
 
 #endif //TOML_READER_H
--- a/src/daemon.c
+++ b/src/daemon.c
@@ -354,6 +354,9 @@ void cleanup(const int ret)
 	char buffer[42] = { 0 };
 	format_time(buffer, 0, timer_elapsed_msec(EXIT_TIMER));
 	log_info("########## FTL terminated after%s (code %i)! ##########", buffer, ret);
+
+	uci_clean();
+	clean_all();
 }
 
 static float last_clock = 0.0f;
@@ -404,54 +407,6 @@ ssize_t getrandom_fallback(void *buf, si
 	return buflen;
 }
 
-bool ipv6_enabled(void)
-{
-	// First we check a few virtual system files to see if IPv6 is disabled
-	const char *files[] = {
-		"/sys/module/ipv6/parameters/disable", // GRUB - ipv6.disable=1
-		"/proc/sys/net/ipv6/conf/all/disable_ipv6", // sysctl.conf - net.ipv6.conf.all.disable_ipv6=1
-		"/proc/sys/net/ipv6/conf/default/disable_ipv6", // sysctl.conf - net.ipv6.conf.all.disable_ipv6=1
-		NULL
-	};
-
-	// Loop over the files
-	for(int i = 0; files[i] != NULL; i++)
-	{
-		// Open file for reading
-		FILE *f = fopen(files[i], "r");
-		if(f == NULL)
-			continue;
-
-		// Read first character
-		const int c = fgetc(f);
-		fclose(f);
-		// If the first character is a 1, then IPv6 is disabled
-		if(c == '1')
-			return false;
-	}
-
-	// If the file does not exist or if it does not contain a 1, then we check
-	// if /proc/net/if_inet6 has any IPv6-capable interfaces
-	// Since Linux 2.6.25 (April 2008), files in /proc/net are a symlink to
-	// /proc/self/net and provide information about the network devices and
-	// interfaces for the network namespace of which the process is a member
-	FILE *f = fopen("/proc/net/if_inet6", "r");
-
-	if(f != NULL)
-	{
-		// If the file exists, we check if it is empty
-		const int c = fgetc(f);
-		fclose(f);
-		// If the file is empty, then there are no IPv6-capable interfaces
-		if(c == EOF)
-			return false;
-	}
-
-	// else: IPv6 is not obviously disabled and there is at least one
-	// IPv6-capable interface
-	return true;
-}
-
 void init_locale(void)
 {
 	// Set locale to system default, needed for libidn to work properly
@@ -463,4 +418,4 @@ void init_locale(void)
 	// the dot as decimal separator (even if the system locale uses a
 	// comma, e.g., in German)
 	setlocale(LC_NUMERIC, "C");
-}
\ No newline at end of file
+}
--- a/src/daemon.h
+++ b/src/daemon.h
@@ -23,7 +23,6 @@ void cleanup(const int ret);
 void set_nice(void);
 void calc_cpu_usage(const unsigned int interval);
 float get_cpu_percentage(void) __attribute__((pure));
-bool ipv6_enabled(void);
 void init_locale(void);
 
 #include <sys/syscall.h>
--- a/src/dnsmasq_interface.c
+++ b/src/dnsmasq_interface.c
@@ -467,6 +467,34 @@ size_t _FTL_make_answer(struct dns_heade
 	return p - (unsigned char *)header;
 }
 
+static bool is_hostname_domain(const char *domain)
+{
+	const size_t len = strlen(hostname());
+	if(strncasecmp(domain, hostname(), len) != 0)
+		return false;
+
+	struct uci_element *e;
+	uci_foreach_element(&uci_dhcp->sections, e)
+	{
+		struct uci_section *s = uci_to_section(e);
+		if (strcmp(s->type, "dhcp") != 0)
+			continue;
+
+		const char *dmnsfx = uci_lookup_option_string(uci_ctx, s, "domain_iface");
+		if(dmnsfx != NULL)
+		{
+			char *suffix = calloc(len + strlen(dmnsfx) + 2, sizeof(char));
+			strcpy(suffix, hostname());
+			strcat(suffix, ".");
+			strcat(suffix, dmnsfx);
+			if(strcasecmp(domain, suffix) == 0)
+				return true;
+		}
+	}
+
+	return false;
+}
+
 static bool is_pihole_domain(const char *domain)
 {
 	if(!pihole_suffix && daemon->domain_suffix)
@@ -562,6 +590,9 @@ bool _FTL_new_query(const unsigned int f
 	// Check domain name received from dnsmasq
 	name = check_dnsmasq_name(name);
 
+	if(is_hostname_domain(name))
+		return false;
+
 	// If domain is "pi.hole" or the local hostname we skip analyzing this query
 	// and, instead, immediately reply with the IP address - these queries are not further analyzed
 	if(is_pihole_domain(name))
@@ -636,6 +667,18 @@ bool _FTL_new_query(const unsigned int f
 		strcpy(clientIP, "::");
 	}
 
+	// Skip filter-rr queries
+	if(!config.dns.analyzeOnlyAandAAAA.v.b && rr_on_list(daemon->filter_rr, qtype))
+	{
+		if(config.debug.queries.v.b)
+		{
+			const char *types = querystr(arg, qtype);
+			log_debug(DEBUG_QUERIES, "Not analyzing filter-rr: %s (%i)", types, id);
+		}
+		free(domainString);
+		return false;
+	}
+
 	// Check if user wants to skip queries coming from localhost
 	if(config.dns.ignoreLocalhost.v.b &&
 	   (strcmp(clientIP, "127.0.0.1") == 0 || strcmp(clientIP, "::1") == 0))
@@ -1123,6 +1166,20 @@ static bool check_domain_blocked(const c
 	if(query->flags.allowed)
 		return false;
 
+	// check domain in uci config
+	if(is_in_uci_list(uci_pihole, "@blacklist[0]", "domain", domain))
+	{
+		// Set new status
+		*new_status = QUERY_DENYLIST;
+		blockingreason = "exactly blacklisted";
+
+		// Mark domain as exactly blacklisted for this client
+		set_dnscache_blockingstatus(dns_cache, client, DENYLIST_BLOCKED, domain);
+
+		// We block this domain
+		return true;
+	}
+
 	// Check domains against exact blacklist
 	const enum db_result blacklist = in_denylist(domain, dns_cache, client);
 	if(blacklist == FOUND)
@@ -1414,6 +1471,16 @@ static bool _FTL_check_blocking(int quer
 	// Check exact whitelist for match
 	query->flags.allowed = in_allowlist(domainstr, dns_cache, client) == FOUND;
 
+	if(!query->flags.allowed)
+	{
+		if(is_in_uci_list(uci_pihole, "@whitelist[0]", "domain", domainstr) ||
+		   is_in_uci_list(uci_pihole, "@whitelist[0]", "client", getstr(client->ippos)) ||
+		   is_in_uci_list(uci_pihole, "@whitelist[0]", "client", getstr(client->namepos)))
+		{
+			query->flags.allowed = true;
+		}
+	}
+
 	// If not found: Check regex whitelist for match
 	if(!query->flags.allowed)
 		query->flags.allowed = in_regex(domainstr, dns_cache, client->id, REGEX_ALLOW);
@@ -1439,6 +1506,18 @@ static bool _FTL_check_blocking(int quer
 	bool db_okay = true;
 	bool blockDomain = check_domain_blocked(domainstr, clientID, client, query, dns_cache, &new_status, &db_okay);
 
+	if(blockDomain && query->type == TYPE_A &&
+	   !is_in_uci_list(uci_pihole, "@block_with_ip[0]", "ignore_domain", domainstr))
+	{
+		if(is_in_uci_list(uci_pihole, "@block_with_ip[0]", "client", getstr(client->ippos)) ||
+		   is_in_uci_list(uci_pihole, "@block_with_ip[0]", "client", getstr(client->namepos)))
+		{
+			force_next_DNS_reply = REPLY_IP;
+			if(db_okay)
+				dns_cache->force_reply = REPLY_IP;
+		}
+	}
+
 	// Check blacklist (exact + regex) and gravity for _esni.domain if enabled
 	// (defaulting to true)
 	if(config.dns.blockESNI.v.b &&
--- a/src/log.c
+++ b/src/log.c
@@ -47,6 +47,9 @@ void log_ctrl(bool plog, bool pstdout)
 
 void init_FTL_log(const char *name)
 {
+	// reread logfile location
+	uci_get_value(&config.files.log.ftl, "pihole", "logfile");
+
 	// Open the log file in append/create mode
 	if(config.files.log.ftl.v.s != NULL)
 	{
--- a/src/main.c
+++ b/src/main.c
@@ -62,6 +62,14 @@ int main (int argc, char *argv[])
 	// to have arg{c,v}_dnsmasq initialized
 	parse_args(argc, argv);
 
+	// Check if there is already a running FTL process
+	if(check_running_FTL())
+		return EXIT_FAILURE;
+
+	// Initialize uci
+	if(!uci_init())
+		return EXIT_FAILURE;
+
 	// Initialize FTL log
 	init_FTL_log(argc > 0 ? argv[0] : NULL);
 	// Try to open FTL log
@@ -87,8 +95,7 @@ int main (int argc, char *argv[])
 	if(!init_shmem())
 	{
 		log_crit("Initialization of shared memory failed.");
-		// Check if there is already a running FTL process
-		check_running_FTL();
+		uci_clean();
 		return EXIT_FAILURE;
 	}
 
@@ -117,6 +124,7 @@ int main (int argc, char *argv[])
 	if(!init_memory_database())
 	{
 		log_crit("FATAL: Cannot initialize in-memory database.");
+		uci_clean();
 		return EXIT_FAILURE;
 	}
 
--- a/src/procps.c
+++ b/src/procps.c
@@ -214,7 +214,7 @@ bool check_running_FTL(void)
 		log_debug(DEBUG_SHMEM, "PID: %d -> name: %s%s", pid, name, pid == ourselves ? " (us)" : "");
 
 		// Skip our own process
-		if(pid == ourselves)
+		if(pid == ourselves || pid - ourselves == 1)
 			continue;
 
 		// Only process this is this is our own process
--- a/src/zip/teleporter.c
+++ b/src/zip/teleporter.c
@@ -351,7 +351,7 @@ static const char *import_dhcp_leases(vo
 	rotate_files(DHCPLEASESFILE, NULL);
 
 	// Write new dhcp.leases file to disk
-	FILE *fp = fopen(DHCPLEASESFILE, "w");
+	FILE *fp = fopen(config.dhcp.leaseFile.v.s, "w");
 	if(fp == NULL)
 	{
 		strncpy(hint, strerror(errno), ERRBUF_SIZE);
