--- a/src/CMakeLists.txt	2024-03-13 17:40:43.000000000 +0700
+++ b/src/CMakeLists.txt	2024-03-13 17:40:48.000000000 +0700
@@ -330,6 +330,12 @@ if(CONNTRACK_SUPPORT)
     target_link_libraries(pihole-FTL ${LIBNETFILTER_CONNTRACK} ${LIBNFNETLINK})
 endif()
 
+find_library(LIBUCI uci)
+if(NOT LIBUCI)
+    message(FATAL_ERROR "libuci not found")
+endif()
+target_link_libraries(pihole-FTL ${LIBUCI})
+
 if(NFT_SUPPORT)
     find_library(LIBNFTABLES nftables)
     target_link_libraries(pihole-FTL ${LIBNFTABLES})
--- a/src/api/config.c	2024-03-13 17:40:42.000000000 +0700
+++ b/src/api/config.c	2024-03-13 17:42:36.000000000 +0700
@@ -14,6 +14,7 @@
 #include "api/api.h"
 // config struct
 #include "config/config.h"
+#include "config/config_uci.h"
 // struct clientsData
 #include "datastructure.h"
 // INT_MIN, INT_MAX, ...
@@ -764,6 +765,10 @@ static int api_config_patch(struct ftl_c
 		// Memorize that at least one config item actually changed
 		config_changed = true;
 
+		// Set to uci config
+		if(uci_set_value(uci_ctx, new_item, NULL))
+			log_err("Failed to save new config for: %s", new_item->k);
+
 		// If we reach this point, a valid setting was found and changed
 
 		// Validate new value (if validation function is defined)
@@ -803,7 +808,7 @@ static int api_config_patch(struct ftl_c
 		if(dnsmasq_changed)
 		{
 			char errbuf[ERRBUF_SIZE] = { 0 };
-			if(write_dnsmasq_config(&newconf, true, errbuf))
+			if(write_dnsmasq_config(uci_ctx, &newconf, true, errbuf))
 				api->ftl.restart = true;
 			else
 			{
@@ -941,6 +946,7 @@ static int api_config_put_delete(struct
 			{
 				// Add new item to array
 				JSON_COPY_STR_TO_ARRAY(new_item->v.json, new_item_str);
+				uci_add_sec_foreach(uci_dhcp, new_item->k, new_item_str);
 				found = true;
 			}
 		}
@@ -951,6 +957,7 @@ static int api_config_put_delete(struct
 				// Remove item from array
 				found = true;
 				cJSON_DeleteItemFromArray(new_item->v.json, idx);
+				uci_del_sec_foreach(uci_dhcp, new_item_str);
 			}
 			else
 			{
@@ -1011,7 +1018,7 @@ static int api_config_put_delete(struct
 	{
 		char errbuf[ERRBUF_SIZE] = { 0 };
 		// Request restart of FTL
-		if(write_dnsmasq_config(&newconf, true, errbuf))
+		if(write_dnsmasq_config(uci_ctx, &newconf, true, errbuf))
 			api->ftl.restart = true;
 		else
 		{
--- a/src/api/dhcp.c	2024-03-13 17:40:42.000000000 +0700
+++ b/src/api/dhcp.c	2024-03-13 17:40:48.000000000 +0700
@@ -12,6 +12,7 @@
 #include "webserver/http-common.h"
 #include "webserver/json_macros.h"
 #include "api.h"
+#include "config/config.h"
 #include "config/dnsmasq_config.h"
 // rotate_files()
 #include "files.h"
@@ -23,7 +24,7 @@ int api_dhcp_leases_GET(struct ftl_conn
 	cJSON *json = JSON_NEW_OBJECT();
 	JSON_ADD_ITEM_TO_OBJECT(json, "leases", leases);
 
-	FILE *fp = fopen(DHCPLEASESFILE, "r");
+	FILE *fp = fopen(config.dhcp.leaseFile.v.s, "r");
 	if(fp == NULL)
 	{
 		// File does not exist or not readable, send empty array
--- a/src/api/stats.c	2024-03-13 17:40:42.000000000 +0700
+++ b/src/api/stats.c	2024-03-13 17:42:31.000000000 +0700
@@ -14,12 +14,11 @@
 #include "api/api.h"
 #include "shmem.h"
 #include "datastructure.h"
-// read_setupVarsconf()
-#include "config/setupVars.h"
 // logging routines
 #include "log.h"
 // config struct
 #include "config/config.h"
+#include "config/config_uci.h"
 // overTime data
 #include "overTime.h"
 // enum REGEX
@@ -199,7 +198,7 @@ int api_stats_top_domains(struct ftl_con
 	qsort(temparray, added_domains, sizeof(int[2]), cmpdesc);
 
 	// Get filter
-	const char* log_show = read_setupVarsconf("API_QUERY_LOG_SHOW");
+	const char* log_show = uci_get_string(uci_ctx, uci_pihole, "@pihole[0]", "api_query_log_show");
 	bool showpermitted = true, showblocked = true;
 	if(log_show != NULL)
 	{
@@ -213,7 +212,6 @@ int api_stats_top_domains(struct ftl_con
 			showblocked = false;
 		}
 	}
-	clearSetupVarsArray();
 
 	// Get domains which the user doesn't want to see
 	regex_t *regex_domains = NULL;
--- a/src/args.c	2024-03-13 17:40:43.000000000 +0700
+++ b/src/args.c	2024-03-13 17:42:04.000000000 +0700
@@ -50,6 +50,7 @@
 #endif
 #include "config/cli.h"
 #include "config/config.h"
+#include "config/config_uci.h"
 // compression functions
 #include "zip/gzip.h"
 // teleporter functions
@@ -282,26 +283,31 @@ void parse_args(int argc, char* argv[])
 	// Set config option through CLI
 	if(argc > 1 && strcmp(argv[1], "--config") == 0)
 	{
+		struct uci_context *ctx;
+		int ret = EXIT_FAILURE;
 		// Enable stdout printing
 		cli_mode = true;
+		ctx = uci_alloc_context();
+		uci_load_package(ctx, false);
 		log_ctrl(false, false);
-		readFTLconf(&config, false);
+		readFTLconf(&config, false, ctx);
 		log_ctrl(false, true);
 		clear_debug_flags(); // No debug printing wanted
 		if(argc == 2)
-			exit(get_config_from_CLI(NULL, false));
+			ret = get_config_from_CLI(NULL, false);
 		else if(argc == 3)
-			exit(get_config_from_CLI(argv[2], false));
+			ret = get_config_from_CLI(argv[2], false);
 		else if(argc == 4 && strcmp(argv[2], "-q") == 0)
-			exit(get_config_from_CLI(argv[3], true));
+			ret = get_config_from_CLI(argv[3], true);
 		else if(argc == 4)
-			exit(set_config_from_CLI(argv[2], argv[3]));
+			ret = set_config_from_CLI(ctx, argv[2], argv[3]);
 		else
 		{
 			printf("Usage: %s --config [<config item key>] [<value>]\n", argv[0]);
 			printf("Example: %s --config dns.blockESNI true\n", argv[0]);
-			exit(EXIT_FAILURE);
 		}
+		uci_clean(ctx);
+		exit(ret);
 	}
 
 
@@ -310,7 +316,7 @@ void parse_args(int argc, char* argv[])
 	{
 		cli_mode = true;
 		log_ctrl(false, false);
-		readFTLconf(&config, false);
+		readFTLconf(&config, false, uci_ctx);
 		log_ctrl(false, true);
 		clear_debug_flags(); // No debug printing wanted
 		exit(printTOTP());
@@ -323,7 +329,7 @@ void parse_args(int argc, char* argv[])
 		// Enable stdout printing
 		cli_mode = true;
 		log_ctrl(false, true);
-		readFTLconf(&config, false);
+		readFTLconf(&config, false, uci_ctx);
 		exit(write_teleporter_zip_to_disk() ? EXIT_SUCCESS : EXIT_FAILURE);
 	}
 
@@ -333,7 +339,7 @@ void parse_args(int argc, char* argv[])
 		// Enable stdout printing
 		cli_mode = true;
 		log_ctrl(false, true);
-		readFTLconf(&config, false);
+		readFTLconf(&config, false, uci_ctx);
 		exit(read_teleporter_zip_from_disk(argv[2]) ? EXIT_SUCCESS : EXIT_FAILURE);
 	}
 
@@ -377,7 +383,7 @@ void parse_args(int argc, char* argv[])
 		const char *certfile = NULL;
 		if(argc == 2)
 		{
-			readFTLconf(&config, false);
+			readFTLconf(&config, false, uci_ctx);
 			certfile = config.webserver.tls.cert.v.s;
 		}
 		else
@@ -529,7 +535,7 @@ void parse_args(int argc, char* argv[])
 		cli_mode = true;
 
 		// Need to get dns.port and the resolver settings
-		readFTLconf(&config, false);
+		readFTLconf(&config, false, uci_ctx);
 
 		char *name = resolveHostname(argv[2], true);
 		if(name == NULL)
--- a/src/config/CMakeLists.txt	2024-03-13 17:40:43.000000000 +0700
+++ b/src/config/CMakeLists.txt	2024-03-13 17:41:16.000000000 +0700
@@ -13,6 +13,8 @@ set(sources
         cli.h
         config.c
         config.h
+        config_uci.c
+        config_uci.h
         dnsmasq_config.c
         dnsmasq_config.h
         env.c
--- a/src/config/cli.c	2024-03-13 17:40:43.000000000 +0700
+++ b/src/config/cli.c	2024-03-13 17:42:20.000000000 +0700
@@ -11,6 +11,7 @@
 #include "FTL.h"
 #include "config/cli.h"
 #include "config/config.h"
+#include "config/config_uci.h"
 #include "config/toml_helper.h"
 #include "config/toml_writer.h"
 #include "config/dnsmasq_config.h"
@@ -35,7 +36,7 @@ enum exit_codes {
 } __attribute__((packed));
 
 // Read a TOML value from a table depending on its type
-static bool readStringValue(struct conf_item *conf_item, const char *value, struct config *newconf)
+bool readStringValue(struct conf_item *conf_item, const char *value, struct config *newconf)
 {
 	if(conf_item == NULL || value == NULL)
 	{
@@ -47,9 +48,9 @@ static bool readStringValue(struct conf_
 	{
 		case CONF_BOOL:
 		{
-			if(strcasecmp(value, "true") == 0 || strcasecmp(value, "yes") == 0)
+			if(strcasecmp(value, "true") == 0 || strcmp(value, "1") == 0)
 				conf_item->v.b = true;
-			else if(strcasecmp(value, "false") == 0 || strcasecmp(value, "no") == 0)
+			else if(strcasecmp(value, "false") == 0 || strcmp(value, "0") == 0)
 				conf_item->v.b = false;
 			else
 			{
@@ -60,13 +61,13 @@ static bool readStringValue(struct conf_
 		}
 		case CONF_ALL_DEBUG_BOOL:
 		{
-			if(strcasecmp(value, "true") == 0 || strcasecmp(value, "yes") == 0)
+			if(strcasecmp(value, "true") == 0 || strcmp(value, "1") == 0)
 			{
 				set_all_debug(newconf, true);
 				conf_item->v.b = true;
 				set_debug_flags(newconf);
 			}
-			else if(strcasecmp(value, "false") == 0 || strcasecmp(value, "no") == 0)
+			else if(strcasecmp(value, "false") == 0 || strcmp(value, "0") == 0)
 			{
 				set_all_debug(newconf, false);
 				conf_item->v.b = false;
@@ -74,7 +75,7 @@ static bool readStringValue(struct conf_
 			}
 			else
 			{
-				log_err("Config setting %s is invalid, allowed options are: [ true, false, yes, no ]", conf_item->k);
+				log_err("Config setting %s is invalid, allowed options are: [ true, false, 1, 0 ]", conf_item->k);
 				return false;
 			}
 			break;
@@ -380,7 +381,7 @@ static bool readStringValue(struct conf_
 	return true;
 }
 
-int set_config_from_CLI(const char *key, const char *value)
+int set_config_from_CLI(struct uci_context *ctx, const char *key, const char *value)
 {
 	// Check if we are either
 	// - root, or
@@ -398,6 +399,7 @@ int set_config_from_CLI(const char *key,
 			printf("Permission error: User %s is not allowed to edit Pi-hole's config\n", current_user->pw_name);
 
 		printf("Please run this command using sudo\n\n");
+		clean_all();
 		return EXIT_FAILURE;
 	}
 
@@ -418,6 +420,7 @@ int set_config_from_CLI(const char *key,
 		{
 			log_err("Config option %s is read-only (set via environmental variable)", key);
 			free_config(&newconf);
+			clean_all();
 			return ENV_VAR_FORCED;
 		}
 
@@ -449,6 +452,7 @@ int set_config_from_CLI(const char *key,
 	if(!readStringValue(new_item, value, &newconf))
 	{
 		free_config(&newconf);
+		clean_all();
 		return VALUE_INVALID;
 	}
 
@@ -476,11 +480,12 @@ int set_config_from_CLI(const char *key,
 		if(conf_item->f & FLAG_RESTART_FTL)
 		{
 			char errbuf[ERRBUF_SIZE] = { 0 };
-			if(!write_dnsmasq_config(&newconf, true, errbuf))
+			if(!write_dnsmasq_config(ctx, &newconf, true, errbuf))
 			{
 				// Test failed
 				log_debug(DEBUG_CONFIG, "Config item %s: dnsmasq config test failed", conf_item->k);
 				free_config(&newconf);
+				clean_all();
 				return DNSMASQ_TEST_FAILED;
 			}
 		}
@@ -491,6 +496,10 @@ int set_config_from_CLI(const char *key,
 			write_custom_list();
 		}
 
+		// save to uci config
+		if(uci_set_value(ctx, new_item, value))
+			log_err("Failed to save new config for: %s=%s", new_item->k, value);
+
 		// Install new configuration
 		replace_config(&newconf);
 
@@ -509,6 +518,7 @@ int set_config_from_CLI(const char *key,
 
 	putchar('\n');
 	writeFTLtoml(false);
+	clean_all();
 	return OKAY;
 }
 
@@ -526,7 +536,7 @@ int get_config_from_CLI(const char *key,
 		struct conf_item *item = get_conf_item(&config, i);
 
 		// Check if item.k is identical with key
-		if(strcmp(item->k, key) == 0)
+		if(key != NULL && strcmp(item->k, key) == 0)
 		{
 			exactMatch = true;
 			break;
@@ -575,6 +585,7 @@ int get_config_from_CLI(const char *key,
 			log_err(" - %s", matches[i]);
 		free(matches);
 
+		clean_all();
 		return KEY_UNKNOWN;
 	}
 
@@ -583,5 +594,6 @@ int get_config_from_CLI(const char *key,
 	if(quiet && conf_item != NULL && conf_item->t == CONF_BOOL)
 		return conf_item->v.b ? OKAY : FAIL;
 
+	clean_all();
 	return OKAY;
 }
--- a/src/config/cli.h	2024-03-13 17:40:43.000000000 +0700
+++ b/src/config/cli.h	2024-03-13 17:40:48.000000000 +0700
@@ -9,8 +9,9 @@
 *  Please see LICENSE file for your rights under this license. */
 #ifndef CONFIG_CLI_H
 #define CONFIG_CLI_H
+#include <uci.h>
 
-int set_config_from_CLI(const char *key, const char *value);
+int set_config_from_CLI(struct uci_context *ctx, const char *key, const char *value);
 int get_config_from_CLI(const char *key, const bool quiet);
 
 #endif //CONFIG_CLI_H
\ No newline at end of file
--- a/src/config/config.c	2024-03-13 17:40:43.000000000 +0700
+++ b/src/config/config.c	2024-03-13 17:43:25.000000000 +0700
@@ -35,14 +35,12 @@
 #include "config/env.h"
 // sha256sum()
 #include "files.h"
+#include "config/config_uci.h"
 
 struct config config = { 0 };
 static bool config_initialized = false;
 uint8_t last_checksum[SHA256_DIGEST_SIZE] = { 0 };
 
-// Private prototypes
-static bool port_in_use(const in_port_t port);
-
 // Set debug flags from config struct to global debug_flags array
 // This is called whenever the config is reloaded and debug flags may have
 // changed
@@ -389,7 +387,7 @@ void initConfig(struct config *conf)
 	conf->dns.upstreams.a = cJSON_CreateStringReference("array of IP addresses and/or hostnames, optionally with a port (#...)");
 	conf->dns.upstreams.t = CONF_JSON_STRING_ARRAY;
 	conf->dns.upstreams.d.json = cJSON_CreateArray();
-	conf->dns.upstreams.f = FLAG_RESTART_FTL;
+	conf->dns.upstreams.f = FLAG_RESTART_FTL | FLAG_PKG_DHCP;
 	conf->dns.upstreams.c = validate_stub; // Type-based checking + dnsmasq syntax checking
 
 	conf->dns.CNAMEdeepInspect.k = "dns.CNAMEdeepInspect";
@@ -486,14 +484,14 @@ void initConfig(struct config *conf)
 	conf->dns.domainNeeded.k = "dns.domainNeeded";
 	conf->dns.domainNeeded.h = "If set, A and AAAA queries for plain names, without dots or domain parts, are never forwarded to upstream nameservers";
 	conf->dns.domainNeeded.t = CONF_BOOL;
-	conf->dns.domainNeeded.f = FLAG_RESTART_FTL | FLAG_ADVANCED_SETTING;
+	conf->dns.domainNeeded.f = FLAG_RESTART_FTL | FLAG_ADVANCED_SETTING | FLAG_PKG_DHCP;
 	conf->dns.domainNeeded.d.b = false;
 	conf->dns.domainNeeded.c = validate_stub; // Only type-based checking
 
 	conf->dns.expandHosts.k = "dns.expandHosts";
 	conf->dns.expandHosts.h = "If set, the domain is added to simple names (without a period) in /etc/hosts in the same way as for DHCP-derived names";
 	conf->dns.expandHosts.t = CONF_BOOL;
-	conf->dns.expandHosts.f = FLAG_RESTART_FTL | FLAG_ADVANCED_SETTING;
+	conf->dns.expandHosts.f = FLAG_RESTART_FTL | FLAG_ADVANCED_SETTING | FLAG_PKG_DHCP;
 	conf->dns.expandHosts.d.b = false;
 	conf->dns.expandHosts.c = validate_stub; // Only type-based checking
 
@@ -501,37 +499,29 @@ void initConfig(struct config *conf)
 	conf->dns.domain.h = "The DNS domain used by your Pi-hole to expand hosts and for DHCP.\n\n Only if DHCP is enabled below: For DHCP, this has two effects; firstly it causes the DHCP server to return the domain to any hosts which request it, and secondly it sets the domain which it is legal for DHCP-configured hosts to claim. The intention is to constrain hostnames so that an untrusted host on the LAN cannot advertise its name via DHCP as e.g. \"google.com\" and capture traffic not meant for it. If no domain suffix is specified, then any DHCP hostname with a domain part (ie with a period) will be disallowed and logged. If a domain is specified, then hostnames with a domain part are allowed, provided the domain part matches the suffix. In addition, when a suffix is set then hostnames without a domain part have the suffix added as an optional domain part. For instance, we can set domain=mylab.com and have a machine whose DHCP hostname is \"laptop\". The IP address for that machine is available both as \"laptop\" and \"laptop.mylab.com\".\n\n You can disable setting a domain by setting this option to an empty string.";
 	conf->dns.domain.a = cJSON_CreateStringReference("<any valid domain>");
 	conf->dns.domain.t = CONF_STRING;
-	conf->dns.domain.f = FLAG_RESTART_FTL | FLAG_ADVANCED_SETTING;
-	conf->dns.domain.d.s = (char*)"lan";
+	conf->dns.domain.f = FLAG_RESTART_FTL | FLAG_ADVANCED_SETTING | FLAG_PKG_DHCP;
+	conf->dns.domain.d.s = (char*)"";
 	conf->dns.domain.c = validate_domain;
 
 	conf->dns.bogusPriv.k = "dns.bogusPriv";
 	conf->dns.bogusPriv.h = "Should all reverse lookups for private IP ranges (i.e., 192.168.x.y, etc) which are not found in /etc/hosts or the DHCP leases file be answered with \"no such domain\" rather than being forwarded upstream?";
 	conf->dns.bogusPriv.t = CONF_BOOL;
-	conf->dns.bogusPriv.f = FLAG_RESTART_FTL | FLAG_ADVANCED_SETTING;
+	conf->dns.bogusPriv.f = FLAG_RESTART_FTL | FLAG_ADVANCED_SETTING | FLAG_PKG_DHCP;
 	conf->dns.bogusPriv.d.b = true;
 	conf->dns.bogusPriv.c = validate_stub; // Only type-based checking
 
 	conf->dns.dnssec.k = "dns.dnssec";
 	conf->dns.dnssec.h = "Validate DNS replies using DNSSEC?";
 	conf->dns.dnssec.t = CONF_BOOL;
-	conf->dns.dnssec.f = FLAG_RESTART_FTL;
+	conf->dns.dnssec.f = FLAG_RESTART_FTL | FLAG_PKG_DHCP;
 	conf->dns.dnssec.c = validate_stub; // Only type-based checking
 	conf->dns.dnssec.d.b = false;
 
-	conf->dns.interface.k = "dns.interface";
-	conf->dns.interface.h = "Interface to use for DNS (see also dnsmasq.listening.mode) and DHCP (if enabled)";
-	conf->dns.interface.a = cJSON_CreateStringReference("a valid interface name");
-	conf->dns.interface.t = CONF_STRING;
-	conf->dns.interface.f = FLAG_RESTART_FTL | FLAG_ADVANCED_SETTING;
-	conf->dns.interface.d.s = (char*)"";
-	conf->dns.interface.c = validate_stub; // Type-based checking + dnsmasq syntax checking
-
 	conf->dns.hostRecord.k = "dns.hostRecord";
 	conf->dns.hostRecord.h = "Add A, AAAA and PTR records to the DNS. This adds one or more names to the DNS with associated IPv4 (A) and IPv6 (AAAA) records";
 	conf->dns.hostRecord.a = cJSON_CreateStringReference("<name>[,<name>....],[<IPv4-address>],[<IPv6-address>][,<TTL>]");
 	conf->dns.hostRecord.t = CONF_STRING;
-	conf->dns.hostRecord.f = FLAG_RESTART_FTL | FLAG_ADVANCED_SETTING;
+	conf->dns.hostRecord.f = FLAG_RESTART_FTL | FLAG_ADVANCED_SETTING | FLAG_PKG_DHCP;
 	conf->dns.hostRecord.d.s = (char*)"";
 	conf->dns.hostRecord.c = validate_stub; // Type-based checking + dnsmasq syntax checking
 
@@ -549,29 +539,29 @@ void initConfig(struct config *conf)
 		CONFIG_ADD_ENUM_OPTIONS(conf->dns.listeningMode.a, listeningMode);
 	}
 	conf->dns.listeningMode.t = CONF_ENUM_LISTENING_MODE;
-	conf->dns.listeningMode.f = FLAG_RESTART_FTL | FLAG_ADVANCED_SETTING;
+	conf->dns.listeningMode.f = FLAG_RESTART_FTL | FLAG_ADVANCED_SETTING | FLAG_PKG_DHCP;
 	conf->dns.listeningMode.d.listeningMode = LISTEN_LOCAL;
 	conf->dns.listeningMode.c = validate_stub; // Only type-based checking
 
 	conf->dns.queryLogging.k = "dns.queryLogging";
 	conf->dns.queryLogging.h = "Log DNS queries and replies to pihole.log";
 	conf->dns.queryLogging.t = CONF_BOOL;
-	conf->dns.queryLogging.f = FLAG_RESTART_FTL;
-	conf->dns.queryLogging.d.b = true;
+	conf->dns.queryLogging.f = FLAG_RESTART_FTL | FLAG_PKG_DHCP;
+	conf->dns.queryLogging.d.b = false;
 	conf->dns.queryLogging.c = validate_stub; // Only type-based checking
 
 	conf->dns.cnameRecords.k = "dns.cnameRecords";
 	conf->dns.cnameRecords.h = "List of CNAME records which indicate that <cname> is really <target>. If the <TTL> is given, it overwrites the value of local-ttl";
 	conf->dns.cnameRecords.a = cJSON_CreateStringReference("Array of CNAMEs each on in one of the following forms: \"<cname>,<target>[,<TTL>]\"");
 	conf->dns.cnameRecords.t = CONF_JSON_STRING_ARRAY;
-	conf->dns.cnameRecords.f = FLAG_RESTART_FTL | FLAG_ADVANCED_SETTING;
+	conf->dns.cnameRecords.f = FLAG_RESTART_FTL | FLAG_ADVANCED_SETTING | FLAG_PKG_DHCP;
 	conf->dns.cnameRecords.d.json = cJSON_CreateArray();
 	conf->dns.cnameRecords.c = validate_dns_cnames;
 
 	conf->dns.port.k = "dns.port";
 	conf->dns.port.h = "Port used by the DNS server";
 	conf->dns.port.t = CONF_UINT16;
-	conf->dns.port.f = FLAG_RESTART_FTL | FLAG_ADVANCED_SETTING;
+	conf->dns.port.f = FLAG_RESTART_FTL | FLAG_ADVANCED_SETTING | FLAG_PKG_DHCP;
 	conf->dns.port.d.ui = 53u;
 	conf->dns.port.c = validate_stub; // Only type-based checking
 
@@ -579,7 +569,7 @@ void initConfig(struct config *conf)
 	conf->dns.cache.size.k = "dns.cache.size";
 	conf->dns.cache.size.h = "Cache size of the DNS server. Note that expiring cache entries naturally make room for new insertions over time. Setting this number too high will have an adverse effect as not only more space is needed, but also lookup speed gets degraded in the 10,000+ range. dnsmasq may issue a warning when you go beyond 10,000+ cache entries.";
 	conf->dns.cache.size.t = CONF_UINT;
-	conf->dns.cache.size.f = FLAG_RESTART_FTL | FLAG_ADVANCED_SETTING;
+	conf->dns.cache.size.f = FLAG_RESTART_FTL | FLAG_ADVANCED_SETTING | FLAG_PKG_DHCP;
 	conf->dns.cache.size.d.ui = 10000u;
 	conf->dns.cache.size.c = validate_stub; // Only type-based checking
 
@@ -620,7 +610,7 @@ void initConfig(struct config *conf)
 	conf->dns.revServers.t = CONF_JSON_STRING_ARRAY;
 	conf->dns.revServers.d.json = cJSON_CreateArray();
 	conf->dns.revServers.c = validate_dns_revServers;
-	conf->dns.revServers.f = FLAG_RESTART_FTL;
+	conf->dns.revServers.f = FLAG_RESTART_FTL | FLAG_PKG_DHCP;
 
 	// sub-struct dns.rate_limit
 	conf->dns.rateLimit.count.k = "dns.rateLimit.count";
@@ -714,67 +704,28 @@ void initConfig(struct config *conf)
 	conf->dhcp.active.h = "Is the embedded DHCP server enabled?";
 	conf->dhcp.active.t = CONF_BOOL;
 	conf->dhcp.active.f = FLAG_RESTART_FTL;
-	conf->dhcp.active.d.b = false;
+	conf->dhcp.active.d.b = true;
 	conf->dhcp.active.c = validate_stub; // Only type-based checking
 
-	conf->dhcp.start.k = "dhcp.start";
-	conf->dhcp.start.h = "Start address of the DHCP address pool";
-	conf->dhcp.start.a = cJSON_CreateStringReference("<valid IPv4 address> or empty string (\"\"), e.g., \"192.168.0.10\"");
-	conf->dhcp.start.t = CONF_STRUCT_IN_ADDR;
-	conf->dhcp.start.f = FLAG_RESTART_FTL;
-	memset(&conf->dhcp.start.d.in_addr, 0, sizeof(struct in_addr));
-	conf->dhcp.start.c = validate_stub; // Only type-based checking
-
-	conf->dhcp.end.k = "dhcp.end";
-	conf->dhcp.end.h = "End address of the DHCP address pool";
-	conf->dhcp.end.a = cJSON_CreateStringReference("<valid IPv4 address> or empty string (\"\"), e.g., \"192.168.0.250\"");
-	conf->dhcp.end.t = CONF_STRUCT_IN_ADDR;
-	conf->dhcp.end.f = FLAG_RESTART_FTL;
-	memset(&conf->dhcp.end.d.in_addr, 0, sizeof(struct in_addr));
-	conf->dhcp.end.c = validate_stub; // Only type-based checking
-
-	conf->dhcp.router.k = "dhcp.router";
-	conf->dhcp.router.h = "Address of the gateway to be used (typically the address of your router in a home installation)";
-	conf->dhcp.router.a = cJSON_CreateStringReference("<valid IPv4 address> or empty string (\"\"), e.g., \"192.168.0.1\"");
-	conf->dhcp.router.t = CONF_STRUCT_IN_ADDR;
-	conf->dhcp.router.f = FLAG_RESTART_FTL;
-	memset(&conf->dhcp.router.d.in_addr, 0, sizeof(struct in_addr));
-	conf->dhcp.router.c = validate_stub; // Only type-based checking
-
-	conf->dhcp.netmask.k = "dhcp.netmask";
-	conf->dhcp.netmask.h = "The netmask used by your Pi-hole. For directly connected networks (i.e., networks on which the machine running Pi-hole has an interface) the netmask is optional and may be set to an empty string (\"\"): it will then be determined from the interface configuration itself. For networks which receive DHCP service via a relay agent, we cannot determine the netmask itself, so it should explicitly be specified, otherwise Pi-hole guesses based on the class (A, B or C) of the network address.";
-	conf->dhcp.netmask.a = cJSON_CreateStringReference("<any valid netmask> (e.g., \"255.255.255.0\") or empty string (\"\") for auto-discovery");
-	conf->dhcp.netmask.t = CONF_STRUCT_IN_ADDR;
-	conf->dhcp.netmask.f = FLAG_RESTART_FTL | FLAG_ADVANCED_SETTING;
-	memset(&conf->dhcp.netmask.d.in_addr, 0, sizeof(struct in_addr));
-	conf->dhcp.netmask.c = validate_stub; // Only type-based checking
-
-	conf->dhcp.leaseTime.k = "dhcp.leaseTime";
-	conf->dhcp.leaseTime.h = "If the lease time is given, then leases will be given for that length of time. If not given, the default lease time is one hour for IPv4 and one day for IPv6.";
-	conf->dhcp.leaseTime.a = cJSON_CreateStringReference("The lease time can be in seconds, or minutes (e.g., \"45m\") or hours (e.g., \"1h\") or days (like \"2d\") or even weeks (\"1w\"). You may also use \"infinite\" as string but be aware of the drawbacks");
-	conf->dhcp.leaseTime.t = CONF_STRING;
-	conf->dhcp.leaseTime.f = FLAG_RESTART_FTL | FLAG_ADVANCED_SETTING;
-	conf->dhcp.leaseTime.d.s = (char*)"";
-	conf->dhcp.leaseTime.c = validate_stub; // Type-based checking + dnsmasq syntax checking
-
-	conf->dhcp.ipv6.k = "dhcp.ipv6";
-	conf->dhcp.ipv6.h = "Should Pi-hole make an attempt to also satisfy IPv6 address requests (be aware that IPv6 works a whole lot different than IPv4)";
-	conf->dhcp.ipv6.t = CONF_BOOL;
-	conf->dhcp.ipv6.f = FLAG_RESTART_FTL;
-	conf->dhcp.ipv6.d.b = false;
-	conf->dhcp.ipv6.c = validate_stub; // Only type-based checking
+	conf->dhcp.leaseFile.k = "dhcp.leaseFile";
+	conf->dhcp.leaseFile.h = "The file which contains DHCP Lease information.";
+	conf->dhcp.leaseFile.a = cJSON_CreateStringReference("<any writable file>");
+	conf->dhcp.leaseFile.t = CONF_STRING;
+	conf->dhcp.leaseFile.f = FLAG_RESTART_FTL | FLAG_ADVANCED_SETTING | FLAG_PKG_DHCP;
+	conf->dhcp.leaseFile.d.s = (char*)"/etc/pihole/dhcp.leases";
+	conf->dhcp.leaseFile.c = validate_filepath;
 
 	conf->dhcp.multiDNS.k = "dhcp.multiDNS";
 	conf->dhcp.multiDNS.h = "Advertise DNS server multiple times to clients. Some devices will add their own proprietary DNS servers to the list of DNS servers, which can cause issues with Pi-hole. This option will advertise the Pi-hole DNS server multiple times to clients, which should prevent this from happening.";
 	conf->dhcp.multiDNS.t = CONF_BOOL;
-	conf->dhcp.multiDNS.f = FLAG_RESTART_FTL;
+	conf->dhcp.multiDNS.f = FLAG_RESTART_FTL | FLAG_PKG_DHCP;
 	conf->dhcp.multiDNS.d.b = false;
 	conf->dhcp.multiDNS.c = validate_stub; // Only type-based checking
 
 	conf->dhcp.rapidCommit.k = "dhcp.rapidCommit";
 	conf->dhcp.rapidCommit.h = "Enable DHCPv4 Rapid Commit Option specified in RFC 4039. Should only be enabled if either the server is the only server for the subnet to avoid conflicts";
 	conf->dhcp.rapidCommit.t = CONF_BOOL;
-	conf->dhcp.rapidCommit.f = FLAG_RESTART_FTL;
+	conf->dhcp.rapidCommit.f = FLAG_RESTART_FTL | FLAG_PKG_DHCP;
 	conf->dhcp.rapidCommit.d.b = false;
 	conf->dhcp.rapidCommit.c = validate_stub; // Only type-based checking
 
@@ -782,7 +733,7 @@ void initConfig(struct config *conf)
 	conf->dhcp.hosts.h = "Per host parameters for the DHCP server. This allows a machine with a particular hardware address to be always allocated the same hostname, IP address and lease time or to specify static DHCP leases";
 	conf->dhcp.hosts.a = cJSON_CreateStringReference("Array of static leases each on in one of the following forms: \"[<hwaddr>][,id:<client_id>|*][,set:<tag>][,tag:<tag>][,<ipaddr>][,<hostname>][,<lease_time>][,ignore]\"");
 	conf->dhcp.hosts.t = CONF_JSON_STRING_ARRAY;
-	conf->dhcp.hosts.f = FLAG_RESTART_FTL | FLAG_ADVANCED_SETTING;
+	conf->dhcp.hosts.f = FLAG_RESTART_FTL | FLAG_ADVANCED_SETTING | FLAG_PKG_DHCP;
 	conf->dhcp.hosts.d.json = cJSON_CreateArray();
 	conf->dhcp.hosts.c = validate_stub; // Type-based checking + dnsmasq syntax checking
 
@@ -900,7 +851,7 @@ void initConfig(struct config *conf)
 	conf->webserver.port.a = cJSON_CreateStringReference("comma-separated list of <[ip_address:]port>");
 	conf->webserver.port.f = FLAG_ADVANCED_SETTING | FLAG_RESTART_FTL;
 	conf->webserver.port.t = CONF_STRING;
-	conf->webserver.port.d.s = (char*)"80,[::]:80,443s,[::]:443s";
+	conf->webserver.port.d.s = (char*)"8080";
 	conf->webserver.port.c = validate_stub; // Type-based checking + civetweb syntax checking
 
 	conf->webserver.tls.rev_proxy.k = "webserver.tls.rev_proxy";
@@ -1154,7 +1105,7 @@ void initConfig(struct config *conf)
 	conf->files.log.dnsmasq.h = "The log file used by the embedded dnsmasq DNS server";
 	conf->files.log.dnsmasq.a = cJSON_CreateStringReference("<any writable file>");
 	conf->files.log.dnsmasq.t = CONF_STRING;
-	conf->files.log.dnsmasq.f = FLAG_ADVANCED_SETTING | FLAG_RESTART_FTL;
+	conf->files.log.dnsmasq.f = FLAG_ADVANCED_SETTING | FLAG_RESTART_FTL | FLAG_PKG_DHCP;
 	conf->files.log.dnsmasq.d.s = (char*)"/var/log/pihole/pihole.log";
 	conf->files.log.dnsmasq.c = validate_filepath_dash;
 
@@ -1196,13 +1147,6 @@ void initConfig(struct config *conf)
 	conf->misc.addr2line.d.b = true;
 	conf->misc.addr2line.c = validate_stub; // Only type-based checking
 
-	conf->misc.etc_dnsmasq_d.k = "misc.etc_dnsmasq_d";
-	conf->misc.etc_dnsmasq_d.h = "Should FTL load additional dnsmasq configuration files from /etc/dnsmasq.d/?";
-	conf->misc.etc_dnsmasq_d.t = CONF_BOOL;
-	conf->misc.etc_dnsmasq_d.f = FLAG_RESTART_FTL | FLAG_ADVANCED_SETTING;
-	conf->misc.etc_dnsmasq_d.d.b = false;
-	conf->misc.etc_dnsmasq_d.c = validate_stub; // Only type-based checking
-
 	conf->misc.dnsmasq_lines.k = "misc.dnsmasq_lines";
 	conf->misc.dnsmasq_lines.h = "Additional lines to inject into the generated dnsmasq configuration.\n Warning: This is an advanced setting and should only be used with care. Incorrectly formatted or duplicated lines as well as lines conflicting with the automatic configuration of Pi-hole can break the embedded dnsmasq and will stop DNS resolution from working.\n Use this option with extra care.";
 	conf->misc.dnsmasq_lines.a = cJSON_CreateStringReference("array of valid dnsmasq config line options");
@@ -1521,7 +1465,7 @@ void reset_config(struct conf_item *conf
 	}
 }
 
-bool readFTLconf(struct config *conf, const bool rewrite)
+bool readFTLconf(struct config *conf, const bool rewrite, struct uci_context *ctx)
 {
 	// Initialize config with default values
 	initConfig(conf);
@@ -1529,6 +1473,9 @@ bool readFTLconf(struct config *conf, co
 	// First, read the environment
 	getEnvVars();
 
+	// read uci value
+	uci_get_config_value(ctx, conf);
+
 	// Try to read TOML config file
 	// If we cannot parse /etc/pihole.toml (due to missing or invalid syntax),
 	// we try to read the rotated files in /etc/pihole/config_backup starting at
@@ -1543,8 +1490,9 @@ bool readFTLconf(struct config *conf, co
 			if(rewrite)
 			{
 				writeFTLtoml(true);
-				write_dnsmasq_config(conf, false, NULL);
+				write_dnsmasq_config(ctx, conf, false, NULL);
 				write_custom_list();
+				write_hosts_file();
 			}
 			return true;
 		}
@@ -1583,44 +1531,16 @@ bool readFTLconf(struct config *conf, co
 		rename(GLOBALTOMLPATH, new_name);
 	}
 
-	// Determine default webserver ports if not imported from setupVars.conf
-	if(!(config.webserver.port.f & FLAG_CONF_IMPORTED))
-	{
-		// Check if ports 80/TCP and 443/TCP are already in use
-		const in_port_t http_port = port_in_use(80) ? 8080 : 80;
-		const in_port_t https_port = port_in_use(443) ? 8443 : 443;
-
-		// Create a string with the default ports
-		// Allocate memory for the string
-		char *ports = calloc(32, sizeof(char));
-		if(ports == NULL)
-		{
-			log_err("Unable to allocate memory for default ports string");
-			return false;
-		}
-		// Create the string
-		snprintf(ports, 32, "%d,%ds", http_port, https_port);
-
-		// Append IPv6 ports if IPv6 is enabled
-		const bool have_ipv6 = ipv6_enabled();
-		if(have_ipv6)
-			snprintf(ports + strlen(ports), 32 - strlen(ports),
-				",[::]:%d,[::]:%ds", http_port, https_port);
-
-		// Set default values for webserver ports
-		if(conf->webserver.port.t == CONF_STRING_ALLOCATED)
-			free(conf->webserver.port.v.s);
-		conf->webserver.port.v.s = ports;
-		conf->webserver.port.t = CONF_STRING_ALLOCATED;
-
-		log_info("Initialised webserver ports at %d (HTTP) and %d (HTTPS), IPv6 support is %s",
-			http_port, https_port, have_ipv6 ? "enabled" : "disabled");
-	}
+	log_info("Initialised webserver ports at %s", conf->webserver.port.v.s);
 
 	// Initialize the TOML config file
 	writeFTLtoml(true);
-	write_dnsmasq_config(conf, false, NULL);
-	write_custom_list();
+	if(rewrite)
+	{
+		write_dnsmasq_config(ctx, conf, false, NULL);
+		write_custom_list();
+		write_hosts_file();
+	}
 
 	return false;
 }
@@ -1797,43 +1717,22 @@ void reread_config(void)
 	// at any time and is automatically reloaded by dnsmasq
 	write_custom_list();
 
+	// reload uci config
+	if(!uci_load_package(uci_ctx, true))
+	{
+		log_err("failed to reload uci config");
+		return;
+	}
+
+	uci_get_config_value(uci_ctx, &config);
+	write_hosts_file();
+
 	// If we need to restart FTL, we do so now
 	if(restart)
 	{
-		log_info("Restarting FTL due to pihole.toml change");
+		log_info("Restarting FTL due to config change");
 		exit_code = RESTART_FTL_CODE;
 		// Send SIGTERM to FTL
 		kill(main_pid(), SIGTERM);
 	}
 }
-
-// Very simple test of a port's availability by trying to bind a TCP socket to
-// it at 0.0.0.0 (this tests only IPv4 availability)
-static bool port_in_use(const in_port_t port)
-{
-	// Create a socket
-	const int sock = socket(AF_INET, SOCK_STREAM, 0);
-	if(sock < 0)
-	{
-		log_err("Unable to create port testing socket: %s", strerror(errno));
-		return false;
-	}
-
-	// Bind the socket to the desired port
-	struct sockaddr_in addr = { 0 };
-	addr.sin_family = AF_INET;
-	addr.sin_port = htons(port);
-	addr.sin_addr.s_addr = htonl(INADDR_ANY);
-
-	// Try to bind the socket
-	if(bind(sock, (struct sockaddr*)&addr, sizeof(addr)) < 0 && errno == EADDRINUSE)
-	{
-		// If we cannot bind the socket, the port is in use
-		close(sock);
-		return true;
-	}
-
-	// If we can bind the socket, the port is not in use
-	close(sock);
-	return false;
-}
--- a/src/config/config.h	2024-03-13 17:40:43.000000000 +0700
+++ b/src/config/config.h	2024-03-13 17:41:36.000000000 +0700
@@ -31,6 +31,7 @@
 #endif
 // enum web_theme
 #include "api/theme.h"
+#include <uci.h>
 
 #define GLOBALTOMLPATH "/tmp/etc/pihole.toml"
 
@@ -105,6 +106,7 @@ enum conf_type {
 #define FLAG_WRITE_ONLY            (1 << 4)
 #define FLAG_ENV_VAR               (1 << 5)
 #define FLAG_CONF_IMPORTED         (1 << 6)
+#define FLAG_PKG_DHCP              (1 << 7)
 
 struct conf_item {
 	const char *k;        // item Key
@@ -146,7 +148,6 @@ struct config {
 		struct conf_item domain;
 		struct conf_item bogusPriv;
 		struct conf_item dnssec;
-		struct conf_item interface;
 		struct conf_item hostRecord;
 		struct conf_item listeningMode;
 		struct conf_item queryLogging;
@@ -187,12 +188,7 @@ struct config {
 
 	struct {
 		struct conf_item active;
-		struct conf_item start;
-		struct conf_item end;
-		struct conf_item router;
-		struct conf_item netmask;
-		struct conf_item leaseTime;
-		struct conf_item ipv6;
+		struct conf_item leaseFile;
 		struct conf_item rapidCommit;
 		struct conf_item multiDNS;
 		struct conf_item hosts;
@@ -277,7 +273,6 @@ struct config {
 		struct conf_item delay_startup;
 		struct conf_item nice;
 		struct conf_item addr2line;
-		struct conf_item etc_dnsmasq_d;
 		struct conf_item dnsmasq_lines;
 		struct conf_item extraLogging;
 		struct {
@@ -333,7 +328,7 @@ void set_debug_flags(struct config *conf
 void set_all_debug(struct config *conf, const bool status);
 void initConfig(struct config *conf);
 void reset_config(struct conf_item *conf_item);
-bool readFTLconf(struct config *conf, const bool rewrite);
+bool readFTLconf(struct config *conf, const bool rewrite, struct uci_context *ctx);
 bool getLogFilePath(void);
 struct conf_item *get_conf_item(struct config *conf, const unsigned int n);
 struct conf_item *get_debug_item(struct config *conf, const enum debug_flag debug);
@@ -348,6 +343,9 @@ const char *get_conf_type_str(const enum
 void replace_config(struct config *newconf);
 void reread_config(void);
 
+// Defined in cli.c
+bool readStringValue(struct conf_item *conf_item, const char *value, struct config *newconf);
+
 // Defined in toml_reader.c
 bool readDebugSettings(void);
 void init_config_mutex(void);
--- a/src/config/config_uci.c	1970-01-01 07:00:00.000000000 +0700
+++ b/src/config/config_uci.c	2024-03-13 17:47:43.000000000 +0700
@@ -0,0 +1,898 @@
+#include "FTL.h"
+#include "log.h"
+#include "config_uci.h"
+#include "../datastructure.h"
+#include "password.h"
+#include <uci_blob.h>
+
+static struct blob_buf uci_b;
+static struct uci_ptr uci_ptr;
+struct uci_package *uci_dhcp;
+struct uci_package *uci_network;
+struct uci_package *uci_pihole;
+struct uci_context *uci_ctx;
+
+enum custom_domain_s {
+	DOMAIN_HOST_IP,
+	DOMAIN_HOST_NAME,
+	DOMAIN_HOST_MAX
+} __attribute__ ((packed));
+
+static const struct blobmsg_policy custom_domain_attrs[DOMAIN_HOST_MAX] = {
+	[DOMAIN_HOST_IP] = { .name = "ip", .type = BLOBMSG_TYPE_STRING },
+	[DOMAIN_HOST_NAME] = { .name = "name", .type = BLOBMSG_TYPE_STRING },
+};
+
+const struct uci_blob_param_list custom_domain_attr_list = {
+	.n_params = DOMAIN_HOST_MAX,
+	.params = custom_domain_attrs,
+};
+
+enum cname_s {
+	CNAME_NAME,
+	CNAME_TARGET,
+	CNAME_TTL,
+	CNAME_MAX
+} __attribute__ ((packed));
+
+static const struct blobmsg_policy cname_attrs[CNAME_MAX] = {
+	[CNAME_NAME] = { .name = "cname", .type = BLOBMSG_TYPE_STRING },
+	[CNAME_TARGET] = { .name = "target", .type = BLOBMSG_TYPE_STRING },
+	[CNAME_TTL] = { .name = "ttl", .type = BLOBMSG_TYPE_STRING },
+};
+
+static const struct uci_blob_param_list cname_attr_list = {
+	.n_params = CNAME_MAX,
+	.params = cname_attrs,
+};
+
+enum static_host_s {
+	STATIC_HOST_MAC,
+	STATIC_HOST_IP,
+	STATIC_HOST_NAME,
+	STATIC_HOST_LEASETIME,
+	STATIC_HOST_MAX
+} __attribute__ ((packed));
+
+static const struct blobmsg_policy static_hosts_attrs[STATIC_HOST_MAX] = {
+	[STATIC_HOST_MAC] = { .name = "mac", .type = BLOBMSG_TYPE_STRING },
+	[STATIC_HOST_IP] = { .name = "ip", .type = BLOBMSG_TYPE_STRING },
+	[STATIC_HOST_NAME] = { .name = "name", .type = BLOBMSG_TYPE_STRING },
+	[STATIC_HOST_LEASETIME] = { .name = "leasetime", .type = BLOBMSG_TYPE_STRING },
+};
+
+const struct uci_blob_param_list static_hosts_attr_list = {
+	.n_params = STATIC_HOST_MAX,
+	.params = static_hosts_attrs,
+};
+
+extern void watch_config(bool watch);
+
+// from libuci.c
+static const char *uci_errstr[] = {
+	[UCI_OK] =            "Success",
+	[UCI_ERR_MEM] =       "Out of memory",
+	[UCI_ERR_INVAL] =     "Invalid argument",
+	[UCI_ERR_NOTFOUND] =  "Entry not found",
+	[UCI_ERR_IO] =        "I/O error",
+	[UCI_ERR_PARSE] =     "Parse error",
+	[UCI_ERR_DUPLICATE] = "Duplicate entry",
+	[UCI_ERR_UNKNOWN] =   "Unknown error",
+};
+
+static int uci_init_ptr(struct uci_context *ctx, struct uci_package *pkg,
+						const char *sec, const char *opt, const char *val)
+{
+	if (!pkg)
+		return -1;
+
+	memset(&uci_ptr, 0, sizeof(uci_ptr));
+	uci_ptr.p = pkg;
+	uci_ptr.section = sec;
+
+	if (uci_ptr.section && *sec == '@')
+		uci_ptr.flags |= UCI_LOOKUP_EXTENDED;
+
+	if (!opt || !opt[0]) {
+		uci_ptr.target = UCI_TYPE_SECTION;
+		goto lookup;
+	}
+
+	uci_ptr.target = UCI_TYPE_OPTION;
+	uci_ptr.option = opt;
+	uci_ptr.value = val;
+
+lookup:
+	int ret = uci_lookup_ptr(ctx, &uci_ptr, NULL, true);
+	if(ret)
+		syslog(LOG_ERR, "uci_init_ptr: section: %s, option: %s, value %s (%s)",
+				 sec, opt, val ? val : "NULL", uci_errstr[ret]);
+
+	return ret;
+}
+
+static int uci_del_section(struct uci_section *section)
+{
+	if (!section)
+		return -1;
+
+	struct uci_ptr ptr = {
+		.p = section->package,
+		.s = section,
+	};
+
+	if(uci_lookup_ptr(uci_ctx, &ptr, NULL, true) != UCI_OK)
+		return UCI_ERR_PARSE;
+
+	int ret = uci_delete(uci_ctx, &ptr);
+	if(ret)
+		syslog(LOG_ERR, "uci_del_section: section: %s (%s)", ptr.s->type, uci_errstr[ret]);
+
+	return ret;
+}
+
+static void _uci_commit(struct uci_context *ctx, struct uci_package **pkg)
+{
+	if (!pkg)
+		return;
+
+	watch_config(false);
+	if (uci_commit(ctx, pkg, false))
+		syslog(LOG_ERR, "failed to commit config");
+
+	watch_config(true);
+	uci_load_package(ctx, true);
+}
+
+static void uci_read_foreach_to_json(struct conf_item *item, const struct uci_blob_param_list *list,
+									 const char *section)
+{
+	if (item->t != CONF_JSON_STRING_ARRAY)
+		return;
+
+	cJSON_Delete(item->v.json);
+	item->v.json = cJSON_CreateArray();
+
+	struct uci_element *e;
+	// only search in config dhcp
+	uci_foreach_element(&uci_dhcp->sections, e)
+	{
+		// e->name (named section)
+		struct uci_section *s = uci_to_section(e);
+		if (strcmp(s->type, section) != 0)
+			continue;
+
+		// syslog(LOG_INFO, "%s", s->e.name);
+		const char *delim = ",";
+		if(!strcmp(section, "domain"))
+			delim = " ";
+
+		struct blob_attr *tb[STATIC_HOST_MAX], *c;
+		blob_buf_init(&uci_b, 0);
+		uci_to_blob(&uci_b, s, list);
+		blobmsg_parse(list->params, list->n_params, tb, blob_data(uci_b.head), blob_len(uci_b.head));
+
+		static char buffer[512];
+		unsigned pos = 0;
+		buffer[0] = 0;
+
+		for(int i = 0; i < list->n_params; i++)
+		{
+			if ((c = tb[i]))
+				pos += snprintf(&buffer[pos], sizeof(buffer) - pos, "%s%s", blobmsg_get_string(c), delim);
+		}
+
+		// remove last delim
+		if (pos)
+			buffer[pos - 1] = 0;
+
+		cJSON *str = cJSON_CreateString(buffer);
+		cJSON_AddItemToArray(item->v.json, str);
+
+		// not really needed
+		blob_buf_free(&uci_b);
+	}
+}
+
+int uci_config_set(struct uci_package *pkg, const char *sec,
+				   const char *opt, const char *val, const bool list)
+{
+	int ret = uci_init_ptr(uci_ctx, pkg, sec, opt, (val) ? (val) : (""));
+	if (ret != UCI_OK)
+		return ret;
+
+	list ? (ret = uci_add_list(uci_ctx, &uci_ptr)) : (ret = uci_set(uci_ctx, &uci_ptr));
+	if(ret == UCI_OK)
+		_uci_commit(uci_ctx, &uci_ptr.p);
+	else
+		syslog(LOG_ERR, "uci_config_set: %s.%s=%s (%s)", sec, opt, val, uci_errstr[ret]);
+
+	return ret;
+}
+
+int uci_add_sec_foreach(struct uci_package *pkg, const char *key, const char *target)
+{
+	struct uci_ptr ptr = { .p = pkg, };
+	if(uci_lookup_ptr(uci_ctx, &ptr, NULL, true) != UCI_OK)
+		return UCI_ERR_INVAL;
+
+	const char *section = NULL;
+	const char *delim = ",";
+	if(!strcmp(key, "dns.hosts")) {
+		delim = " ";
+		section = "domain";
+	}
+	else if(!strcmp(key, "dns.cnameRecords"))
+		section = "cname";
+	else
+		return UCI_ERR_INVAL;
+
+	// ptr.section = ptr.s->e.name;
+	if(uci_add_section(uci_ctx, ptr.p, section, &ptr.s) != 0)
+		return UCI_ERR_INVAL;
+
+	char *tmp = NULL;
+	char* strtmp = strdup(target);
+	char *token = strtok_r(strtmp, delim, &tmp);
+	int ret = UCI_ERR_INVAL;
+	for(int i = 0; token != NULL; i++)
+	{
+		if(!strcmp(key, "dns.cnameRecords")) {
+			ptr.value = token;
+			// cname, target, ttl
+			if(i == 0) ptr.option = cname_attrs[i].name;
+			else if(i == 1) ptr.option = cname_attrs[i].name;
+			else if(i == 2) ptr.option = cname_attrs[i].name;
+			else if(i > 2) {
+				syslog(LOG_ERR, "something went wrong with cnameRecords, this should not be happening");
+				free(strtmp);
+				if(!ret)
+					uci_revert(uci_ctx, &ptr);
+				return ret;
+			}
+		} else if(!strcmp(key, "dns.hosts")) {
+			ptr.value = token;
+			// ip, name
+			if(i == 0) ptr.option = custom_domain_attrs[i].name;
+			else if(i == 1) ptr.option = custom_domain_attrs[i].name;
+			else if(i > 1) {
+				syslog(LOG_ERR, "something went wrong with dns hosts, this should not be happening");
+				free(strtmp);
+				if(!ret)
+					uci_revert(uci_ctx, &ptr);
+				return ret;
+			}
+		}
+
+		if(ptr.value && ptr.option)
+			ret = uci_set(uci_ctx, &ptr);
+
+		token = strtok_r(NULL, delim, &tmp);
+	}
+
+	if(ret == UCI_OK)
+		_uci_commit(uci_ctx, &ptr.p);
+
+	free(strtmp);
+	return ret;
+}
+
+int uci_del_sec_foreach(struct uci_package *pkg, const char *target)
+{
+	if(!pkg)
+		return -1;
+
+	char* strtmp = strdup(target);
+	const char *a = NULL;
+	const char *b = NULL;
+	if(strchr(strtmp, ',') != NULL) {
+		a = strtok(strtmp, ",");
+		b = strtok(NULL, ",");
+	} else {
+		a = strtok(strtmp, " ");
+		b = strtok(NULL, " ");
+	}
+
+	if(a == NULL || b == NULL) {
+		syslog(LOG_ERR, "failed to delete section for target: %s", target);
+		free(strtmp);
+		return -1;
+	}
+
+	struct uci_element *e;
+	uci_foreach_element(&pkg->sections, e) {
+		const char *tmp1 = NULL;
+		const char *tmp2 = NULL;
+		struct uci_section *s = uci_to_section(e);
+		// only find cname and domain section
+		if (strcmp(s->type, "cname") == 0) {
+			tmp1 = "cname";
+			tmp2 = "target";
+		} else if (strcmp(s->type, "domain") == 0) {
+			tmp1 = "ip";
+			tmp2 = "name";
+		} else
+			continue;
+
+		const char* tmp = uci_lookup_option_string(uci_ctx, s, tmp1);
+		if(!tmp)
+			continue;
+
+		// at least 2 options is belong to this section
+		if(strcmp(tmp, a) == 0)
+		{
+			tmp = uci_lookup_option_string(uci_ctx, s, tmp2);
+			if(tmp && strcmp(tmp, b) == 0)
+			{
+				if(uci_del_section(s) == UCI_OK) {
+					_uci_commit(uci_ctx, &pkg);
+					break;
+				}
+			}
+		}
+	}
+
+	free(strtmp);
+	return 0;
+}
+
+bool uci_read_bool(struct uci_context *ctx, struct uci_package *pkg,
+				   const char *sec, const char *opt, bool fallback)
+{
+	if(uci_init_ptr(ctx, pkg, sec, opt, NULL) != UCI_OK)
+		return fallback;
+
+	if(!(uci_ptr.flags & UCI_LOOKUP_COMPLETE))
+		return fallback;
+
+	if(uci_ptr.o->type == UCI_TYPE_STRING)
+	{
+		if(strcasecmp(uci_ptr.o->v.string, "false") == 0 || strcmp(uci_ptr.o->v.string, "0") == 0)
+			return false;
+		else if(strcasecmp(uci_ptr.o->v.string, "true") == 0 || strcmp(uci_ptr.o->v.string, "1") == 0)
+			return true;
+	}
+
+	return fallback;
+}
+
+// from https://stackoverflow.com/questions/8465006/
+static char* concat(int count, ...)
+{
+	va_list ap;
+	int i;
+
+	// Find required length to store merged string
+	int len = 1; // room for NULL
+	va_start(ap, count);
+	for(i=0 ; i<count ; i++)
+		len += strlen(va_arg(ap, char*));
+	va_end(ap);
+
+	// Allocate memory to concat strings
+	char *merged = calloc(sizeof(char),len);
+	int null_pos = 0;
+
+	// Actually concatenate strings
+	va_start(ap, count);
+	for(i=0 ; i<count ; i++)
+	{
+		char *s = va_arg(ap, char*);
+		strcpy(merged+null_pos, s);
+		null_pos += strlen(s);
+	}
+	va_end(ap);
+
+	return merged;
+}
+
+// use this function or add a new key in struct conf_item
+static void set_uci_type_name(struct conf_item *item, const char **section, char **option)
+{
+	unsigned int level = config_path_depth(item->p);
+
+	const char *delim = "_";
+	*section = "pihole";
+	if(item->f & FLAG_PKG_DHCP)
+	{
+		*section = "dnsmasq";
+		if(item == &config.dns.cache.size)
+			*option = strdup("cachesize");
+		else if(item == &config.files.log.dnsmasq)
+			*option = strdup("logfacility");
+		else if(strcmp(item->k, "dns.upstreams") == 0)
+			*option = strdup("server");
+		else {
+			char *tmp_opt= malloc(strlen(item->p[level-1]) + 1);
+			strcpy(tmp_opt, item->p[level-1]);
+			strtolower(tmp_opt);
+			*option = strdup(tmp_opt);
+			free(tmp_opt);
+		}
+	}
+	else if(item == &config.files.pid)
+		*option = strdup("pidfile");
+	else if(item == &config.files.log.ftl)
+		*option = strdup("logfile");
+	else if(item == &config.files.log.webserver) {
+		*section = "webserver";
+		*option = strdup("logfile");
+	}
+	else if(level == 4)
+	{
+		// webserver.api.xxx.xxx
+		if(strcmp(item->p[level - 4], "webserver") == 0) {
+			*section = "api";
+			*option = concat(3, item->p[level - 2], delim, item->p[level - 1]);
+		} else
+			// dns.reply.xxx.xxx
+			*option = concat(5, item->p[level - 3], delim, item->p[level - 2], delim, item->p[level - 1]);
+	}
+	else if(level == 3)
+	{
+		if(strcmp(item->p[level - 3], "webserver") == 0)
+		{
+			if(strcmp(item->p[level - 2], "api") == 0)
+				*section = "api";
+			else
+				*section = "webserver";
+
+			*option = strdup(item->p[level - 1]);
+		}
+		// database.network.xxx
+		else if(strcmp(item->p[level - 3], "database") == 0) {
+			*section = "database";
+			*option = concat(3, item->p[level - 2], delim, item->p[level - 1]);
+		}
+		else
+			*option = concat(3, item->p[level - 2], delim, item->p[level - 1]);
+	}
+	else
+	{
+		if(strcmp(item->p[level - 2], "debug") == 0)
+			*section = "debug";
+		else if(strcmp(item->p[level - 2], "webserver") == 0)
+			*section = "webserver";
+		else if(strcmp(item->p[level - 2], "database") == 0 ||
+				strcmp(item->p[level - 2], "files") == 0)
+			*section = "database";
+
+		*option = strdup(item->p[level - 1]);
+	}
+}
+
+int uci_set_value(struct uci_context *ctx, struct conf_item *item, const char *value)
+{
+	const char *sec = NULL;
+	char *opt = NULL;
+	set_uci_type_name(item, &sec, &opt);
+
+	struct uci_ptr ptr = {
+		.option = opt,
+		.target = UCI_TYPE_OPTION,
+	};
+
+	if(item->f & FLAG_PKG_DHCP)
+		ptr.p = uci_dhcp;
+	else
+		ptr.p = uci_pihole;
+
+	// create section if not exist
+	struct uci_section *s = get_uci_section_type(ctx, ptr.p, sec);
+	if(!s && uci_add_section(ctx, ptr.p, sec, &s)) {
+		syslog(LOG_ERR, "failed to create section: %s", sec);
+		free(opt);
+		return -1;
+	}
+
+	ptr.s = s;
+
+	switch(item->t)
+	{
+		case CONF_BOOL:
+		case CONF_ALL_DEBUG_BOOL:
+			ptr.value = item->v.b ? "1" : "0";
+			break;
+		case CONF_STRING:
+		case CONF_STRING_ALLOCATED:
+			ptr.value = item->v.s;
+			break;
+		case CONF_ENUM_BLOCKING_MODE:
+			ptr.value = get_blocking_mode_str(item->v.blocking_mode);
+			break;
+		case CONF_ENUM_WEB_THEME:
+			ptr.value = get_web_theme_str(item->v.web_theme);
+			break;
+		case CONF_ENUM_PTR_TYPE:
+			ptr.value = get_ptr_type_str(item->v.ptr_type);
+			break;
+		case CONF_ENUM_LISTENING_MODE:
+			ptr.value = get_listeningMode_str(item->v.listeningMode);
+			break;
+		case CONF_ENUM_BUSY_TYPE:
+			ptr.value = get_busy_reply_str(item->v.busy_reply);
+			break;
+		case CONF_ENUM_REFRESH_HOSTNAMES:
+			ptr.value = get_refresh_hostnames_str(item->v.refresh_hostnames);
+			break;
+		case CONF_INT:
+		case CONF_ENUM_PRIVACY_LEVEL:
+		case CONF_ENUM_TEMP_UNIT:
+		{
+			char *buf;
+			if (asprintf(&buf, "%i", item->v.i) > 0)
+				ptr.value = buf;
+			free(buf);
+			break;
+		}
+		case CONF_UINT:
+		{
+			char *buf;
+			if (asprintf(&buf, "%u", item->v.ui) > 0)
+				ptr.value = buf;
+			free(buf);
+			break;
+		}
+		case CONF_DOUBLE:
+		{
+			char *buf;
+			if (asprintf(&buf, "%f", item->v.d) > 0)
+				ptr.value = buf;
+			free(buf);
+			break;
+		}
+		case CONF_UINT16:
+		{
+			char *buf;
+			if (asprintf(&buf, "%u", item->v.ui) > 0)
+				ptr.value = buf;
+			free(buf);
+			break;
+		}
+		case CONF_LONG:
+		{
+			char *buf;
+			if (asprintf(&buf, "%li", item->v.l) > 0)
+				ptr.value = buf;
+			free(buf);
+			break;
+		}
+		case CONF_ULONG:
+		{
+			char *buf;
+			if (asprintf(&buf, "%lu", item->v.ul) > 0)
+				ptr.value = buf;
+			free(buf);
+			break;
+		}
+		case CONF_STRUCT_IN_ADDR:
+		{
+			char addr4[INET_ADDRSTRLEN] = { 0 };
+			inet_ntop(AF_INET, &item->v.in_addr, addr4, INET_ADDRSTRLEN);
+			ptr.value = addr4;
+
+			break;
+		}
+		case CONF_STRUCT_IN6_ADDR:
+		{
+			char addr6[INET6_ADDRSTRLEN] = { 0 };
+			inet_ntop(AF_INET6, &item->v.in6_addr, addr6, INET6_ADDRSTRLEN);
+			ptr.value = addr6;
+
+			break;
+		}
+		case CONF_PASSWORD:
+		case CONF_JSON_STRING_ARRAY:
+			break;
+	}
+
+	int ret = UCI_ERR_INVAL;
+	if(item->t == CONF_JSON_STRING_ARRAY && !uci_lookup_ptr(ctx, &ptr, NULL, true))
+	{
+		ret = uci_delete(ctx, &ptr);
+		for(int i = 0; i < cJSON_GetArraySize(item->v.json); i++)
+		{
+			cJSON *server = cJSON_GetArrayItem(item->v.json, i);
+			if(server != NULL && cJSON_IsString(server)) {
+				ptr.value = server->valuestring;
+				if(!uci_lookup_ptr(ctx, &ptr, NULL, true))
+					ret = uci_add_list(ctx, &ptr);
+			}
+		}
+	} else if(item->t == CONF_PASSWORD) {
+		// from cli.c
+		item--;
+		char *pwhash = strlen(value) > 0 ? create_password(value) : strdup("");
+		if(verify_password(value, pwhash, false)) {
+			ptr.option = "pwhash";
+			ptr.value = pwhash;
+			if(!uci_lookup_ptr(ctx, &ptr, NULL, true))
+				ret = uci_set(ctx, &ptr);
+		}
+
+		free(pwhash);
+	} else if(!uci_lookup_ptr(ctx, &ptr, NULL, true))
+		ret = uci_set(ctx, &ptr);
+
+	if(ret == UCI_OK)
+		_uci_commit(ctx, &ptr.p);
+	else
+		syslog(LOG_ERR, "uci_set_value: %s", uci_errstr[ret]);
+
+	free(opt);
+	return ret;
+}
+
+void uci_get_config_value(struct uci_context *ctx, struct config *conf)
+{
+	for(unsigned int i = 0; i < CONFIG_ELEMENTS; i++)
+	{
+		struct conf_item *cfg_item = get_conf_item(conf, i);
+		if(cfg_item == &config.dns.cnameRecords ||
+		   cfg_item == &config.dns.hosts ||
+		   cfg_item == &config.dhcp.hosts)
+			continue;
+
+		const char *sec = NULL;
+		char *opt = NULL;
+		set_uci_type_name(cfg_item, &sec, &opt);
+
+		uci_get_value(ctx, cfg_item, sec, opt);
+
+		free(opt);
+	}
+
+	uci_read_foreach_to_json(&config.dns.hosts, &custom_domain_attr_list, "domain");
+	uci_read_foreach_to_json(&config.dns.cnameRecords, &cname_attr_list, "cname");
+	uci_read_foreach_to_json(&config.dhcp.hosts, &static_hosts_attr_list, "host");
+
+	set_debug_flags(conf);
+}
+
+int uci_get_value(struct uci_context *ctx, struct conf_item *conf_item, const char *sec, const char *opt)
+{
+	struct uci_ptr ptr = {
+		.option = opt,
+	};
+
+	if(conf_item->f & FLAG_PKG_DHCP)
+		ptr.p = uci_dhcp;
+	else
+		ptr.p = uci_pihole;
+
+	struct uci_section *s = get_uci_section_type(ctx, ptr.p, sec);
+	if(!s) {
+		syslog(LOG_WARNING, "there is no section: %s, using default value for: %s", sec, opt);
+		return UCI_ERR_INVAL;
+	}
+
+	ptr.s = s;
+
+	if(uci_lookup_ptr(ctx, &ptr, NULL, true) != UCI_OK)
+		return UCI_ERR_PARSE;
+
+	if(!(ptr.flags & UCI_LOOKUP_COMPLETE))
+		return UCI_ERR_NOTFOUND;
+
+	if(conf_item->t == CONF_JSON_STRING_ARRAY && ptr.o->type == UCI_TYPE_LIST)
+	{
+		struct uci_element *e;
+		struct uci_list *list = &ptr.o->v.list;
+		cJSON_Delete(conf_item->v.json);
+		conf_item->v.json = cJSON_CreateArray();
+		uci_foreach_element(list, e)
+		{
+			if(!e->name)
+				continue;
+
+			cJSON *item = cJSON_CreateString(e->name);
+			cJSON_AddItemToArray(conf_item->v.json, item);
+		}
+	}
+	else if(ptr.o->type == UCI_TYPE_STRING && ptr.o->v.string &&
+		    conf_item->t != CONF_JSON_STRING_ARRAY)
+		return readStringValue(conf_item, ptr.o->v.string, &config) ? 0 : UCI_ERR_PARSE;
+
+	return 0;
+}
+
+const char *uci_get_string(struct uci_context *ctx, struct uci_package *pkg,
+						   const char *sec, const char *opt)
+{
+	if(!sec || !opt)
+		return NULL;
+
+	if(uci_init_ptr(ctx, pkg, sec, opt, NULL) != UCI_OK)
+		return NULL;
+
+	if(!(uci_ptr.flags & UCI_LOOKUP_COMPLETE))
+		return NULL;
+
+	if(uci_ptr.o->type == UCI_TYPE_STRING && uci_ptr.o->v.string)
+		return uci_ptr.o->v.string;
+	else if(uci_ptr.o->type == UCI_TYPE_LIST)
+	{
+		struct uci_element *e = NULL;
+		struct uci_list *list = &uci_ptr.o->v.list;
+		static char buffer[512];
+		unsigned pos = 0;
+
+		buffer[0] = 0;
+		uci_foreach_element(list, e)
+			if (e->name)
+				pos += snprintf(&buffer[pos], sizeof(buffer) - pos, "%s%s", e->name, ",");
+
+		if (pos)
+			buffer[pos - 1] = 0;
+
+		return buffer;
+	}
+
+	return NULL;
+}
+
+static void unload_packages(struct uci_context *ctx)
+{
+	uci_pihole = uci_lookup_package(ctx, "pihole");
+	if (uci_pihole)
+		uci_unload(ctx, uci_pihole);
+
+	uci_network = uci_lookup_package(ctx, "network");
+	if (uci_network)
+		uci_unload(ctx, uci_network);
+
+	uci_dhcp = uci_lookup_package(ctx, "dhcp");
+	if (uci_dhcp)
+		uci_unload(ctx, uci_dhcp);
+}
+
+bool uci_load_package(struct uci_context *ctx, bool reload)
+{
+	if(reload)
+		unload_packages(ctx);
+
+	int ret = uci_load(ctx, "dhcp", &uci_dhcp);
+	if(ret)
+		syslog(LOG_ERR, "failed to load dhcp config (%s)", uci_errstr[ret]);
+
+	ret = uci_load(ctx, "pihole", &uci_pihole);
+	if(ret)
+		syslog(LOG_ERR, "failed to load pihole config (%s)", uci_errstr[ret]);
+
+	ret = uci_load(ctx, "network", &uci_network);
+	if(ret)
+		syslog(LOG_ERR, "failed to load pihole config (%s)", uci_errstr[ret]);
+
+	return (ret == 0) ? true : false;
+}
+
+bool uci_init(void)
+{
+	if (uci_ctx == NULL) {
+		uci_ctx = uci_alloc_context();
+		if (!uci_ctx)
+			return false;
+	}
+
+	return uci_load_package(uci_ctx, false);
+}
+
+extern char *username;
+extern const char **argv_dnsmasq;
+void clean_all(void)
+{
+	// clean all "still reachable" that valgrind detects
+	// is this really needed ?
+	for(unsigned int i = 0; i < CONFIG_ELEMENTS; i++)
+	{
+		struct conf_item *copy_item = get_conf_item(&config, i);
+
+		if(copy_item->a != NULL)
+			cJSON_Delete(copy_item->a);
+
+		if(copy_item->p != NULL)
+		{
+			free_config_path(copy_item->p);
+			free(copy_item->p);
+		}
+
+		switch(copy_item->t)
+		{
+			case CONF_BOOL:
+			case CONF_INT:
+			case CONF_UINT:
+			case CONF_UINT16:
+			case CONF_LONG:
+			case CONF_ULONG:
+			case CONF_DOUBLE:
+			case CONF_STRING:
+			case CONF_PASSWORD:
+			case CONF_ENUM_PTR_TYPE:
+			case CONF_ENUM_BUSY_TYPE:
+			case CONF_ENUM_BLOCKING_MODE:
+			case CONF_ENUM_REFRESH_HOSTNAMES:
+			case CONF_ENUM_PRIVACY_LEVEL:
+			case CONF_ENUM_LISTENING_MODE:
+			case CONF_ENUM_WEB_THEME:
+			case CONF_ENUM_TEMP_UNIT:
+			case CONF_STRUCT_IN_ADDR:
+			case CONF_STRUCT_IN6_ADDR:
+			case CONF_ALL_DEBUG_BOOL:
+				break;
+			case CONF_STRING_ALLOCATED:
+				free(copy_item->v.s);
+				break;
+			case CONF_JSON_STRING_ARRAY:
+				cJSON_Delete(copy_item->d.json);
+				cJSON_Delete(copy_item->v.json);
+				break;
+		}
+	}
+
+	if(argv_dnsmasq != NULL)
+		free(argv_dnsmasq);
+
+	if(username != NULL)
+		free(username);
+}
+
+void uci_clean(struct uci_context *ctx)
+{
+	unload_packages(ctx);
+
+	if (ctx)
+		uci_free_context(ctx);
+
+	ctx = NULL;
+}
+
+struct uci_section * __attribute__((pure)) get_uci_section_type(struct uci_context *ctx, struct uci_package *pkg, const char *s)
+{
+	if(!pkg)
+		return NULL;
+
+	struct uci_element *e;
+	uci_foreach_element(&pkg->sections, e)
+	{
+		struct uci_section *section = uci_to_section(e);
+		if (strcmp(section->type, s) == 0)
+			return section;
+	}
+
+	return NULL;
+}
+
+// https://stackoverflow.com/questions/9210528/split-string-with-delimiters-in-c
+int split_comma(const char *txt, char delim, char ***ptr)
+{
+    int *tklen, *t, count = 1;
+    char **arr, *p = (char *)txt;
+
+    while (*p != '\0') {
+		if (*p++ == delim)
+			count += 1;
+    }
+
+    t = tklen = calloc(count, sizeof(int));
+
+    for (p = (char *)txt; *p != '\0'; p++)
+		*p == delim ? *t++ : (*t)++;
+
+    *ptr = arr = malloc(count * sizeof(char *));
+    t = tklen;
+    p = *arr++ = calloc(*(t++) + 1, sizeof(char *));
+
+    while (*txt != '\0')
+    {
+        if (*txt == delim)
+        {
+            p = *arr++ = calloc(*(t++) + 1, sizeof(char *));
+            txt++;
+        }
+        else
+			*p++ = *txt++;
+    }
+
+    free (tklen);
+    return count;
+}
--- a/src/config/config_uci.h	1970-01-01 07:00:00.000000000 +0700
+++ b/src/config/config_uci.h	2024-03-13 17:47:42.000000000 +0700
@@ -0,0 +1,27 @@
+#ifndef CONFIG_UCI_H
+#define CONFIG_UCI_H
+
+#include "config/config.h"
+
+extern struct uci_package *uci_dhcp;
+extern struct uci_package *uci_pihole;
+extern struct uci_package *uci_network;
+extern struct uci_context *uci_ctx;
+
+struct uci_section *get_uci_section_type(struct uci_context *ctx, struct uci_package *pkg, const char *s);
+const char *uci_get_string(struct uci_context *ctx, struct uci_package *pkg, const char *sec, const char *opt);
+int split_comma(const char *txt, char delim, char ***ptr);
+bool uci_load_package(struct uci_context *ctx, bool reload);
+int uci_config_set(struct uci_package *pkg, const char *sec,
+				   const char *opt, const char *val, const bool list);
+int uci_add_sec_foreach(struct uci_package *pkg, const char *key, const char *target);
+int uci_del_sec_foreach(struct uci_package *pkg, const char *target);
+int uci_set_value(struct uci_context *ctx, struct conf_item *item, const char *value);
+int uci_get_value(struct uci_context *ctx, struct conf_item *conf_item, const char *sec, const char *opt);
+bool uci_read_bool(struct uci_context *ctx, struct uci_package *pkg, const char *sec, const char *opt, bool fallback);
+void uci_get_config_value(struct uci_context *ctx, struct config *conf);
+bool uci_init(void);
+void uci_clean(struct uci_context *ctx);
+void clean_all(void);
+
+#endif // CONFIG_UCI_H
--- a/src/config/dnsmasq_config.c	2024-03-13 17:40:43.000000000 +0700
+++ b/src/config/dnsmasq_config.c	2024-03-13 17:43:40.000000000 +0700
@@ -19,6 +19,7 @@
 #include <sys/file.h>
 // struct config
 #include "config/config.h"
+#include "config/config_uci.h"
 // JSON array functions
 #ifdef SYSTEM_CJSON
 #include <cjson/cJSON.h>
@@ -35,6 +36,9 @@
 #include <unistd.h>
 // wait
 #include <sys/wait.h>
+#include <uci.h>
+ 
+extern const char *hostname(void);
 
 #define HEADER_WIDTH 80
 
@@ -212,12 +216,11 @@ static void write_config_header(FILE *fp
 	CONFIG_CENTER(fp, HEADER_WIDTH, "%s", "ANY CHANGES MADE TO THIS FILE WILL BE LOST WHEN THE CONFIGURATION CHANGES");
 	CONFIG_CENTER(fp, HEADER_WIDTH, "%s", "");
 	CONFIG_CENTER(fp, HEADER_WIDTH, "%s", "IF YOU WISH TO CHANGE ANY OF THESE VALUES, CHANGE THEM IN");
-	CONFIG_CENTER(fp, HEADER_WIDTH, "%s", "/etc/pihole/pihole.toml");
+	CONFIG_CENTER(fp, HEADER_WIDTH, "%s", "/etc/config/pihole or /etc/config/dhcp");
 	CONFIG_CENTER(fp, HEADER_WIDTH, "%s", "and restart pihole-FTL");
 	CONFIG_CENTER(fp, HEADER_WIDTH, "%s", "");
 	CONFIG_CENTER(fp, HEADER_WIDTH, "%s", "ANY OTHER CHANGES SHOULD BE MADE IN A SEPARATE CONFIG FILE");
 	CONFIG_CENTER(fp, HEADER_WIDTH, "%s", "WITHIN /tmp/dnsmasq.d/yourname.conf");
-	CONFIG_CENTER(fp, HEADER_WIDTH, "%s", "(make sure misc.etc_dnsmasq_d is set to true in /etc/pihole/pihole.toml)");
 	CONFIG_CENTER(fp, HEADER_WIDTH, "%s", "");
 	CONFIG_CENTER(fp, HEADER_WIDTH, "Last updated: %s", timestring);
 	CONFIG_CENTER(fp, HEADER_WIDTH, "by FTL version %s", FTL_VERSION);
@@ -225,75 +228,171 @@ static void write_config_header(FILE *fp
 	CONFIG_CENTER(fp, HEADER_WIDTH, "%s", "################################################################################");
 }
 
-bool __attribute__((const)) write_dnsmasq_config(struct config *conf, bool test_config, char errbuf[ERRBUF_SIZE])
+static int ipv4_mask_to_prfx(const char *prefix)
 {
-	// Early config checks
-	if(conf->dhcp.active.v.b)
-	{
-		// Check if the addresses are valid
-		// The addresses should neither be 0.0.0.0 nor 255.255.255.255
-		if((ntohl(conf->dhcp.start.v.in_addr.s_addr) == 0) ||
-		   (ntohl(conf->dhcp.start.v.in_addr.s_addr) == 0xFFFFFFFF))
-		{
-			strncpy(errbuf, "DHCP start address is not valid", ERRBUF_SIZE);
-			log_err("Unable to update dnsmasq configuration: %s", errbuf);
-			return false;
-		}
-		if((ntohl(conf->dhcp.end.v.in_addr.s_addr) == 0) ||
-		   (ntohl(conf->dhcp.end.v.in_addr.s_addr) == 0xFFFFFFFF))
-		{
-			strncpy(errbuf, "DHCP end address is not valid", ERRBUF_SIZE);
-			log_err("Unable to update dnsmasq configuration: %s", errbuf);
-			return false;
-		}
-		if((ntohl(conf->dhcp.router.v.in_addr.s_addr) == 0) ||
-		   (ntohl(conf->dhcp.router.v.in_addr.s_addr) == 0xFFFFFFFF))
-		{
-			strncpy(errbuf, "DHCP router address is not valid", ERRBUF_SIZE);
-			log_err("Unable to update dnsmasq configuration: %s", errbuf);
-			return false;
-		}
-		// The addresses should neither end in .0 or .255 in the last octet
-		if((ntohl(conf->dhcp.start.v.in_addr.s_addr) & 0xFF) == 0 ||
-		   (ntohl(conf->dhcp.start.v.in_addr.s_addr) & 0xFF) == 0xFF)
-		{
-			strncpy(errbuf, "DHCP start address is not valid", ERRBUF_SIZE);
-			log_err("Unable to update dnsmasq configuration: %s", errbuf);
-			return false;
-		}
-		if((ntohl(conf->dhcp.end.v.in_addr.s_addr) & 0xFF) == 0 ||
-		   (ntohl(conf->dhcp.end.v.in_addr.s_addr) & 0xFF) == 0xFF)
-		{
-			strncpy(errbuf, "DHCP end address is not valid", ERRBUF_SIZE);
-			log_err("Unable to update dnsmasq configuration: %s", errbuf);
-			return false;
-		}
-		if((ntohl(conf->dhcp.router.v.in_addr.s_addr) & 0xFF) == 0 ||
-		   (ntohl(conf->dhcp.router.v.in_addr.s_addr) & 0xFF) == 0xFF)
-		{
-			strncpy(errbuf, "DHCP router address is not valid", ERRBUF_SIZE);
-			log_err("Unable to update dnsmasq configuration: %s", errbuf);
-			return false;
-		}
+	struct in_addr in;
+	if (inet_pton(AF_INET, prefix, &in) == 0)
+		return -1;
 
-		// Check if the DHCP range is valid (start needs to be smaller than end)
-		if(ntohl(conf->dhcp.start.v.in_addr.s_addr) >= ntohl(conf->dhcp.end.v.in_addr.s_addr))
-		{
-			strncpy(errbuf, "DHCP range start address is larger than or equal to the end address", ERRBUF_SIZE);
-			log_err("Unable to update dnsmasq configuration: %s", errbuf);
-			return false;
+	int c = 0;
+	unsigned int seen_one = 0;
+	uint32_t i = ntohl(in.s_addr);
+
+	while (i > 0) {
+		if (i & 1) {
+			seen_one = 1;
+			c++;
+		} else {
+			if (seen_one) {
+				return -1;
+			}
 		}
+		i >>= 1;
+	}
+
+	return c;
+}
+
+static void write_config_dhcp(FILE *fp, struct uci_context *ctx)
+{
+	if(!config.dhcp.active.v.b)
+		return;
+
+	if(uci_read_bool(ctx, uci_dhcp, "@dnsmasq[0]", "quietdhcp", false))
+		fputs("quiet-dhcp\n", fp);
+
+	if(uci_read_bool(ctx, uci_dhcp, "@dnsmasq[0]", "fqdn", false))
+		fputs("dhcp-fqdn\n", fp);
+
+	if(uci_read_bool(ctx, uci_dhcp, "@dnsmasq[0]", "logdhcp", false))
+		fputs("log-dhcp\n", fp);
+
+	if(uci_read_bool(ctx, uci_dhcp, "@dnsmasq[0]", "sequential_ip", false))
+		fputs("dhcp-sequential-ip\n", fp);
 
-		// Check if the router address is within the DHCP range
-		if(ntohl(conf->dhcp.router.v.in_addr.s_addr) >= ntohl(conf->dhcp.start.v.in_addr.s_addr) &&
-		   ntohl(conf->dhcp.router.v.in_addr.s_addr) <= ntohl(conf->dhcp.end.v.in_addr.s_addr))
+	struct uci_element *ep;
+	uci_foreach_element(&uci_dhcp->sections, ep)
+	{
+		struct uci_section *s = uci_to_section(ep);
+		if (strcmp(s->type, "host") == 0)
+			continue;
+
+		if(strcmp(ep->name, "wan") == 0) {
+			const char *proto = uci_get_string(ctx, uci_network, "wan", "proto");
+			if(proto && strcmp(proto, "pppoe") == 0 && uci_read_bool(ctx, uci_dhcp, ep->name, "ignore", false))
+				fputs("no-dhcp-interface=pppoe-wan\n", fp);
+		}
+
+		bool skipped_dhcp = false;
+		int dhcp_start = 0, dhcp_limit = 0;
+		const char *iface = NULL;
+		const char *domain_iface = NULL;
+		const char *leasetime = NULL;
+		struct uci_element *eo;
+		uci_foreach_element(&s->options, eo)
 		{
-			strncpy(errbuf, "DHCP router address should not be within DHCP range", ERRBUF_SIZE);
-			log_err("Unable to update dnsmasq configuration: %s", errbuf);
-			return false;
+			struct uci_option* opt = uci_to_option(eo);
+			if(opt->type == UCI_TYPE_STRING && opt->v.string)
+			{
+				if (strcmp(s->type, "dhcp") == 0)
+				{
+					if(strcmp(opt->e.name, "ignore") == 0 && strcmp(opt->v.string, "1") == 0) {
+						skipped_dhcp = true;
+						break;
+					}
+
+					if(strcmp(opt->e.name, "interface") == 0)
+						iface = opt->v.string;
+					else if(strcmp(opt->e.name, "start") == 0)
+						dhcp_start = atoi(opt->v.string);
+					else if(strcmp(opt->e.name, "limit") == 0)
+						dhcp_limit = atoi(opt->v.string);
+					else if(strcmp(opt->e.name, "leasetime") == 0)
+						leasetime = opt->v.string;
+					else if(strcmp(opt->e.name, "domain_iface") == 0)
+						domain_iface = opt->v.string;
+				}
+				else if (strcmp(s->type, "dnsmasq") == 0)
+				{
+					if(strcmp(opt->e.name, "dhcpleasemax") == 0)
+						fprintf(fp, "dhcp-lease-max=%s\n", opt->v.string);
+					else if(strcmp(opt->e.name, "dhcp_boot") == 0)
+						fprintf(fp, "dhcp-boot=%s\n", opt->v.string);
+				}
+			}
+			else if(opt->type == UCI_TYPE_LIST)
+			{
+				const char *networkid = NULL;
+				const char *vendorclass = NULL;
+				if (strcmp(s->type, "vendorclass") == 0)
+				{
+					networkid = uci_lookup_option_string(ctx, s, "networkid");
+					vendorclass = uci_lookup_option_string(ctx, s, "vendorclass");
+					if(networkid && vendorclass)
+						fprintf(fp, "dhcp-vendorclass=set:%s,%s\n", networkid, vendorclass);
+				}
+
+				struct uci_element *el;
+				uci_foreach_element(&opt->v.list, el) {
+					if (!el->name)
+						continue;
+
+					if(strcmp(s->type, "vendorclass") == 0 && networkid && vendorclass)
+						fprintf(fp, "dhcp-option=%s,%s\n", networkid, el->name);
+
+					if(iface != NULL && strcmp(opt->e.name, "dhcp_option") == 0)
+						fprintf(fp, "dhcp-option=%s,%s\n", iface, el->name);
+				}
+			}
 		}
+
+		if(iface == NULL)
+			continue;
+
+		const char *ipaddr = uci_get_string(ctx, uci_network, iface, "ipaddr");
+		const char *netmask = uci_get_string(ctx, uci_network, iface, "netmask");
+		if(skipped_dhcp || !ipaddr || !netmask)
+			continue;
+
+		struct in_addr addr4, mask, net;
+		memset(&addr4, 0, sizeof(addr4));
+		if(!inet_pton(AF_INET, ipaddr, &addr4))
+			continue;
+
+		int prfx = ipv4_mask_to_prfx(netmask);
+		char ip_net[INET_ADDRSTRLEN] = { 0 },
+		     ip_start[INET_ADDRSTRLEN] = { 0 },
+		     ip_end[INET_ADDRSTRLEN] = { 0 };
+		mask.s_addr = htonl(~((1 << (32 - prfx)) - 1));
+		memset(&net, 0, sizeof(net));
+		net.s_addr = addr4.s_addr & mask.s_addr;
+
+		addr4.s_addr = htonl(ntohl(net.s_addr));
+		inet_ntop(AF_INET, &addr4.s_addr, ip_net, INET_ADDRSTRLEN);
+
+		addr4.s_addr = htonl(ntohl(net.s_addr) + dhcp_start);
+		inet_ntop(AF_INET, &addr4.s_addr, ip_start, INET_ADDRSTRLEN);
+
+		addr4.s_addr = htonl(ntohl(net.s_addr) + dhcp_start + dhcp_limit - 1);
+		inet_ntop(AF_INET, &addr4.s_addr, ip_end, INET_ADDRSTRLEN);
+
+		// dhcp-range=set:lan,192.168.0.10,192.168.0.19,255.255.255.0,24h
+		fprintf(fp, "dhcp-range=set:%s,%s,%s,%s,%s\n", iface, ip_start,
+				ip_end, netmask, leasetime);
+
+		fprintf(fp, "dhcp-option=%s,option:router,%s\n", iface, ipaddr);
+
+		// domain=lan,192.168.0.0/24,local
+		// domain=lan,192.168.0.1,192,168.0.50,local
+		// needs expandhosts in order to work without manually adding domain to host
+		if(config.dns.domainNeeded.v.b && domain_iface != NULL)
+			fprintf(fp, "domain=%s,%s/%i,local\n", domain_iface, ip_net, prfx);
 	}
+}
 
+bool __attribute__((const)) write_dnsmasq_config(struct uci_context *ctx,
+												 struct config *conf, bool test_config, char errbuf[ERRBUF_SIZE])
+{
 	log_debug(DEBUG_CONFIG, "Opening "DNSMASQ_TEMP_CONF" for writing");
 	FILE *pihole_conf = fopen(DNSMASQ_TEMP_CONF, "w");
 	// Return early if opening failed
@@ -364,7 +463,7 @@ bool __attribute__((const)) write_dnsmas
 		fputs("\n", pihole_conf);
 	}
 
-	if(strlen(conf->files.log.dnsmasq.v.s) > 0)
+	if(conf->files.log.dnsmasq.v.s != NULL && strlen(conf->files.log.dnsmasq.v.s) > 0)
 	{
 		fputs("# Specify the log file to use\n", pihole_conf);
 		fputs("# We set this even if logging is disabled to store warnings\n", pihole_conf);
@@ -423,10 +522,17 @@ bool __attribute__((const)) write_dnsmas
 		fputs("\n", pihole_conf);
 	}
 
-	const char *interface = conf->dns.interface.v.s;
-	// Use eth0 as fallback interface if the interface is missing
-	if(strlen(interface) == 0)
-		interface = "eth0";
+	fputs("\n", pihole_conf);
+ 
+	const char *interface = uci_get_string(ctx, uci_dhcp, "@dnsmasq[0]", "interface");
+	// Use br-lan as fallback interface if the interface is missing
+	if(interface == NULL)
+		interface = "br-lan";
+
+	// with split_comma approach instead of uci_foreach_element,
+	// we have a fallback interface in case there is no interface option
+	char **comma;
+	int count = split_comma(interface, ',', &comma);
 
 	switch(conf->dns.listeningMode.v.listeningMode)
 	{
@@ -441,12 +547,15 @@ bool __attribute__((const)) write_dnsmas
 			break;
 		case LISTEN_SINGLE:
 			fputs("# Listen on one interface\n", pihole_conf);
-			fprintf(pihole_conf, "interface=%s\n", interface);
+			fprintf(pihole_conf, "interface=%s\n", comma[0]);
 			break;
 		case LISTEN_BIND:
-			fputs("# Bind to one interface\n", pihole_conf);
-			fprintf(pihole_conf, "interface=%s\n", interface);
+			// interface is handled later
+			fputs("# Bind to interface(s)\n", pihole_conf);
 			fputs("bind-interfaces\n", pihole_conf);
+			for (int i = 0; i < count; i++)
+				fprintf(pihole_conf, "interface=%s\n", comma[i]);
+
 			break;
 		case LISTEN_NONE:
 			fputs("# No interface configuration applied, make sure to cover this yourself\n", pihole_conf);
@@ -454,6 +563,11 @@ bool __attribute__((const)) write_dnsmas
 	}
 	fputs("\n", pihole_conf);
 
+	// always freeing char pointer when using split_comma
+	for (int i = 0; i < count; i++)
+		free (comma[i]);
+	free (comma);
+
 	const unsigned int revServers = cJSON_GetArraySize(conf->dns.revServers.v.json);
 	for(unsigned int i = 0; i < revServers; i++)
 	{
@@ -506,13 +620,19 @@ bool __attribute__((const)) write_dnsmas
 	// ticked, we add `local=/domain/` to signal that this domain is purely
 	// local and FTL may answer queries from /etc/hosts or DHCP but should
 	// never forward queries on that domain to any upstream servers
-	if(conf->dns.domainNeeded.v.b)
+	const char *local_dom = uci_get_string(ctx, uci_dhcp, "@dnsmasq[0]", "local");
+	if(conf->dns.domainNeeded.v.b && (local_dom != NULL || strlen(conf->dns.domain.v.s) > 0))
 	{
 		fputs("# Never forward A or AAAA queries for plain names, without\n",pihole_conf);
 		fputs("# dots or domain parts, to upstream nameservers. If the name\n", pihole_conf);
 		fputs("# is not known from /etc/hosts or DHCP a NXDOMAIN is returned\n", pihole_conf);
-		if(strlen(conf->dns.domain.v.s))
+		if(strlen(conf->dns.domain.v.s)) {
+			if(local_dom != NULL) {
+				fprintf(pihole_conf, "local=%s\n", local_dom);
+			} else {
 			fprintf(pihole_conf, "local=/%s/\n\n", conf->dns.domain.v.s);
+			}
+		}
 		else
 			fputs("\n", pihole_conf);
 	}
@@ -525,30 +645,169 @@ bool __attribute__((const)) write_dnsmas
 		fprintf(pihole_conf, "domain=%s\n\n", conf->dns.domain.v.s);
 	}
 
+	bool rebind_protection = uci_read_bool(ctx,  uci_dhcp, "@dnsmasq[0]", "rebind_protection", true);
+	if(rebind_protection)
+	{
+		fputs("# Discard upstream RFC1918 responses!\n", pihole_conf);
+		fputs("stop-dns-rebind\n", pihole_conf);
+		fputs("\n", pihole_conf);
+		if(uci_read_bool(ctx,  uci_dhcp, "@dnsmasq[0]", "rebind_localhost", false))
+		{
+			fputs("# Allowing 127.0.0.0/8 responses\n", pihole_conf);
+			fputs("rebind-localhost-ok\n", pihole_conf);
+		}
+	}
+	fputs("\n", pihole_conf);
+
+	if(!conf->dns.dnssec.v.b)
+	{
+		if(uci_read_bool(ctx,  uci_dhcp, "@dnsmasq[0]", "proxydnssec", false)) {
+			fputs("proxy-dnssec\n", pihole_conf);
+			const char *cpe_id = uci_get_string(ctx, uci_dhcp, "@dnsmasq[0]", "proto");
+			if(cpe_id != NULL)
+				fprintf(pihole_conf, "add-cpe-id=%s\n", cpe_id);
+		}
+	}
+
+	if(uci_read_bool(ctx,  uci_dhcp, "@dnsmasq[0]", "ubus", true))
+		fputs("enable-ubus\n", pihole_conf);
+
+	if(uci_read_bool(ctx,  uci_dhcp, "@dnsmasq[0]", "nonwildcard", true))
+		fputs("bind-dynamic\n", pihole_conf);
+
+	if(uci_read_bool(ctx,  uci_dhcp, "@dnsmasq[0]", "tftp_no_fail", false))
+		fputs("tftp-no-fail\n", pihole_conf);
+
+	if(uci_read_bool(ctx,  uci_dhcp, "@dnsmasq[0]", "noresolv", false))
+		fputs("no-resolv\n", pihole_conf);
+
+	if(uci_read_bool(ctx,  uci_dhcp, "@dnsmasq[0]", "no_id", false))
+		fputs("no-ident\n", pihole_conf);
+
+	if(uci_read_bool(ctx,  uci_dhcp, "@dnsmasq[0]", "filterwin2k", false))
+		fputs("filterwin2k\n", pihole_conf);
+
+	if(uci_read_bool(ctx,  uci_dhcp, "@dnsmasq[0]", "nohosts", false))
+		fputs("no-hosts\n", pihole_conf);
+
+	if(uci_read_bool(ctx,  uci_dhcp, "@dnsmasq[0]", "strictorder", false))
+		fputs("strict-order\n", pihole_conf);
+
+	if(uci_read_bool(ctx,  uci_dhcp, "@dnsmasq[0]", "readethers", false))
+		fputs("read-ethers\n", pihole_conf);
+
+	if(uci_read_bool(ctx,  uci_dhcp, "@dnsmasq[0]", "dbus", false))
+		fputs("enable-dbus\n", pihole_conf);
+
+	if(uci_read_bool(ctx,  uci_dhcp, "@dnsmasq[0]", "tftp_no_fail", false))
+		fputs("tftp-no-fail\n", pihole_conf);
+
+	if(uci_read_bool(ctx,  uci_dhcp, "@dnsmasq[0]", "allservers", false))
+		fputs("all-servers\n", pihole_conf);
+
+	if(uci_read_bool(ctx,  uci_dhcp, "@dnsmasq[0]", "noping", false))
+		fputs("no-ping\n", pihole_conf);
+
+	if(uci_read_bool(ctx,  uci_dhcp, "@dnsmasq[0]", "filter_a", false))
+		fputs("filter-A\n", pihole_conf);
+
+	if(uci_read_bool(ctx,  uci_dhcp, "@dnsmasq[0]", "filter_aaaa", false))
+		fputs("filter-AAAA\n", pihole_conf);
+
+	if(uci_read_bool(ctx,  uci_dhcp, "@dnsmasq[0]", "scriptarp", false))
+		fputs("script-arp\n", pihole_conf);
+
+	if(!uci_read_bool(ctx,  uci_dhcp, "@dnsmasq[0]", "scriptarp", false))
+		fputs("dnssec-check-unsigned=no\n", pihole_conf);
+
+	// since FTL doesn't support multiple instances
+	// find the first dnsmasq section in dhcp config
+	struct uci_section *s = get_uci_section_type(ctx, uci_dhcp, "dnsmasq");
+	struct uci_element *elem;
+	uci_foreach_element(&s->options, elem)
+	{
+		struct uci_option* opt = uci_to_option(elem);
+		if(opt->type == UCI_TYPE_STRING && opt->v.string)
+		{
+			if(strcmp(opt->e.name, "tftp_root") == 0)
+			{
+				fprintf(pihole_conf, "tftp-root=%s\n", opt->v.string);
+				if(uci_read_bool(ctx,  uci_dhcp, "@dnsmasq[0]", "enable_tftp", false))
+					fputs("enable-tftp\n", pihole_conf);
+			}
+			else if(strcmp(opt->e.name, "tftp_unique_root") == 0) 
+				fprintf(pihole_conf, "ftp-unique-root=%s\n", opt->v.string);
+			else if(strcmp(opt->e.name, "ednspacket_max") == 0) 
+				fprintf(pihole_conf, "edns-packet-max=%s\n", opt->v.string);
+			else if(strcmp(opt->e.name, "dnsforwardmax") == 0)
+				fprintf(pihole_conf, "dns-forward-max=%s\n", opt->v.string);
+			else if(strcmp(opt->e.name, "queryport") == 0)
+				fprintf(pihole_conf, "query-port=%s\n", opt->v.string);
+			else if(strcmp(opt->e.name, "minport") == 0)
+				fprintf(pihole_conf, "min-port=%s\n", opt->v.string);
+			else if(strcmp(opt->e.name, "maxport") == 0)
+				fprintf(pihole_conf, "max-port=%s\n", opt->v.string);
+			else if(strcmp(opt->e.name, "local_ttl") == 0)
+				fprintf(pihole_conf, "local-ttl=%s\n", opt->v.string);
+			else if(strcmp(opt->e.name, "max_ttl") == 0)
+				fprintf(pihole_conf, "max-ttl=%s\n", opt->v.string);
+			else if(strcmp(opt->e.name, "min_cache_ttl") == 0)
+				fprintf(pihole_conf, "min-cache-ttl=%s\n", opt->v.string);
+			else if(strcmp(opt->e.name, "max_cache_ttl") == 0)
+				fprintf(pihole_conf, "max-cache-ttl=%s\n", opt->v.string);
+			else if(strcmp(opt->e.name, "serversfile") == 0)
+				fprintf(pihole_conf, "servers-file=%s\n", opt->v.string);
+		}
+		else if(opt->type == UCI_TYPE_LIST)
+		{
+			struct uci_element *el;
+			uci_foreach_element(&opt->v.list, el)
+			{
+				if (!el->name)
+					continue;
+
+				if(rebind_protection && strcmp(opt->e.name, "rebind_domain") == 0)
+					fprintf(pihole_conf, "rebind-domain-ok=%s\n", el->name);
+				else if(strcmp(opt->e.name, "notinterface") == 0)
+					fprintf(pihole_conf, "except-interface=%s\n", el->name);
+				else if(strcmp(opt->e.name, "addnhosts") == 0)
+					fprintf(pihole_conf, "addn-hosts=%s\n", el->name);
+				else if(strcmp(opt->e.name, "bogusnxdomain") == 0)
+					fprintf(pihole_conf, "bogus-nxdomain=%s\n", el->name);
+#if 0
+				else if(strcmp(opt->e.name, "interface") == 0)
+				{
+					if(conf->dns.listeningMode.v.listeningMode == LISTEN_BIND)
+						fprintf(pihole_conf, "interface=%s\n", el->name);
+					else if(conf->dns.listeningMode.v.listeningMode == LISTEN_SINGLE)
+					{
+						fputs("# Listen on one interface\n", pihole_conf);
+						fprintf(pihole_conf, "interface=%s\n", el->name);
+						continue;
+					}
+				}
+#endif
+			}
+		}
+	}
+
+	const char *filter_rr = uci_get_string(ctx, uci_dhcp, "@dnsmasq[0]", "filter_rr");
+	if(filter_rr != NULL)
+		fprintf(pihole_conf, "filter-rr=%s\n", filter_rr);
+
+	fputs("\n", pihole_conf);
+
 	if(conf->dhcp.active.v.b)
 	{
 		fputs("# DHCP server setting\n", pihole_conf);
 		fputs("dhcp-authoritative\n", pihole_conf);
-		fputs("dhcp-leasefile="DHCPLEASESFILE"\n", pihole_conf);
-		char start[INET_ADDRSTRLEN] = { 0 },
-		     end[INET_ADDRSTRLEN] = { 0 },
-		     router[INET_ADDRSTRLEN] = { 0 };
-		inet_ntop(AF_INET, &conf->dhcp.start.v.in_addr, start, INET_ADDRSTRLEN);
-		inet_ntop(AF_INET, &conf->dhcp.end.v.in_addr, end, INET_ADDRSTRLEN);
-		inet_ntop(AF_INET, &conf->dhcp.router.v.in_addr, router, INET_ADDRSTRLEN);
-		fprintf(pihole_conf, "dhcp-range=%s,%s", start, end);
-		// Net mask is optional, only add if it is not 0.0.0.0
-		const struct in_addr inaddr_empty = {0};
-		if(memcmp(&conf->dhcp.netmask.v.in_addr, &inaddr_empty, sizeof(inaddr_empty)) != 0)
-		{
-			char netmask[INET_ADDRSTRLEN] = { 0 };
-			inet_ntop(AF_INET, &conf->dhcp.netmask.v.in_addr, netmask, INET_ADDRSTRLEN);
-			fprintf(pihole_conf, ",%s", netmask);
-		}
-		// Lease time is optional, only add it if it is set
-		if(strlen(conf->dhcp.leaseTime.v.s) > 0)
-			fprintf(pihole_conf, ",%s", conf->dhcp.leaseTime.v.s);
-		fprintf(pihole_conf, "\ndhcp-option=option:router,%s\n", router);
+		fputs("dhcp-broadcast=tag:needs-broadcast\n", pihole_conf);
+		fprintf(pihole_conf, "dhcp-leasefile=%s\n", config.dhcp.leaseFile.v.s);
+		fputs("dhcp-ignore-names=tag:dhcp_bogus_hostname\n", pihole_conf);
+		fputs("dhcp-name-match=set:dhcp_bogus_hostname,localhost\n", pihole_conf);
+		fputs("dhcp-name-match=set:dhcp_bogus_hostname,wpad\n", pihole_conf);
+
+		write_config_dhcp(pihole_conf, ctx);
 
 		if(conf->dhcp.rapidCommit.v.b)
 			fputs("dhcp-rapid-commit\n", pihole_conf);
@@ -568,16 +827,6 @@ bool __attribute__((const)) write_dnsmas
 			fputs("dhcp-option=option:dns-server,0.0.0.0,0.0.0.0,0.0.0.0\n", pihole_conf);
 		}
 
-		if(conf->dhcp.ipv6.v.b)
-		{
-			// Add dns-server option only if not already done above (dhcp.multiDNS)
-			if(conf->dhcp.multiDNS.v.b)
-				fputs("dhcp-option=option6:dns-server,[::],[::],[fd00::],[fd00::],[fe80::],[fe80::]\n", pihole_conf);
-			else
-				fputs("dhcp-option=option6:dns-server,[::]\n", pihole_conf);
-			fputs("# Enable IPv6 DHCP variant\n", pihole_conf);
-			fprintf(pihole_conf, "dhcp-range=::,constructor:%s,ra-names,ra-stateless,64\n", interface);
-		}
 		fputs("\n", pihole_conf);
 		if(cJSON_GetArraySize(conf->dhcp.hosts.v.json) > 0)
 		{
@@ -633,7 +882,7 @@ bool __attribute__((const)) write_dnsmas
 	fputs("server=/onion/\n", pihole_conf);
 	fputs("\n", pihole_conf);
 
-	if(directory_exists("/tmp/dnsmasq.d") && conf->misc.etc_dnsmasq_d.v.b)
+	if(directory_exists("/tmp/dnsmasq.d"))
 	{
 		// Load additional user scripts from /tmp/dnsmasq.d if the
 		// directory exists (it may not, e.g., in a container)
@@ -643,9 +892,11 @@ bool __attribute__((const)) write_dnsmas
 	}
 
 	// Add option for caching all DNS records
+	if(conf->dns.cache.size.v.ui > 0) {
 	fputs("# Cache all DNS records\n", pihole_conf);
 	fputs("cache-rr=ANY\n", pihole_conf);
 	fputs("\n", pihole_conf);
+	}
 
 	// Add option for PCAP file recording
 	if(strlen(conf->files.pcap.v.s) > 0)
@@ -752,6 +1003,85 @@ bool __attribute__((const)) write_dnsmas
 	return true;
 }
 
+bool write_hosts_file(void)
+{
+	const char *host_file = "/tmp/hosts/host_static";
+	FILE *hostfile = fopen(host_file, "w");
+	if(!hostfile)
+	{
+		log_err("Cannot open %s for writing, unable to update host_static: %s", host_file, strerror(errno));
+		return false;
+	}
+
+	if(flock(fileno(hostfile), LOCK_EX) != 0)
+	{
+		log_err("Cannot open %s in exclusive mode: %s", host_file, strerror(errno));
+		fclose(hostfile);
+		return false;
+	}
+
+	write_config_header(hostfile, "Static DHCP (HOSTS file)");
+	fputc('\n', hostfile);
+
+	int i = 0;
+	struct uci_element *e;
+	uci_foreach_element(&uci_dhcp->sections, e)
+	{
+		struct uci_section *s = uci_to_section(e);
+		if (strcmp(s->type, "host") != 0)
+			continue;
+
+		const char *ip = uci_lookup_option_string(uci_ctx, s, "ip");
+		const char *name = uci_lookup_option_string(uci_ctx, s, "name");
+		if(name != NULL && ip != NULL)
+		{
+			fprintf(hostfile, "%s %s\n", ip, name);
+			i++;
+		}
+	}
+
+	e = NULL;
+	uci_foreach_element(&uci_network->sections, e)
+	{
+		struct uci_section *s = uci_to_section(e);
+		if (strcmp(s->type, "interface") != 0)
+			continue;
+
+		const char *proto = uci_lookup_option_string(uci_ctx, s, "proto");
+		if(!proto || strcmp(proto, "static") != 0)
+			continue;
+
+		const char *ipaddr = uci_lookup_option_string(uci_ctx, s, "ipaddr");
+		const char *domain_iface = uci_get_string(uci_ctx, uci_dhcp, e->name, "domain_iface");
+
+		if(ipaddr != NULL && strcmp(ipaddr, "127.0.0.1") != 0)
+		{
+			if(domain_iface != NULL)
+				fprintf(hostfile, "%s %s.%s\n", ipaddr, hostname(), domain_iface);
+			else
+				fprintf(hostfile, "%s %s\n", hostname(), ipaddr);
+
+			i++;
+		}
+	}
+
+	fprintf(hostfile, "\n# %d entrie(s) in this file\n", i);
+
+	if(flock(fileno(hostfile), LOCK_UN) != 0)
+	{
+		log_err("Cannot release lock on host_static: %s", strerror(errno));
+		fclose(hostfile);
+		return false;
+	}
+
+	if(fclose(hostfile) != 0)
+	{
+		log_err("Cannot close host_static: %s", strerror(errno));
+		return false;
+	}
+	return true;
+}
+
 bool read_legacy_dhcp_static_config(void)
 {
 	// Check if file exists, if not, there is nothing to do
@@ -954,19 +1284,19 @@ bool write_custom_list(void)
 		}
 	}
 
-	log_debug(DEBUG_CONFIG, "Opening "DNSMASQ_CUSTOM_LIST_LEGACY".tmp for writing");
-	FILE *custom_list = fopen(DNSMASQ_CUSTOM_LIST_LEGACY".tmp", "w");
+	log_debug(DEBUG_CONFIG, "Opening "DNSMASQ_CUSTOM_LIST" for writing");
+	FILE *custom_list = fopen(DNSMASQ_CUSTOM_LIST"", "w");
 	// Return early if opening failed
 	if(!custom_list)
 	{
-		log_err("Cannot open "DNSMASQ_CUSTOM_LIST_LEGACY".tmp for writing, unable to update custom.list: %s", strerror(errno));
+		log_err("Cannot open "DNSMASQ_CUSTOM_LIST" for writing, unable to update custom.list: %s", strerror(errno));
 		return false;
 	}
 
 	// Lock file, may block if the file is currently opened
 	if(flock(fileno(custom_list), LOCK_EX) != 0)
 	{
-		log_err("Cannot open "DNSMASQ_CUSTOM_LIST_LEGACY".tmp in exclusive mode: %s", strerror(errno));
+		log_err("Cannot open "DNSMASQ_CUSTOM_LIST" in exclusive mode: %s", strerror(errno));
 		fclose(custom_list);
 		return false;
 	}
--- a/src/config/dnsmasq_config.h	2024-03-13 17:40:43.000000000 +0700
+++ b/src/config/dnsmasq_config.h	2024-03-13 17:40:48.000000000 +0700
@@ -14,21 +14,20 @@
 
 #define ERRBUF_SIZE 1024
 
-bool write_dnsmasq_config(struct config *conf, bool test_config, char errbuf[ERRBUF_SIZE]);
+bool write_dnsmasq_config(struct uci_context *ctx, struct config *conf, bool test_config, char errbuf[ERRBUF_SIZE]);
 int get_lineno_from_string(const char *string);
 char *get_dnsmasq_line(const unsigned int lineno);
 bool read_legacy_dhcp_static_config(void);
 bool read_legacy_cnames_config(void);
 bool read_legacy_custom_hosts_config(void);
 bool write_custom_list(void);
+bool write_hosts_file(void);
 
-#define DNSMASQ_PH_CONFIG "/etc/pihole/dnsmasq.conf"
-#define DNSMASQ_TEMP_CONF "/etc/pihole/dnsmasq.conf.temp"
+#define DNSMASQ_PH_CONFIG "/tmp/etc/dnsmasq.conf"
+#define DNSMASQ_TEMP_CONF "/tmp/etc/dnsmasq.conf.temp"
 #define DNSMASQ_STATIC_LEASES "/etc/pihole/04-pihole-static-dhcp.conf"
 #define DNSMASQ_CNAMES "/etc/pihole/05-pihole-custom-cname.conf"
-#define DNSMASQ_HOSTSDIR "/etc/pihole/hosts"
-#define DNSMASQ_CUSTOM_LIST DNSMASQ_HOSTSDIR"/custom.list"
-#define DNSMASQ_CUSTOM_LIST_LEGACY "/etc/pihole/custom.list"
-#define DHCPLEASESFILE "/etc/pihole/dhcp.leases"
+#define DNSMASQ_HOSTSDIR "/tmp/hosts"
+#define DNSMASQ_CUSTOM_LIST DNSMASQ_HOSTSDIR"/host_custom"
 
 #endif //DNSMASQ_CONFIG_H
--- a/src/config/inotify.c	2024-03-13 17:40:43.000000000 +0700
+++ b/src/config/inotify.c	2024-03-13 17:40:48.000000000 +0700
@@ -14,7 +14,7 @@
 // NAME_MAX
 #include <limits.h>
 
-#define WATCHDIR "/etc/pihole"
+#define WATCHDIR "/etc/config"
 
 static int inotify_fd = -1;
 static int inotify_wd = -1;
@@ -108,7 +108,7 @@ bool check_inotify_event(void)
 		{
 			// File opened for writing was closed
 			log_debug(DEBUG_INOTIFY, "File written: "WATCHDIR"/%s", event->name);
-			if(strcmp(event->name, "pihole.toml") == 0)
+			if(strcmp(event->name, "pihole") == 0 || strcmp(event->name, "dhcp") == 0)
 				config_changed = true;
 		}
 		else if(event->mask & IN_CREATE)
@@ -125,7 +125,7 @@ bool check_inotify_event(void)
 		{
 			// File was moved (target)
 			log_debug(DEBUG_INOTIFY, "File moved to: "WATCHDIR"/%s", event->name);
-			if(strcmp(event->name, "pihole.toml") == 0)
+			if(strcmp(event->name, "pihole") == 0)
 				config_changed = true;
 		}
 		else if(event->mask & IN_DELETE)
--- a/src/config/toml_reader.c	2024-03-13 17:40:43.000000000 +0700
+++ b/src/config/toml_reader.c	2024-03-13 17:40:48.000000000 +0700
@@ -28,7 +28,6 @@
 
 // Private prototypes
 static toml_table_t *parseTOML(const unsigned int version);
-static void reportDebugFlags(void);
 
 // Migrate dns.revServer -> dns.revServers[0]
 static bool migrate_dns_revServer(toml_table_t *toml, struct config *newconf)
@@ -266,7 +265,7 @@ bool getLogFilePathTOML(void)
 	return true;
 }
 
-static void reportDebugFlags(void)
+void reportDebugFlags(void)
 {
 	// Print debug settings
 	log_debug(DEBUG_ANY, "************************");
--- a/src/config/toml_reader.h	2024-03-13 17:40:43.000000000 +0700
+++ b/src/config/toml_reader.h	2024-03-13 17:40:48.000000000 +0700
@@ -17,5 +17,6 @@ bool readFTLtoml(struct config *oldconf,
                  toml_table_t *toml, const bool verbose, bool *restart,
                  const unsigned int version);
 bool getLogFilePathTOML(void);
+void reportDebugFlags(void);
 
 #endif //TOML_READER_H
--- a/src/daemon.c	2024-03-13 17:40:43.000000000 +0700
+++ b/src/daemon.c	2024-03-13 17:41:55.000000000 +0700
@@ -11,6 +11,7 @@
 #include "FTL.h"
 #include "daemon.h"
 #include "config/config.h"
+#include "config/config_uci.h"
 #include "log.h"
 // sleepms()
 #include "timers.h"
@@ -378,6 +379,9 @@ void cleanup(const int ret)
 	char buffer[42] = { 0 };
 	format_time(buffer, 0, timer_elapsed_msec(EXIT_TIMER));
 	log_info("########## FTL terminated after%s (code %i)! ##########", buffer, ret);
+
+	uci_clean(uci_ctx);
+	clean_all();
 }
 
 static float last_clock = 0.0f;
@@ -428,54 +432,6 @@ ssize_t getrandom_fallback(void *buf, si
 	return buflen;
 }
 
-bool ipv6_enabled(void)
-{
-	// First we check a few virtual system files to see if IPv6 is disabled
-	const char *files[] = {
-		"/sys/module/ipv6/parameters/disable", // GRUB - ipv6.disable=1
-		"/proc/sys/net/ipv6/conf/all/disable_ipv6", // sysctl.conf - net.ipv6.conf.all.disable_ipv6=1
-		"/proc/sys/net/ipv6/conf/default/disable_ipv6", // sysctl.conf - net.ipv6.conf.all.disable_ipv6=1
-		NULL
-	};
-
-	// Loop over the files
-	for(int i = 0; files[i] != NULL; i++)
-	{
-		// Open file for reading
-		FILE *f = fopen(files[i], "r");
-		if(f == NULL)
-			continue;
-
-		// Read first character
-		const int c = fgetc(f);
-		fclose(f);
-		// If the first character is a 1, then IPv6 is disabled
-		if(c == '1')
-			return false;
-	}
-
-	// If the file does not exist or if it does not contain a 1, then we check
-	// if /proc/net/if_inet6 has any IPv6-capable interfaces
-	// Since Linux 2.6.25 (April 2008), files in /proc/net are a symlink to
-	// /proc/self/net and provide information about the network devices and
-	// interfaces for the network namespace of which the process is a member
-	FILE *f = fopen("/proc/net/if_inet6", "r");
-
-	if(f != NULL)
-	{
-		// If the file exists, we check if it is empty
-		const int c = fgetc(f);
-		fclose(f);
-		// If the file is empty, then there are no IPv6-capable interfaces
-		if(c == EOF)
-			return false;
-	}
-
-	// else: IPv6 is not obviously disabled and there is at least one
-	// IPv6-capable interface
-	return true;
-}
-
 void init_locale(void)
 {
 	// Set locale to system default, needed for libidn to work properly
--- a/src/daemon.h	2024-03-13 17:40:43.000000000 +0700
+++ b/src/daemon.h	2024-03-13 17:40:48.000000000 +0700
@@ -24,7 +24,6 @@ void cleanup(const int ret);
 void set_nice(void);
 void calc_cpu_usage(const unsigned int interval);
 float get_cpu_percentage(void) __attribute__((pure));
-bool ipv6_enabled(void);
 void init_locale(void);
 
 #include <sys/syscall.h>
--- a/src/dnsmasq_interface.c	2024-03-13 17:47:14.000000000 +0700
+++ b/src/dnsmasq_interface.c	2024-03-13 17:49:34.000000000 +0700
@@ -636,6 +636,18 @@ bool _FTL_new_query(const unsigned int f
 		strcpy(clientIP, "::");
 	}
 
+#if 0	// Skip filter-rr queries
+	if(!config.dns.analyzeOnlyAandAAAA.v.b && rr_on_list(daemon->filter_rr, qtype))
+	{
+		if(config.debug.queries.v.b)
+		{
+			const char *types = querystr(arg, qtype);
+			log_debug(DEBUG_QUERIES, "Not analyzing filter-rr: %s (%i)", types, id);
+		}
+		free(domainString);
+		return false;
+	}
+#endif
 	// Check if user wants to skip queries coming from localhost
 	if(config.dns.ignoreLocalhost.v.b &&
 	   (strcmp(clientIP, "127.0.0.1") == 0 || strcmp(clientIP, "::1") == 0))
--- a/src/log.c	2024-03-13 17:40:43.000000000 +0700
+++ b/src/log.c	2024-03-13 17:41:48.000000000 +0700
@@ -13,6 +13,7 @@
 // is_fork()
 #include "daemon.h"
 #include "config/config.h"
+#include "config/config_uci.h"
 #include "log.h"
 // global variable username
 #include "main.h"
@@ -47,6 +48,9 @@ void log_ctrl(bool plog, bool pstdout)
 
 void init_FTL_log(const char *name)
 {
+	// reread logfile location
+	uci_get_value(uci_ctx, &config.files.log.ftl, "pihole", "logfile");
+
 	// Open the log file in append/create mode
 	if(config.files.log.ftl.v.s != NULL)
 	{
--- a/src/main.c	2024-03-13 17:40:43.000000000 +0700
+++ b/src/main.c	2024-03-13 17:42:49.000000000 +0700
@@ -14,6 +14,7 @@
 #include "config/setupVars.h"
 #include "args.h"
 #include "config/config.h"
+#include "config/config_uci.h"
 #include "main.h"
 // exit_code
 #include "signals.h"
@@ -59,6 +60,14 @@ int main (int argc, char *argv[])
 	// to have arg{c,v}_dnsmasq initialized
 	parse_args(argc, argv);
 
+	// Check if there is already a running FTL process
+	if(check_running_FTL())
+		return EXIT_FAILURE;
+
+	// Initialize uci
+	if(!uci_init())
+		return EXIT_FAILURE;
+
 	// Initialize FTL log
 	init_FTL_log(argc > 0 ? argv[0] : NULL);
 	// Try to open FTL log
@@ -74,7 +83,7 @@ int main (int argc, char *argv[])
 	// Process pihole.toml configuration file
 	// The file is rewritten after parsing to ensure that all
 	// settings are present and have a valid value
-	if(readFTLconf(&config, true))
+	if(readFTLconf(&config, true, uci_ctx))
 		log_info("Parsed config file "GLOBALTOMLPATH" successfully");
 
 	// Set process priority
@@ -84,8 +93,7 @@ int main (int argc, char *argv[])
 	if(!init_shmem())
 	{
 		log_crit("Initialization of shared memory failed.");
-		// Check if there is already a running FTL process
-		check_running_FTL();
+		uci_clean(uci_ctx);
 		return EXIT_FAILURE;
 	}
 
--- a/src/procps.c	2024-03-13 17:40:43.000000000 +0700
+++ b/src/procps.c	2024-03-13 17:40:48.000000000 +0700
@@ -214,7 +214,7 @@ bool check_running_FTL(void)
 		log_debug(DEBUG_SHMEM, "PID: %d -> name: %s%s", pid, name, pid == ourselves ? " (us)" : "");
 
 		// Skip our own process
-		if(pid == ourselves)
+		if(pid == ourselves || pid - ourselves == 1)
 			continue;
 
 		// Only process this is this is our own process
--- a/src/regex.c	2024-03-13 17:40:43.000000000 +0700
+++ b/src/regex.c	2024-03-13 17:42:44.000000000 +0700
@@ -23,6 +23,7 @@
 #include "shmem.h"
 // readFTLconf()
 #include "config/config.h"
+#include "config/config_uci.h"
 // cli_stuff()
 #include "args.h"
 
@@ -855,7 +856,7 @@ int regex_test(const bool debug_mode, co
 
 	// Process pihole-FTL.conf to get gravity.db path
 	// Do not overwrite the file after reading it
-	readFTLconf(&config, false);
+	readFTLconf(&config, false, uci_ctx);
 
 	// Disable all debugging output if not explicitly in debug mode (CLI argument "d")
 	if(!debug_mode)
--- a/src/tools/dhcp-discover.c	2024-03-13 17:40:43.000000000 +0700
+++ b/src/tools/dhcp-discover.c	2024-03-13 17:43:34.000000000 +0700
@@ -17,6 +17,7 @@
 #include "log.h"
 // readFTLconf()
 #include "config/config.h"
+#include "config/config_uci.h"
 // cli_bold(), etc.
 #include "args.h"
 // check_capability()
@@ -715,7 +716,7 @@ int run_dhcp_discover(void)
 	// Disable terminal output during config config file parsing
 	log_ctrl(false, false);
 	// Process pihole-FTL.conf to get gravity.db
-	readFTLconf(&config, false);
+	readFTLconf(&config, false, uci_ctx);
 	// Only print to terminal, disable log file
 	log_ctrl(false, true);
 
--- a/src/zip/teleporter.c	2024-03-13 17:40:43.000000000 +0700
+++ b/src/zip/teleporter.c	2024-03-13 17:40:48.000000000 +0700
@@ -320,7 +320,7 @@ static const char *test_and_import_pihol
 
 	// Test dnsmasq config in the imported configuration
 	// The dnsmasq configuration will be overwritten if the test succeeds
-	if(!write_dnsmasq_config(&teleporter_config, true, hint))
+	if(!write_dnsmasq_config(uci_ctx, &teleporter_config, true, hint))
 		return "File etc/pihole/pihole.toml in ZIP archive contains invalid dnsmasq configuration";
 
 	// When we reach this point, we know that the file is a valid TOML file and contains
@@ -351,7 +351,7 @@ static const char *import_dhcp_leases(vo
 	rotate_files(DHCPLEASESFILE, NULL);
 
 	// Write new dhcp.leases file to disk
-	FILE *fp = fopen(DHCPLEASESFILE, "w");
+	FILE *fp = fopen(config.dhcp.leaseFile.v.s, "w");
 	if(fp == NULL)
 	{
 		strncpy(hint, strerror(errno), ERRBUF_SIZE);
