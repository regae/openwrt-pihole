--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -121,6 +121,8 @@ set(sources
         capabilities.h
         config.c
         config.h
+        config_uci.c
+        config_uci.h
         daemon.c
         daemon.h
         datastructure.c
@@ -228,6 +230,12 @@ endif()
 
 target_link_libraries(pihole-FTL ${LIBNETTLE} ${LIBHOGWEED} ${LIBGMP} ${LIBUBOX} ${LIBUBUS})
 
+find_library(LIBUCI uci)
+if(NOT LIBUCI)
+    message(FATAL_ERROR "libuci not found")
+endif()
+target_link_libraries(pihole-FTL ${LIBUCI})
+
 if(NFT_SUPPORT)
     find_library(LIBNFTABLES nftables)
     target_link_libraries(pihole-FTL ${LIBNFTABLES})
--- a/src/api/api.c
+++ b/src/api/api.c
@@ -221,7 +221,7 @@ void getTopDomains(const char *client_me
 	const bool blocked = command(client_message, ">top-ads");
 
 	// Exit before processing any data if requested via config setting
-	get_privacy_level(NULL);
+	get_privacy_level();
 	if(config.privacylevel >= PRIVACY_HIDE_DOMAINS) {
 		// Always send the total number of domains, but pretend it's 0
 		if(!istelnet[*sock])
@@ -270,7 +270,7 @@ void getTopDomains(const char *client_me
 
 
 	// Get filter
-	const char* filter = read_setupVarsconf("API_QUERY_LOG_SHOW");
+	const char* filter = uci_get_string("pihole", "api_query_log_show");
 	bool showpermitted = true, showblocked = true;
 	if(filter != NULL)
 	{
@@ -290,7 +290,7 @@ void getTopDomains(const char *client_me
 	char * excludedomains = NULL;
 	if(!audit)
 	{
-		excludedomains = read_setupVarsconf("API_EXCLUDE_DOMAINS");
+		excludedomains = uci_get_string("pihole", "api_exclude_domains");
 		if(excludedomains != NULL)
 		{
 			getSetupVarsArray(excludedomains);
@@ -372,7 +372,7 @@ void getTopClients(const char *client_me
 	int temparray[counters->clients][2], count=10, num;
 
 	// Exit before processing any data if requested via config setting
-	get_privacy_level(NULL);
+	get_privacy_level();
 	if(config.privacylevel >= PRIVACY_HIDE_DOMAINS_CLIENTS) {
 		// Always send the total number of clients, but pretend it's 0
 		if(!istelnet[*sock])
@@ -430,7 +430,7 @@ void getTopClients(const char *client_me
 		qsort(temparray, counters->clients, sizeof(int[2]), cmpdesc);
 
 	// Get clients which the user doesn't want to see
-	const char* excludeclients = read_setupVarsconf("API_EXCLUDE_CLIENTS");
+	const char* excludeclients = uci_get_string("pihole", "api_exclude_clients");
 	if(excludeclients != NULL)
 	{
 		getSetupVarsArray(excludeclients);
@@ -688,7 +688,7 @@ void getQueryTypes(const int *sock)
 void getAllQueries(const char *client_message, const int *sock)
 {
 	// Exit before processing any data if requested via config setting
-	get_privacy_level(NULL);
+	get_privacy_level();
 	if(config.privacylevel >= PRIVACY_MAXIMUM)
 		return;
 
@@ -892,7 +892,7 @@ void getAllQueries(const char *client_me
 	}
 
 	// Get potentially existing filtering flags
-	char * filter = read_setupVarsconf("API_QUERY_LOG_SHOW");
+	const char* filter = uci_get_string("pihole", "api_query_log_show");
 	if(filter != NULL)
 	{
 		if((strcmp(filter, "permittedonly")) == 0)
@@ -1220,7 +1220,7 @@ void getClientsOverTime(const int *sock)
 	int sendit = -1, until = OVERTIME_SLOTS;
 
 	// Exit before processing any data if requested via config setting
-	get_privacy_level(NULL);
+	get_privacy_level();
 	if(config.privacylevel >= PRIVACY_HIDE_DOMAINS_CLIENTS)
 		return;
 
@@ -1248,7 +1248,7 @@ void getClientsOverTime(const int *sock)
 	}
 
 	// Get clients which the user doesn't want to see
-	char * excludeclients = read_setupVarsconf("API_EXCLUDE_CLIENTS");
+	char * excludeclients = uci_get_string("pihole", "api_exclude_clients");
 	// Array of clients to be skipped in the output
 	// if skipclient[i] == true then this client should be hidden from
 	// returned data. We initialize it with false
@@ -1318,12 +1318,12 @@ void getClientsOverTime(const int *sock)
 void getClientNames(const int *sock)
 {
 	// Exit before processing any data if requested via config setting
-	get_privacy_level(NULL);
+	get_privacy_level();
 	if(config.privacylevel >= PRIVACY_HIDE_DOMAINS_CLIENTS)
 		return;
 
 	// Get clients which the user doesn't want to see
-	char * excludeclients = read_setupVarsconf("API_EXCLUDE_CLIENTS");
+	char * excludeclients = uci_get_string("pihole", "api_exclude_clients");
 	// Array of clients to be skipped in the output
 	// if skipclient[i] == true then this client should be hidden from
 	// returned data. We initialize it with false
@@ -1383,7 +1383,7 @@ void getClientNames(const int *sock)
 void getUnknownQueries(const int *sock)
 {
 	// Exit before processing any data if requested via config setting
-	get_privacy_level(NULL);
+	get_privacy_level();
 	if(config.privacylevel >= PRIVACY_HIDE_DOMAINS)
 		return;
 
--- a/src/config.c
+++ b/src/config.c
@@ -19,14 +19,11 @@
 
 // INT_MAX
 #include <limits.h>
+// UCI
+#include "config_uci.h"
 
 ConfigStruct config;
 FTLFileNamesStruct FTLfiles = {
-	// Default path for config file (regular installations)
-	"/etc/pihole/pihole-FTL.conf",
-	// Alternative path for config file (snap installations)
-	"/var/snap/pihole/common/etc/pihole/pihole-FTL.conf",
-	NULL,
 	NULL,
 	NULL,
 	NULL,
@@ -37,46 +34,15 @@ FTLFileNamesStruct FTLfiles = {
 	NULL
 };
 
-pthread_mutex_t lock;
-
-// Private global variables
-static char *conflinebuffer = NULL;
-static size_t size = 0;
-
 // Private prototypes
-static char *parse_FTLconf(FILE *fp, const char * key);
-static void getpath(FILE* fp, const char *option, const char *defaultloc, char **pointer);
-static bool read_bool(const char *option, const bool fallback);
-
-void init_config_mutex(void)
-{
-	// Initialize the lock attributes
-	pthread_mutexattr_t lock_attr = {};
-	pthread_mutexattr_init(&lock_attr);
-
-	// Initialize the lock
-	pthread_mutex_init(&lock, &lock_attr);
-
-	// Destroy the lock attributes since we're done with it
-	pthread_mutexattr_destroy(&lock_attr);
-}
+static void getpath(const char *option, const char *defaultloc, char **pointer);
 
 void getLogFilePath(void)
 {
-	FILE *fp;
 	char * buffer;
-
-	// Try to open default config file. Use fallback if not found
-	if( ((fp = fopen(FTLfiles.conf, "r")) == NULL) &&
-	    ((fp = fopen(FTLfiles.snapConf, "r")) == NULL) &&
-	    ((fp = fopen("pihole-FTL.conf", "r")) == NULL))
-	{
-		printf("Notice: Found no readable FTL config file\n");
-	}
-
 	// Read LOGFILE value if available
 	// defaults to: "/var/log/pihole-FTL.log"
-	buffer = parse_FTLconf(fp, "LOGFILE");
+	buffer = uci_get_string("pihole", "logfile");
 
 	errno = 0;
 	// Use sscanf() to obtain filename from config file parameter only if buffer != NULL
@@ -104,28 +70,14 @@ void getLogFilePath(void)
 
 void read_FTLconf(void)
 {
-	FILE *fp;
 	char * buffer;
 
-	// Try to open default config file. Use fallback if not found
-	if( ((fp = fopen(FTLfiles.conf, "r")) == NULL) &&
-	    ((fp = fopen(FTLfiles.snapConf, "r")) == NULL) &&
-	    ((fp = fopen("pihole-FTL.conf", "r")) == NULL))
-	{
-		logg("Notice: Found no readable FTL config file");
-		logg("        Using default settings");
-	}
-
 	// Parse lines in the config file
-	logg("Starting config file parsing (%s)", FTLfiles.conf);
+	logg("Parsing UCI Config started");
 
 	// SOCKET_LISTENING
 	// defaults to: listen only local
-	config.socket_listenlocal = true;
-	buffer = parse_FTLconf(fp, "SOCKET_LISTENING");
-
-	if(buffer != NULL && strcasecmp(buffer, "all") == 0)
-		config.socket_listenlocal = false;
+	config.socket_listenlocal = uci_read_bool("pihole", "socket_listen_local", true);
 
 	if(config.socket_listenlocal)
 		logg("   SOCKET_LISTENING: only local");
@@ -134,8 +86,7 @@ void read_FTLconf(void)
 
 	// AAAA_QUERY_ANALYSIS
 	// defaults to: Yes
-	buffer = parse_FTLconf(fp, "AAAA_QUERY_ANALYSIS");
-	config.analyze_AAAA = read_bool(buffer, true);
+	config.analyze_AAAA = uci_read_bool("pihole", "aaaa_query_analysis", true);
 
 	if(config.analyze_AAAA)
 		logg("   AAAA_QUERY_ANALYSIS: Show AAAA queries");
@@ -145,7 +96,7 @@ void read_FTLconf(void)
 	// MAXDBDAYS
 	// defaults to: 365 days
 	config.maxDBdays = 365;
-	buffer = parse_FTLconf(fp, "MAXDBDAYS");
+	buffer = uci_get_string("pihole", "maxdbdays");
 
 	int value = 0;
 	const int maxdbdays_max = INT_MAX / 24 / 60 / 60;
@@ -169,8 +120,7 @@ void read_FTLconf(void)
 
 	// RESOLVE_IPV6
 	// defaults to: Yes
-	buffer = parse_FTLconf(fp, "RESOLVE_IPV6");
-	config.resolveIPv6 = read_bool(buffer, true);
+	config.resolveIPv6 = uci_read_bool("pihole", "resolve_ipv6", true);
 
 	if(config.resolveIPv6)
 		logg("   RESOLVE_IPV6: Resolve IPv6 addresses");
@@ -179,8 +129,7 @@ void read_FTLconf(void)
 
 	// RESOLVE_IPV4
 	// defaults to: Yes
-	buffer = parse_FTLconf(fp, "RESOLVE_IPV4");
-	config.resolveIPv4 = read_bool(buffer, true);
+	config.resolveIPv4 = uci_read_bool("pihole", "resolve_ipv4", true);
 
 	if(config.resolveIPv4)
 		logg("   RESOLVE_IPV4: Resolve IPv4 addresses");
@@ -192,7 +141,7 @@ void read_FTLconf(void)
 	// this value can be a floating point number, e.g. "DBINTERVAL=0.5"
 	// defaults to: once per minute
 	config.DBinterval = 60;
-	buffer = parse_FTLconf(fp, "DBINTERVAL");
+	buffer = uci_get_string("pihole", "dbinterval");
 
 	float fvalue = 0;
 	if(buffer != NULL && sscanf(buffer, "%f", &fvalue))
@@ -209,7 +158,7 @@ void read_FTLconf(void)
 
 	// DBFILE
 	// defaults to: "/etc/pihole/pihole-FTL.db"
-	buffer = parse_FTLconf(fp, "DBFILE");
+	buffer = uci_get_string("pihole", "dbfile");
 
 	// Use sscanf() to obtain filename from config file parameter only if buffer != NULL
 	if(!(buffer != NULL && sscanf(buffer, "%127ms", &FTLfiles.FTL_db)))
@@ -233,28 +182,23 @@ void read_FTLconf(void)
 	// On which port should FTL be listening?
 	// defaults to: 4711
 	config.port = 4711;
-	buffer = parse_FTLconf(fp, "FTLPORT");
+	value = uci_get_value_int("pihole", "ftlport");
 
-	value = 0;
-	if(buffer != NULL && sscanf(buffer, "%i", &value))
-		if(value > 0 && value <= 65535)
-			config.port = value;
+	if(value > 0 && value <= 65535)
+		config.port = value;
 
 	// MAXLOGAGE
 	// Up to how many hours in the past should queries be imported from the database?
 	// defaults to: 24.0 via MAXLOGAGE defined in FTL.h
 	config.maxlogage = MAXLOGAGE*3600;
-	buffer = parse_FTLconf(fp, "MAXLOGAGE");
+	value = uci_get_value_int("pihole", "maxlogage");
 
-	fvalue = 0;
 	const char *hint = "";
-	if(buffer != NULL && sscanf(buffer, "%f", &fvalue))
-	{
-		if(fvalue >= 0.0f && fvalue <= 1.0f*MAXLOGAGE)
-			config.maxlogage = (int)(fvalue * 3600);
-		else if(fvalue > 1.0f*MAXLOGAGE)
-			hint = " (value has been clipped to " str(MAXLOGAGE) " hours)";
-	}
+	if(value > 0 && value < MAXLOGAGE)
+		config.maxlogage = (value * 3600);
+	else if(value > MAXLOGAGE)
+		hint = " (value has been clipped to " str(MAXLOGAGE) " hours)";
+
 	logg("   MAXLOGAGE: Importing up to %.1f hours of log data%s",
 	     (float)config.maxlogage/3600.0f, hint);
 
@@ -269,16 +213,12 @@ void read_FTLconf(void)
 	// PRIVACY_NOSTATS (4) = Disable any analysis on queries. No counters are available in this mode.
 	// defaults to: PRIVACY_SHOW_ALL
 	config.privacylevel = PRIVACY_SHOW_ALL;
-	get_privacy_level(fp);
+	get_privacy_level();
 	logg("   PRIVACYLEVEL: Set to %i", config.privacylevel);
 
 	// IGNORE_LOCALHOST
 	// defaults to: false
-	buffer = parse_FTLconf(fp, "IGNORE_LOCALHOST");
-	config.ignore_localhost = read_bool(buffer, false);
-
-	if(buffer != NULL && strcasecmp(buffer, "yes") == 0)
-		config.ignore_localhost = true;
+	config.ignore_localhost = uci_read_bool("pihole", "ignore_localhost", true);
 
 	if(config.ignore_localhost)
 		logg("   IGNORE_LOCALHOST: Hide queries from localhost");
@@ -287,7 +227,7 @@ void read_FTLconf(void)
 
 	// BLOCKINGMODE
 	// defaults to: MODE_IP
-	get_blocking_mode(fp);
+	get_blocking_mode();
 	switch(config.blockingmode)
 	{
 		case MODE_NX:
@@ -309,11 +249,7 @@ void read_FTLconf(void)
 
 	// ANALYZE_ONLY_A_AND_AAAA
 	// defaults to: false
-	buffer = parse_FTLconf(fp, "ANALYZE_ONLY_A_AND_AAAA");
-	config.analyze_only_A_AAAA = read_bool(buffer, false);
-
-	if(buffer != NULL && strcasecmp(buffer, "true") == 0)
-		config.analyze_only_A_AAAA = true;
+	config.analyze_only_A_AAAA = uci_read_bool("pihole", "analyze_only_a_aaaa", false);
 
 	if(config.analyze_only_A_AAAA)
 		logg("   ANALYZE_ONLY_A_AND_AAAA: Enabled. Analyzing only A and AAAA queries");
@@ -322,8 +258,7 @@ void read_FTLconf(void)
 
 	// DBIMPORT
 	// defaults to: Yes
-	buffer = parse_FTLconf(fp, "DBIMPORT");
-	config.DBimport = read_bool(buffer, true);
+	config.DBimport = uci_read_bool("pihole", "dbimport", true);
 
 	if(config.DBimport)
 	{
@@ -335,28 +270,27 @@ void read_FTLconf(void)
 		logg("   DBIMPORT: Not importing history from database");
 
 	// PIDFILE
-	getpath(fp, "PIDFILE", "/run/pihole-FTL.pid", &FTLfiles.pid);
+	getpath("pidfile", "/var/run/pihole/pihole-FTL.pid", &FTLfiles.pid);
 
 	// PORTFILE
-	getpath(fp, "PORTFILE", "/run/pihole-FTL.port", &FTLfiles.port);
+	getpath("portfile", "/var/run/pihole/pihole-FTL.port", &FTLfiles.port);
 	saveport(config.port);
 
 	// SOCKETFILE
-	getpath(fp, "SOCKETFILE", "/run/pihole/FTL.sock", &FTLfiles.socketfile);
+	getpath("socketfile", "/var/run/pihole/FTL.sock", &FTLfiles.socketfile);
 
 	// SETUPVARSFILE
-	getpath(fp, "SETUPVARSFILE", "/etc/pihole/setupVars.conf", &FTLfiles.setupVars);
+	//getpath("setupvarsfile", "/etc/pihole/setupVars.conf", &FTLfiles.setupVars);
 
 	// MACVENDORDB
-	getpath(fp, "MACVENDORDB", "/etc/pihole/macvendor.db", &FTLfiles.macvendor_db);
+	getpath("macvendordb", "/etc/pihole/macvendor.db", &FTLfiles.macvendor_db);
 
 	// GRAVITYDB
-	getpath(fp, "GRAVITYDB", "/etc/pihole/gravity.db", &FTLfiles.gravity_db);
+	getpath("gravitydb", "/etc/pihole/gravity.db", &FTLfiles.gravity_db);
 
 	// PARSE_ARP_CACHE
 	// defaults to: true
-	buffer = parse_FTLconf(fp, "PARSE_ARP_CACHE");
-	config.parse_arp_cache = read_bool(buffer, true);
+	config.parse_arp_cache = uci_read_bool("pihole", "parse_arp_cache", true);
 
 	if(config.parse_arp_cache)
 		logg("   PARSE_ARP_CACHE: Active");
@@ -365,8 +299,7 @@ void read_FTLconf(void)
 
 	// CNAME_DEEP_INSPECT
 	// defaults to: true
-	buffer = parse_FTLconf(fp, "CNAME_DEEP_INSPECT");
-	config.cname_inspection = read_bool(buffer, true);
+	config.cname_inspection = uci_read_bool("pihole", "cname_deep_inspect", true);
 
 	if(config.cname_inspection)
 		logg("   CNAME_DEEP_INSPECT: Active");
@@ -375,19 +308,19 @@ void read_FTLconf(void)
 
 	// DELAY_STARTUP
 	// defaults to: zero (seconds)
-	buffer = parse_FTLconf(fp, "DELAY_STARTUP");
+	value = uci_get_value_int("pihole", "delay_startup");
 
 	config.delay_startup = 0;
-	if(buffer != NULL && sscanf(buffer, "%u", &config.delay_startup) &&
-	   (config.delay_startup > 0 && config.delay_startup <= 300))
+	if(value > 0 && value <= 300) {
+		config.delay_startup = (unsigned int)value;
 		logg("   DELAY_STARTUP: Requested to wait %u seconds during startup.", config.delay_startup);
+	}
 	else
 		logg("   DELAY_STARTUP: No delay requested.");
 
 	// BLOCK_ESNI
 	// defaults to: true
-	buffer = parse_FTLconf(fp, "BLOCK_ESNI");
-	config.block_esni = read_bool(buffer, true);
+	config.block_esni = uci_read_bool("pihole", "block_esni", true);
 
 	if(config.block_esni)
 		logg("   BLOCK_ESNI: Enabled, blocking _esni.{blocked domain}");
@@ -399,13 +332,10 @@ void read_FTLconf(void)
 	// of days are removed to avoid dead entries in the network overview table
 	// defaults to: the same value as MAXDBDAYS
 	config.network_expire = config.maxDBdays;
-	buffer = parse_FTLconf(fp, "MAXNETAGE");
+	value = uci_get_value_int("pihole", "maxnetage");
 
-	int ivalue = 0;
-	if(buffer != NULL &&
-	    sscanf(buffer, "%i", &ivalue) &&
-	    ivalue > 0 && ivalue <= 8760) // 8760 days = 24 years
-			config.network_expire = ivalue;
+	if(value > 0 && value <= 8760) // 8760 days = 24 years
+		config.network_expire = value;
 
 	if(config.network_expire > 0u)
 		logg("   MAXNETAGE: Removing IP addresses and host names from network table after %u days",
@@ -421,8 +351,7 @@ void read_FTLconf(void)
 	// we use the host name associated to the other address as this is the same
 	// device. This behavior can be disabled using NAMES_FROM_NETDB=false
 	// defaults to: true
-	buffer = parse_FTLconf(fp, "NAMES_FROM_NETDB");
-	config.names_from_netdb = read_bool(buffer, true);
+	config.names_from_netdb = uci_read_bool("pihole", "names_from_netdb", true);
 
 	if(config.names_from_netdb)
 		logg("   NAMES_FROM_NETDB: Enabled, trying to get names from network database");
@@ -433,8 +362,7 @@ void read_FTLconf(void)
 	// Should we overwrite the query source when client information is
 	// provided through EDNS0 client subnet (ECS) information?
 	// defaults to: true
-	buffer = parse_FTLconf(fp, "EDNS0_ECS");
-	config.edns0_ecs = read_bool(buffer, true);
+	config.edns0_ecs = uci_read_bool("pihole", "edns0_ecs", true);
 
 	if(config.edns0_ecs)
 		logg("   EDNS0_ECS: Overwrite client from ECS information");
@@ -443,7 +371,7 @@ void read_FTLconf(void)
 
 	// REFRESH_HOSTNAMES
 	// defaults to: IPV4
-	buffer = parse_FTLconf(fp, "REFRESH_HOSTNAMES");
+	buffer = uci_get_string("pihole", "refresh_hostnames");
 
 	if(buffer != NULL && strcasecmp(buffer, "ALL") == 0)
 	{
@@ -470,7 +398,7 @@ void read_FTLconf(void)
 	// defaults to: 1000 queries / 60 seconds
 	config.rate_limit.count = 1000;
 	config.rate_limit.interval = 60;
-	buffer = parse_FTLconf(fp, "RATE_LIMIT");
+	buffer = uci_get_string("pihole", "rate_limit");
 
 	unsigned int count = 0, interval = 0;
 	if(buffer != NULL && sscanf(buffer, "%u/%u", &count, &interval) == 2)
@@ -491,7 +419,7 @@ void read_FTLconf(void)
 	// defaults to: not set
 	config.reply_addr.own_host.overwrite_v4 = false;
 	config.reply_addr.own_host.v4.s_addr = 0;
-	buffer = parse_FTLconf(fp, "LOCAL_IPV4");
+	buffer = uci_get_string("pihole", "local_ipv4");
 	if(buffer != NULL && inet_pton(AF_INET, buffer, &config.reply_addr.own_host.v4))
 		config.reply_addr.own_host.overwrite_v4 = true;
 
@@ -510,7 +438,7 @@ void read_FTLconf(void)
 	// defaults to: not set
 	config.reply_addr.own_host.overwrite_v6 = false;
 	memset(&config.reply_addr.own_host.v6, 0, sizeof(config.reply_addr.own_host.v6));
-	buffer = parse_FTLconf(fp, "LOCAL_IPV6");
+	buffer = uci_get_string("pihole", "local_ipv6");
 	if(buffer != NULL && inet_pton(AF_INET6, buffer, &config.reply_addr.own_host.v6))
 		config.reply_addr.own_host.overwrite_v6 = true;
 
@@ -528,7 +456,7 @@ void read_FTLconf(void)
 	// defaults to: REPLY_ADDR4 setting
 	config.reply_addr.ip_blocking.overwrite_v4 = false;
 	config.reply_addr.ip_blocking.v4.s_addr = 0;
-	buffer = parse_FTLconf(fp, "BLOCK_IPV4");
+	buffer = uci_get_string("pihole", "block_ipv4");
 	if(buffer != NULL && inet_pton(AF_INET, buffer, &config.reply_addr.ip_blocking.v4))
 		config.reply_addr.ip_blocking.overwrite_v4 = true;
 
@@ -546,7 +474,7 @@ void read_FTLconf(void)
 	// defaults to: REPLY_ADDR6 setting
 	config.reply_addr.ip_blocking.overwrite_v6 = false;
 	memset(&config.reply_addr.ip_blocking.v6, 0, sizeof(config.reply_addr.own_host.v6));
-	buffer = parse_FTLconf(fp, "BLOCK_IPV6");
+	buffer = uci_get_string("pihole", "block_ipv6");
 	if(buffer != NULL && inet_pton(AF_INET6, buffer, &config.reply_addr.ip_blocking.v6))
 		config.reply_addr.ip_blocking.overwrite_v6 = true;
 
@@ -564,7 +492,7 @@ void read_FTLconf(void)
 	// IPv4 interface address a query arrived on A hostname and IP blocked queries
 	// defaults to: not set
 	struct in_addr reply_addr4;
-	buffer = parse_FTLconf(fp, "REPLY_ADDR4");
+	buffer = uci_get_string("pihole", "reply_addr4");
 	if(buffer != NULL && inet_pton(AF_INET, buffer, &reply_addr4))
 	{
 		if(config.reply_addr.own_host.overwrite_v4 || config.reply_addr.ip_blocking.overwrite_v4)
@@ -589,7 +517,7 @@ void read_FTLconf(void)
 	// IPv4 interface address a query arrived on A hostname and IP blocked queries
 	// defaults to: not set
 	struct in6_addr reply_addr6;
-	buffer = parse_FTLconf(fp, "REPLY_ADDR6");
+	buffer = uci_get_string("pihole", "reply_addr6");
 	if(buffer != NULL && inet_pton(AF_INET, buffer, &reply_addr6))
 	{
 		if(config.reply_addr.own_host.overwrite_v6 || config.reply_addr.ip_blocking.overwrite_v6)
@@ -612,8 +540,7 @@ void read_FTLconf(void)
 	// SHOW_DNSSEC
 	// Should FTL analyze and include automatically generated DNSSEC queries in the Query Log?
 	// defaults to: true
-	buffer = parse_FTLconf(fp, "SHOW_DNSSEC");
-	config.show_dnssec = read_bool(buffer, true);
+	config.show_dnssec = uci_read_bool("pihole", "show_dnssec", true);
 
 	if(config.show_dnssec)
 		logg("   SHOW_DNSSEC: Enabled, showing automatically generated DNSSEC queries");
@@ -623,8 +550,7 @@ void read_FTLconf(void)
 	// MOZILLA_CANARY
 	// Should FTL handle use-application-dns.net specifically and always return NXDOMAIN?
 	// defaults to: true
-	buffer = parse_FTLconf(fp, "MOZILLA_CANARY");
-	config.special_domains.mozilla_canary = read_bool(buffer, true);
+	config.special_domains.mozilla_canary = uci_read_bool("pihole", "mozilla_canary", true);
 
 	if(config.special_domains.mozilla_canary)
 		logg("   MOZILLA_CANARY: Enabled");
@@ -634,7 +560,7 @@ void read_FTLconf(void)
 	// PIHOLE_PTR
 	// Should FTL return "pi.hole" as name for PTR requests to local IP addresses?
 	// defaults to: PI.HOLE
-	buffer = parse_FTLconf(fp, "PIHOLE_PTR");
+	buffer = uci_get_string("pihole", "pihole_ptr");
 
 	if(buffer != NULL && (strcasecmp(buffer, "none") == 0 ||
 	                      strcasecmp(buffer, "false") == 0))
@@ -661,7 +587,7 @@ void read_FTLconf(void)
 	// REPLY_WHEN_BUSY
 	// How should FTL handle queries when the gravity database is not available?
 	// defaults to: BLOCK
-	buffer = parse_FTLconf(fp, "REPLY_WHEN_BUSY");
+	buffer = uci_get_string("pihole", "reply_when_busy");
 
 	if(buffer != NULL && strcasecmp(buffer, "DROP") == 0)
 	{
@@ -687,11 +613,10 @@ void read_FTLconf(void)
 	// BLOCK_TTL
 	// defaults to: 2 seconds
 	config.block_ttl = 2;
-	buffer = parse_FTLconf(fp, "BLOCK_TTL");
+	value = uci_get_value_int("pihole", "block_ttl");
 
-	unsigned int uval = 0;
-	if(buffer != NULL && sscanf(buffer, "%u", &uval))
-		config.block_ttl = uval;
+	if(value > 0)
+		config.block_ttl = (unsigned int)value;
 
 	if(config.block_ttl == 1)
 		logg("   BLOCK_TTL: 1 second");
@@ -702,8 +627,7 @@ void read_FTLconf(void)
 	// Should FTL handle the iCloud privacy relay domains specifically and
 	// always return NXDOMAIN?
 	// defaults to: true
-	buffer = parse_FTLconf(fp, "BLOCK_ICLOUD_PR");
-	config.special_domains.icloud_private_relay = read_bool(buffer, true);
+	config.special_domains.icloud_private_relay = uci_read_bool("pihole", "block_icloud_pr", true);
 
 	if(config.special_domains.icloud_private_relay)
 		logg("   BLOCK_ICLOUD_PR: Enabled");
@@ -714,8 +638,7 @@ void read_FTLconf(void)
 	// Should FTL check the 15 min average of CPU load and complain if the
 	// load is larger than the number of available CPU cores?
 	// defaults to: true
-	buffer = parse_FTLconf(fp, "CHECK_LOAD");
-	config.check.load = read_bool(buffer, true);
+	config.check.load = uci_read_bool("pihole", "check_load", true);
 
 	if(config.check.load)
 		logg("   CHECK_LOAD: Enabled");
@@ -726,12 +649,10 @@ void read_FTLconf(void)
 	// Limit above which FTL should complain about a shared-memory shortage
 	// defaults to: 90%
 	config.check.shmem = 90;
-	buffer = parse_FTLconf(fp, "CHECK_SHMEM");
+	value = uci_get_value_int("pihole", "check_shmem");
 
-	if(buffer != NULL &&
-	    sscanf(buffer, "%i", &ivalue) &&
-	    ivalue >= 0 && ivalue <= 100)
-			config.check.shmem = ivalue;
+	if(value >= 0 && value <= 100)
+		config.check.shmem = value;
 
 	logg("   CHECK_SHMEM: Warning if shared-memory usage exceeds %d%%", config.check.shmem);
 
@@ -739,32 +660,27 @@ void read_FTLconf(void)
 	// Limit above which FTL should complain about disk shortage for checked files
 	// defaults to: 90%
 	config.check.disk = 90;
-	buffer = parse_FTLconf(fp, "CHECK_DISK");
+	value = uci_get_value_int("pihole", "check_disk");
 
-	if(buffer != NULL &&
-	    sscanf(buffer, "%i", &ivalue) &&
-	    ivalue >= 0 && ivalue <= 100)
-			config.check.disk = ivalue;
+	if(value >= 0 && value <= 100)
+		config.check.disk = value;
 
 	logg("   CHECK_DISK: Warning if certain disk usage exceeds %d%%", config.check.disk);
 
 	// Read DEBUG_... setting from pihole-FTL.conf
-	read_debuging_settings(fp);
+	read_debuging_settings();
 
 	logg("Finished config file parsing");
-
-	if(fp != NULL)
-		fclose(fp);
 }
 
-static void getpath(FILE* fp, const char *option, const char *defaultloc, char **pointer)
+static void getpath(const char *option, const char *defaultloc, char **pointer)
 {
 	// This subroutine is used to read paths from pihole-FTL.conf
 	// fp:         File pointer to opened and readable config file
 	// option:     Option string ("key") to try to read
 	// defaultloc: Value used if key is not found in file
 	// pointer:    Location where read (or default) parameter is stored
-	char *buffer = parse_FTLconf(fp, option);
+	char *buffer = uci_get_string("pihole", option);
 
 	errno = 0;
 	// Use sscanf() to obtain filename from config file parameter only if buffer != NULL
@@ -791,144 +707,29 @@ static void getpath(FILE* fp, const char
 	}
 }
 
-static char *parse_FTLconf(FILE *fp, const char *key)
-{
-	// Return NULL if fp is an invalid file pointer
-	if(fp == NULL)
-		return NULL;
-
-	char *keystr = calloc(strlen(key)+2, sizeof(char));
-	if(keystr == NULL)
-	{
-		logg("WARN: parse_FTLconf failed: could not allocate memory for keystr");
-		return NULL;
-	}
-	sprintf(keystr, "%s=", key);
-
-	// Lock mutex
-	const int lret = pthread_mutex_lock(&lock);
-	if(config.debug & DEBUG_LOCKS)
-		logg("Obtained config lock");
-	if(lret != 0)
-		logg("Error when obtaining config lock: %s", strerror(lret));
-
-	// Go to beginning of file
-	fseek(fp, 0L, SEEK_SET);
-
-	if(config.debug & DEBUG_EXTRA)
-		logg("initial: conflinebuffer = %p, keystr = %p, size = %zu", conflinebuffer, keystr, size);
-
-	// Set size to zero if conflinebuffer is not available here
-	// This causes getline() to allocate memory for the buffer itself
-	if(conflinebuffer == NULL && size != 0)
-		size = 0;
-
-	errno = 0;
-	while(getline(&conflinebuffer, &size, fp) != -1)
-	{
-		if(config.debug & DEBUG_EXTRA)
-		{
-			logg("conflinebuffer = %p, keystr = %p, size = %zu", conflinebuffer, keystr, size);
-			logg("  while reading line \"%s\" looking for \"%s\"", conflinebuffer, keystr);
-		}
-		// Check if memory allocation failed
-		if(conflinebuffer == NULL)
-			break;
-
-		// Skip comment lines
-		if(conflinebuffer[0] == '#' || conflinebuffer[0] == ';')
-			continue;
-
-		// Skip lines with other keys
-		if((strstr(conflinebuffer, keystr)) == NULL)
-			continue;
-
-		// *** MATCH ****
-
-		// Note: value is still a pointer into the conflinebuffer,
-		// no need to duplicate memory here
-		char *value = find_equals(conflinebuffer) + 1;
-
-		// Trim whitespace at beginning and end, this function modifies
-		// the string inplace
-		trim_whitespace(value);
-
-		const int uret = pthread_mutex_unlock(&lock);
-		if(config.debug & DEBUG_LOCKS)
-			logg("Released config lock (match)");
-		if(uret != 0)
-			logg("Error when releasing config lock (match): %s", strerror(uret));
-
-		// Free keystr memory
-		free(keystr);
-		return value;
-	}
-
-	if(errno == ENOMEM)
-		logg("WARN: parse_FTLconf failed: could not allocate memory for getline");
-
-	const int uret = pthread_mutex_unlock(&lock);
-	if(config.debug & DEBUG_LOCKS)
-		logg("Released config lock (no match)");
-	if(uret != 0)
-		logg("Error when releasing config lock (no match): %s", strerror(uret));
-
-	// Key not found or memory error -> return NULL
-	free(keystr);
-
-	return NULL;
-}
-
-void get_privacy_level(FILE *fp)
+void get_privacy_level(void)
 {
-	// See if we got a file handle, if not we have to open
-	// the config file ourselves
-	bool opened = false;
-	if(fp == NULL)
-	{
-		if((fp = fopen(FTLfiles.conf, "r")) == NULL)
-			// Return silently if there is no config file available
-			return;
-		opened = true;
-	}
+	int value = uci_get_value_int("pihole", "privacylevel");
 
-	int value = 0;
-	char *buffer = parse_FTLconf(fp, "PRIVACYLEVEL");
-	if(buffer != NULL && sscanf(buffer, "%i", &value) == 1)
+	// Check for change and validity of privacy level (set in FTL.h)
+	if(value >= PRIVACY_SHOW_ALL && value <= PRIVACY_MAXIMUM)
 	{
-		// Check for change and validity of privacy level (set in FTL.h)
-		if(value >= PRIVACY_SHOW_ALL &&
-		   value <= PRIVACY_MAXIMUM &&
-		   value > config.privacylevel)
-		{
+		if(value > config.privacylevel)
 			logg("Notice: Increasing privacy level from %i to %i", config.privacylevel, value);
-			config.privacylevel = value;
-		}
-	}
+		else if(value < config.privacylevel)
+			logg("Notice: Decreasing privacy level from %i to %i", config.privacylevel, value);
 
-	// Have to close the config file if we opened it
-	if(opened)
-		fclose(fp);
+		config.privacylevel = value;
+	}
 }
 
-void get_blocking_mode(FILE *fp)
+void get_blocking_mode(void)
 {
 	// Set default value
 	config.blockingmode = MODE_NULL;
 
-	// See if we got a file handle, if not we have to open
-	// the config file ourselves
-	bool opened = false;
-	if(fp == NULL)
-	{
-		if((fp = fopen(FTLfiles.conf, "r")) == NULL)
-			// Return silently if there is no config file available
-			return;
-		opened = true;
-	}
-
 	// Get config string (if present)
-	char *buffer = parse_FTLconf(fp, "BLOCKINGMODE");
+	char *buffer = uci_get_string("pihole", "blockingmode");
 	if(buffer != NULL)
 	{
 		if(strcasecmp(buffer, "NXDOMAIN") == 0)
@@ -944,139 +745,120 @@ void get_blocking_mode(FILE *fp)
 		else
 			logg("Ignoring unknown blocking mode, fallback is NULL blocking");
 	}
-
-	// Have to close the config file if we opened it
-	if(opened)
-		fclose(fp);
 }
 
 // Routine for setting the debug flags in the config struct
-static void setDebugOption(FILE* fp, const char* option, enum debug_flags bitmask)
+static void setDebugOption(const char* option, enum debug_flags bitmask)
 {
-	const char* buffer = parse_FTLconf(fp, option);
-
-	// Return early if the key has not been found in FTL's config file
-	if(buffer == NULL)
-		return;
+	bool buffer = uci_read_bool("pihole", option, false);
 
 	// Set bit if value equals "true", clear bit otherwise
-	if(read_bool(buffer, false))
+	if(buffer)
 		config.debug |= bitmask;
 	else
 		config.debug &= ~bitmask;
 }
 
-void read_debuging_settings(FILE *fp)
+void read_debuging_settings(void)
 {
 	// Set default (no debug instructions set)
 	config.debug = 0;
 
-	// See if we got a file handle, if not we have to open
-	// the config file ourselves
-	bool opened = false;
-	if(fp == NULL)
-	{
-		if((fp = fopen(FTLfiles.conf, "r")) == NULL)
-			// Return silently if there is no config file available
-			return;
-		opened = true;
-	}
-
 	// DEBUG_ALL
 	// defaults to: false
 	// ~0 is a shortcut for "all bits set"
-	setDebugOption(fp, "DEBUG_ALL", ~(int16_t)0);
+	setDebugOption("debug_all", ~(int16_t)0);
 
 	// DEBUG_DATABASE
 	// defaults to: false
-	setDebugOption(fp, "DEBUG_DATABASE", DEBUG_DATABASE);
+	setDebugOption("debug_database", DEBUG_DATABASE);
 
 	// DEBUG_NETWORKING
 	// defaults to: false
-	setDebugOption(fp, "DEBUG_NETWORKING", DEBUG_NETWORKING);
+	setDebugOption("debug_networking", DEBUG_NETWORKING);
 
 	// DEBUG_LOCKS
 	// defaults to: false
-	setDebugOption(fp, "DEBUG_LOCKS", DEBUG_LOCKS);
+	setDebugOption("debug_locks", DEBUG_LOCKS);
 
 	// DEBUG_QUERIES
 	// defaults to: false
-	setDebugOption(fp, "DEBUG_QUERIES", DEBUG_QUERIES);
+	setDebugOption("debug_queries", DEBUG_QUERIES);
 
 	// DEBUG_FLAGS
 	// defaults to: false
-	setDebugOption(fp, "DEBUG_FLAGS", DEBUG_FLAGS);
+	setDebugOption("debug_flags", DEBUG_FLAGS);
 
 	// DEBUG_SHMEM
 	// defaults to: false
-	setDebugOption(fp, "DEBUG_SHMEM", DEBUG_SHMEM);
+	setDebugOption("debug_shmem", DEBUG_SHMEM);
 
 	// DEBUG_GC
 	// defaults to: false
-	setDebugOption(fp, "DEBUG_GC", DEBUG_GC);
+	setDebugOption("debug_gc", DEBUG_GC);
 
 	// DEBUG_ARP
 	// defaults to: false
-	setDebugOption(fp, "DEBUG_ARP", DEBUG_ARP);
+	setDebugOption("debug_arp", DEBUG_ARP);
 
 	// DEBUG_REGEX or REGEX_DEBUGMODE (legacy config option)
 	// defaults to: false
-	setDebugOption(fp, "REGEX_DEBUGMODE", DEBUG_REGEX);
-	setDebugOption(fp, "DEBUG_REGEX", DEBUG_REGEX);
+	setDebugOption("regex_debugmode", DEBUG_REGEX);
+	setDebugOption("debug_regex", DEBUG_REGEX);
 
 	// DEBUG_API
 	// defaults to: false
-	setDebugOption(fp, "DEBUG_API", DEBUG_API);
+	setDebugOption("debug_api", DEBUG_API);
 
 	// DEBUG_OVERTIME
 	// defaults to: false
-	setDebugOption(fp, "DEBUG_OVERTIME", DEBUG_OVERTIME);
+	setDebugOption("debug_overtime", DEBUG_OVERTIME);
 
 	// DEBUG_EXTBLOCKED (deprecated, now included in DEBUG_QUERIES)
 
 	// DEBUG_STATUS
 	// defaults to: false
-	setDebugOption(fp, "DEBUG_STATUS", DEBUG_STATUS);
+	setDebugOption("debug_status", DEBUG_STATUS);
 
 	// DEBUG_CAPS
 	// defaults to: false
-	setDebugOption(fp, "DEBUG_CAPS", DEBUG_CAPS);
+	setDebugOption("debug_caps", DEBUG_CAPS);
 
 	// DEBUG_DNSSEC
 	// defaults to: false
-	setDebugOption(fp, "DEBUG_DNSSEC", DEBUG_DNSSEC);
+	setDebugOption("debug_dnssec", DEBUG_DNSSEC);
 
 	// DEBUG_VECTORS
 	// defaults to: false
-	setDebugOption(fp, "DEBUG_VECTORS", DEBUG_VECTORS);
+	setDebugOption("debug_vectors", DEBUG_VECTORS);
 
 	// DEBUG_RESOLVER
 	// defaults to: false
-	setDebugOption(fp, "DEBUG_RESOLVER", DEBUG_RESOLVER);
+	setDebugOption("debug_resolver", DEBUG_RESOLVER);
 
 	// DEBUG_EDNS0
 	// defaults to: false
-	setDebugOption(fp, "DEBUG_EDNS0", DEBUG_EDNS0);
+	setDebugOption("debug_edns0", DEBUG_EDNS0);
 
 	// DEBUG_CLIENTS
 	// defaults to: false
-	setDebugOption(fp, "DEBUG_CLIENTS", DEBUG_CLIENTS);
+	setDebugOption("debug_clients", DEBUG_CLIENTS);
 
 	// DEBUG_ALIASCLIENTS
 	// defaults to: false
-	setDebugOption(fp, "DEBUG_ALIASCLIENTS", DEBUG_ALIASCLIENTS);
+	setDebugOption("debug_aliasclients", DEBUG_ALIASCLIENTS);
 
 	// DEBUG_EVENTS
 	// defaults to: false
-	setDebugOption(fp, "DEBUG_EVENTS", DEBUG_EVENTS);
+	setDebugOption("debug_events", DEBUG_EVENTS);
 
 	// DEBUG_HELPER
 	// defaults to: false
-	setDebugOption(fp, "DEBUG_HELPER", DEBUG_HELPER);
+	setDebugOption("debug_helper", DEBUG_HELPER);
 
 	// DEBUG_EXTRA
 	// defaults to: false
-	setDebugOption(fp, "DEBUG_EXTRA", DEBUG_EXTRA);
+	setDebugOption("debug_extra", DEBUG_EXTRA);
 
 	if(config.debug)
 	{
@@ -1108,24 +890,4 @@ void read_debuging_settings(FILE *fp)
 		// Enable debug logging in dnsmasq (only effective before starting the resolver)
 		argv_dnsmasq[2] = "--log-debug";
 	}
-
-	// Have to close the config file if we opened it
-	if(opened)
-		fclose(fp);
-}
-
-static bool read_bool(const char *option, const bool fallback)
-{
-	if(option == NULL)
-		return fallback;
-
-	else if(strcasecmp(option, "false") == 0 ||
-	        strcasecmp(option, "no") == 0)
-		return false;
-
-	else if(strcasecmp(option, "true") == 0 ||
-	        strcasecmp(option, "yes") == 0)
-		return true;
-
-	return fallback;
 }
--- a/src/config.h
+++ b/src/config.h
@@ -21,13 +21,15 @@
 #include "static_assert.h"
 // struct in_addr, in6_addr
 #include <netinet/in.h>
+// config uci
+#include "config_uci.h"
 
-void init_config_mutex(void);
 void getLogFilePath(void);
 void read_FTLconf(void);
-void get_privacy_level(FILE *fp);
-void get_blocking_mode(FILE *fp);
-void read_debuging_settings(FILE *fp);
+void get_privacy_level(void);
+void get_blocking_mode(void);
+void read_debuging_settings(void);
+void check_blocking_status(void);
 
 // We do not use bitfields in here as this struct exists only once in memory.
 // Accessing bitfields may produce slightly more inefficient code on some
@@ -93,8 +95,6 @@ typedef struct {
 ASSERT_SIZEOF(ConfigStruct, 112, 104, 104);
 
 typedef struct {
-	const char* conf;
-	const char* snapConf;
 	char* log;
 	char* pid;
 	char* port;
@@ -102,7 +102,6 @@ typedef struct {
 	char* FTL_db;
 	char* gravity_db;
 	char* macvendor_db;
-	char* setupVars;
 	char* auditlist;
 } FTLFileNamesStruct;
 
--- /dev/null
+++ b/src/config_uci.c
@@ -0,0 +1,167 @@
+#include <string.h>
+#include <stdlib.h>
+#include <syslog.h>
+#include "log.h"
+#include "config_uci.h"
+#include <uci.h>
+
+static struct uci_context *uci_ctx = NULL;
+static struct uci_package *uci_pkg = NULL;
+static struct uci_ptr ptr;
+
+static struct uci_package *uci_init_package(void)
+{
+	struct uci_context *ctx = uci_ctx;
+	struct uci_package *pkg = NULL;
+
+	if (!ctx) {
+		ctx = uci_alloc_context();
+		uci_ctx = ctx;
+		ctx->flags &= ~UCI_FLAG_STRICT;
+	} else {
+		pkg = uci_lookup_package(ctx, "pihole");
+		if (pkg)
+			uci_unload(ctx, pkg);
+	}
+
+	if (uci_load(ctx, "pihole", &pkg))
+		return NULL;
+
+	return pkg;
+}
+
+void uci_reload(void)
+{
+    struct uci_context *ctx = uci_ctx;
+
+    if (!ctx) {
+        ctx = uci_alloc_context();
+        uci_ctx = ctx;
+        ctx->flags &= ~UCI_FLAG_STRICT;
+        logg("Re-Allocating UCI Context (Should not be happened)"); 
+    }
+
+    uci_pkg = uci_lookup_package(ctx, "pihole");
+    uci_unload(uci_ctx, uci_pkg);
+    uci_load(uci_ctx, "pihole", &uci_pkg);
+
+    logg("Reloading UCI Config"); 
+}
+
+int uci_init(void) {
+	uci_pkg = uci_init_package();
+	if (!uci_pkg) {
+		char *errstr;
+		uci_get_errorstr(uci_ctx, &errstr, NULL);
+		syslog(LOG_ERR, "pihole-FTL: Failed to load pihole config (%s)", errstr);
+		free(errstr);
+		return -1;
+	}
+
+	return 0;
+}
+
+void uci_clean(void)
+{
+	if (uci_pkg != NULL) {
+		uci_unload(uci_ctx, uci_pkg);
+		uci_pkg = NULL;
+	}
+	if (uci_ctx != NULL) {
+		uci_free_context(uci_ctx);
+		uci_ctx = NULL;
+	}
+	logg("Cleaning UCI Config");
+}
+
+static struct uci_section * __attribute__((pure)) get_uci_section_type(struct uci_package *pkg, const char *s)
+{
+	if(!pkg)
+		return NULL;
+
+	struct uci_element *e;
+	uci_foreach_element(&pkg->sections, e)
+	{
+		struct uci_section *section = uci_to_section(e);
+		if (strcmp(section->type, s) == 0)
+			return section;
+	}
+
+	return NULL;
+}
+
+static int uci_init_ptr(const char *section, const char *option)
+{
+	struct uci_section *sec = get_uci_section_type(uci_pkg, section);
+	if(!sec)
+		return UCI_ERR_NOTFOUND;
+
+	memset(&ptr, 0, sizeof(struct uci_ptr));
+	ptr.p = sec->package;
+	ptr.s = sec;
+	ptr.option = option;
+
+	return uci_lookup_ptr(uci_ctx, &ptr, NULL, true);
+}
+
+int uci_get_value_int(const char *section, const char *option)
+{
+	// -1 is useable for maxdbdays
+	if(uci_init_ptr(section, option) != UCI_OK)
+		return -2;
+
+	if(!(ptr.flags & UCI_LOOKUP_COMPLETE))
+		return -2;
+
+	return (ptr.o->v.string) ? atoi(ptr.o->v.string) : -2;
+}
+
+bool uci_read_bool(const char *section, const char *option, const bool fallback)
+{
+	if(uci_init_ptr(section, option) != UCI_OK)
+		return fallback;
+
+	if(!(ptr.flags & UCI_LOOKUP_COMPLETE))
+		return fallback;
+
+	if (ptr.o && ptr.o->type == UCI_TYPE_STRING)
+	{
+		if(strcasecmp(ptr.o->v.string, "false") == 0 || strcmp(ptr.o->v.string, "0") == 0)
+			return false;
+		else if(strcasecmp(ptr.o->v.string, "true") == 0 || strcmp(ptr.o->v.string, "1") == 0)
+			return true;
+	}
+
+	return fallback;
+}
+
+char* uci_get_string(const char *section, const char *option)
+{
+	if(uci_init_ptr(section, option) != UCI_OK)
+		return NULL;
+
+	if(!(ptr.flags & UCI_LOOKUP_COMPLETE))
+		return NULL;
+
+	if(ptr.o->type == UCI_TYPE_STRING)
+		return ptr.o->v.string;
+	else if(ptr.o->type == UCI_TYPE_LIST)
+	{
+		struct uci_element *e = NULL;
+		struct uci_list *list = &ptr.o->v.list;
+		static char buffer[512]; /* TODO size */
+		unsigned pos = 0;
+
+		buffer[0] = 0;
+		uci_foreach_element(list, e)
+			if (e->name)
+				pos += snprintf(&buffer[pos], sizeof(buffer) - pos, "%s%s", e->name, ",");
+
+		if (pos)
+			buffer[pos - 1] = 0;
+
+		return buffer;
+	}
+
+	return NULL;
+}
--- /dev/null
+++ b/src/config_uci.h
@@ -0,0 +1,11 @@
+#ifndef CONFIG_UCI_H
+#define CONFIG_UCI_H
+
+void uci_clean(void);
+void uci_reload(void);
+int uci_init(void);
+int uci_get_value_int(const char *section, const char *option);
+char* uci_get_string(const char *section, const char *option);
+bool uci_read_bool(const char *section, const char *option, const bool fallback);
+
+#endif
--- a/src/daemon.c
+++ b/src/daemon.c
@@ -238,6 +238,9 @@ static void terminate_threads(void)
 // Clean up on exit
 void cleanup(const int ret)
 {
+	// free uci
+	uci_clean();
+
 	// Do proper cleanup only if FTL started successfully
 	if(resolver_ready)
 	{
--- a/src/database/database-thread.c
+++ b/src/database/database-thread.c
@@ -114,7 +114,7 @@ void *DB_thread(void *val)
 
 		// Reload privacy level from pihole-FTL.conf
 		if(get_and_clear_event(RELOAD_PRIVACY_LEVEL))
-			get_privacy_level(NULL);
+			get_privacy_level();
 
 		BREAK_IF_KILLED();
 
--- a/src/dnsmasq/config.h
+++ b/src/dnsmasq/config.h
@@ -218,7 +218,7 @@ RESOLVFILE
 #   if defined(__FreeBSD__)
 #      define CONFFILE "/usr/local/etc/dnsmasq.conf"
 #   else
-#      define CONFFILE "/etc/dnsmasq.conf"
+#      define CONFFILE "/var/etc/dnsmasq.conf"
 #   endif
 #endif
 
--- a/src/dnsmasq_interface.c
+++ b/src/dnsmasq_interface.c
@@ -1762,6 +1762,9 @@ static void FTL_forwarded(const unsigned
 
 void FTL_dnsmasq_reload(void)
 {
+	// reload config
+	uci_reload();
+
 	// This function is called by the dnsmasq code on receive of SIGHUP
 	// *before* clearing the cache and rereading the lists
 	logg("Reloading DNS cache");
@@ -1776,10 +1779,10 @@ void FTL_dnsmasq_reload(void)
 	// cache and reread all blocking lists
 	// Passing NULL to this function means it has to open the config file on
 	// its own behalf (on initial reading, the config file is already opened)
-	get_blocking_mode(NULL);
+	get_blocking_mode();
 
 	// Reread pihole-FTL.conf to see which debugging flags are set
-	read_debuging_settings(NULL);
+	read_debuging_settings();
 
 	// Gravity database updates
 	// - (Re-)open gravity database connection
--- a/src/main.c
+++ b/src/main.c
@@ -48,8 +48,10 @@ int main (int argc, char* argv[])
 	// to have arg{c,v}_dnsmasq initialized
 	parse_args(argc, argv);
 
+	// init uci
+	uci_init();
+
 	// Try to open FTL log
-	init_config_mutex();
 	init_FTL_log();
 	timer_start(EXIT_TIMER);
 	logg("########## FTL started on %s! ##########", hostname());
@@ -96,7 +98,6 @@ int main (int argc, char* argv[])
 		DB_read_queries();
 
 	log_counter_info();
-	check_setupVarsconf();
 
 	// Check for availability of capabilities in debug mode
 	if(config.debug & DEBUG_CAPS)
--- a/src/setupVars.c
+++ b/src/setupVars.c
@@ -16,118 +16,6 @@
 int setupVarsElements = 0;
 char ** setupVarsArray = NULL;
 
-void check_setupVarsconf(void)
-{
-	FILE *setupVarsfp;
-	if((setupVarsfp = fopen(FTLfiles.setupVars, "r")) == NULL)
-	{
-		logg("WARN: Opening of setupVars.conf failed!");
-		logg("      Make sure it exists and is readable");
-		logg("      Message: %s", strerror(errno));
-	}
-	else
-	{
-		logg("Successfully accessed setupVars.conf");
-		fclose(setupVarsfp);
-	}
-}
-
-char* __attribute__((pure)) find_equals(const char* s)
-{
-	const char* chars = "=";
-	while (*s && (!chars || !strchr(chars, *s)))
-		s++;
-	return (char*)s;
-}
-
-void trim_whitespace(char *string)
-{
-	// isspace(char*) man page:
-	// checks for white-space  characters. In the "C" and "POSIX"
-	// locales, these are: space, form-feed ('\f'), newline ('\n'),
-	// carriage return ('\r'), horizontal tab ('\t'), and vertical tab
-	// ('\v').
-	char *original = string, *modified = string;
-	// Trim any whitespace characters (see above) at the beginning by increasing the pointer address
-	while (isspace((unsigned char)*original))
-		original++;
-	// Copy the content of original into modified as long as there is something in original
-	while ((*modified = *original++) != '\0')
-		modified++;
-	// Trim any whitespace characters (see above) at the end of the string by overwriting it
-	// with the zero character (marking the end of a C string)
-	while (modified > string && isspace((unsigned char)*--modified))
-		*modified = '\0';
-}
-
-// This will hold the read string
-// in memory and will serve the space
-// we will point to in the rest of the
-// process (e.g. setupVarsArray will
-// actually point to memory addresses
-// which we allocate for this buffer.
-char * linebuffer = NULL;
-size_t linebuffersize = 0;
-
-char * read_setupVarsconf(const char * key)
-{
-	FILE *setupVarsfp;
-	if((setupVarsfp = fopen(FTLfiles.setupVars, "r")) == NULL)
-	{
-		logg("WARN: Reading setupVars.conf failed: %s", strerror(errno));
-		return NULL;
-	}
-
-	// Allocate keystr
-	char * keystr = calloc(strlen(key)+2, sizeof(char));
-	if(keystr == NULL)
-	{
-		logg("WARN: read_setupVarsconf failed: could not allocate memory for keystr");
-		fclose(setupVarsfp);
-		return NULL;
-	}
-	sprintf(keystr, "%s=", key);
-
-	errno = 0;
-	while(getline(&linebuffer, &linebuffersize, setupVarsfp) != -1)
-	{
-		// Strip (possible) newline
-		linebuffer[strcspn(linebuffer, "\n")] = '\0';
-
-		// Skip comment lines
-		if(linebuffer[0] == '#' || linebuffer[0] == ';')
-			continue;
-
-		// Skip lines with other keys
-		if((strstr(linebuffer, keystr)) == NULL)
-			continue;
-
-		// otherwise: key found
-		fclose(setupVarsfp);
-		free(keystr);
-		return (find_equals(linebuffer) + 1);
-	}
-
-	if(errno == ENOMEM)
-		logg("WARN: read_setupVarsconf failed: could not allocate memory for getline");
-
-	// Key not found -> return NULL
-	fclose(setupVarsfp);
-
-	// Freeing keystr, not setting to NULL, since not used outside of this routine
-	free(keystr);
-
-	// Freeing and setting to NULL to prevent a dangling pointer
-	if(linebuffer != NULL)
-	{
-		free(linebuffer);
-		linebuffersize = 0;
-		linebuffer = NULL;
-	}
-
-	return NULL;
-}
-
 // split string in form:
 //   abc,def,ghi
 // into char ** array:
@@ -165,25 +53,8 @@ void clearSetupVarsArray(void)
 		free(setupVarsArray);
 		setupVarsArray = NULL;
 	}
-	if(linebuffer != NULL)
-	{
-		free(linebuffer);
-		linebuffersize = 0;
-		linebuffer = NULL;
-	}
 }
 
-/* Example
-	char * iface = read_setupVarsconf("API_EXCLUDE_DOMAINS");
-	if(iface != NULL)
-		logg_str("Interface: ",iface);
-	getSetupVarsArray(iface);
-	int i;
-	for (i = 0; i <= setupVarsElements; ++i)
-		printf ("[%d] = %s\n", i, setupVarsArray[i]);
-	clearSetupVarsArray();
-*/
-
 bool insetupVarsArray(const char * str)
 {
 	// Check for possible NULL pointer
@@ -222,23 +93,14 @@ bool insetupVarsArray(const char * str)
 	return false;
 }
 
-bool __attribute__((pure)) getSetupVarsBool(const char * input)
-{
-	if((strcmp(input, "true")) == 0)
-		return true;
-	else
-		return false;
-}
-
 // Global variable showing current blocking status
 enum blocking_status blockingstatus = BLOCKING_UNKNOWN;
 
 void check_blocking_status(void)
 {
-	const char* blocking = read_setupVarsconf("BLOCKING_ENABLED");
 	const char* message;
 
-	if(blocking == NULL || getSetupVarsBool(blocking))
+	if(uci_read_bool("pihole", "blocking_enabled", true))
 	{
 		// Parameter either not present in setupVars.conf
 		// or explicitly set to true
--- a/src/setupVars.h
+++ b/src/setupVars.h
@@ -10,15 +10,9 @@
 #ifndef SETUPVARS_H
 #define SETUPVARS_H
 
-void check_setupVarsconf(void);
-char * read_setupVarsconf(const char * key);
 void getSetupVarsArray(const char * input);
 void clearSetupVarsArray(void);
 bool insetupVarsArray(const char * str);
-bool getSetupVarsBool(const char * input) __attribute__((pure));
-char* find_equals(const char* s) __attribute__((pure));
-void trim_whitespace(char *string);
-void check_blocking_status(void);
 
 extern unsigned char blockingstatus;
 
--- a/src/signals.c
+++ b/src/signals.c
@@ -191,6 +191,9 @@ static void SIGRT_handler(int signum, si
 
 	if(rtsig == 0)
 	{
+		// reload config
+		uci_reload();
+
 		// Reload
 		// - gravity
 		// - exact whitelist
--- a/tools/socket_client.c
+++ b/tools/socket_client.c
@@ -40,7 +40,7 @@ int main (int argc, char **argv) {
 	address.sun_family = AF_LOCAL;
 
 	char *command = ">stats";
-	strcpy(address.sun_path,"/run/pihole/FTL.sock");
+	strcpy(address.sun_path,"/var/run/pihole/FTL.sock");
 
 	int i;
 	for(i = 1; i < argc; i++) {
