--- a/src/config/config.c
+++ b/src/config/config.c
@@ -387,6 +387,41 @@ void initConfig(struct config *conf)
 		return;
 	config_initialized = true;
 
+	conf->dns.blocking.block_domain.k = "dns.blocking.block_domain";
+	conf->dns.blocking.block_domain.h = "Array of domains to be blocked\n Example: [ \"google.com\", \"facebook.com\", \"example.com\" ]";
+	conf->dns.blocking.block_domain.a = cJSON_CreateStringReference("array of domain");
+	conf->dns.blocking.block_domain.t = CONF_JSON_STRING_ARRAY;
+	conf->dns.blocking.block_domain.d.json = cJSON_CreateArray();
+	conf->dns.blocking.block_domain.f = FLAG_ADVANCED_SETTING;
+
+	conf->dns.blocking.whitelist_domain.k = "dns.blocking.whitelist_domain";
+	conf->dns.blocking.whitelist_domain.h = "Array of domains to be whitelisted\n Example: [ \"google.com\", \"facebook.com\", \"example.com\" ]";
+	conf->dns.blocking.whitelist_domain.a = cJSON_CreateStringReference("array of domain");
+	conf->dns.blocking.whitelist_domain.t = CONF_JSON_STRING_ARRAY;
+	conf->dns.blocking.whitelist_domain.d.json = cJSON_CreateArray();
+	conf->dns.blocking.whitelist_domain.f = FLAG_ADVANCED_SETTING;
+
+	conf->dns.blocking.whitelist_client.k = "dns.blocking.whitelist_client";
+	conf->dns.blocking.whitelist_client.h = "Array of IP and/or hostnames\n Example: [ \"192.168.1.10\", \"docker-resolver\" ]";
+	conf->dns.blocking.whitelist_client.a = cJSON_CreateStringReference("array of IP addresses and/or hostnames");
+	conf->dns.blocking.whitelist_client.t = CONF_JSON_STRING_ARRAY;
+	conf->dns.blocking.whitelist_client.d.json = cJSON_CreateArray();
+	conf->dns.blocking.whitelist_client.f = FLAG_ADVANCED_SETTING;
+
+	conf->dns.blocking.withIP.client.k = "dns.blocking.withIP.client";
+	conf->dns.blocking.withIP.client.h = "Array of IP and/or hostnames\n Example: [ \"192.168.1.10\", \"docker-resolver\" ]";
+	conf->dns.blocking.withIP.client.a = cJSON_CreateStringReference("array of IP addresses and/or hostnames");
+	conf->dns.blocking.withIP.client.t = CONF_JSON_STRING_ARRAY;
+	conf->dns.blocking.withIP.client.d.json = cJSON_CreateArray();
+	conf->dns.blocking.withIP.client.f = FLAG_ADVANCED_SETTING;
+
+	conf->dns.blocking.withIP.ignore_domain.k = "dns.blocking.withIP.ignore_domain";
+	conf->dns.blocking.withIP.ignore_domain.h = "Array of domain\n Example: [ \"google.com\", \"facebook.com\", \"example.com\" ]";
+	conf->dns.blocking.withIP.ignore_domain.a = cJSON_CreateStringReference("array of domain");
+	conf->dns.blocking.withIP.ignore_domain.t = CONF_JSON_STRING_ARRAY;
+	conf->dns.blocking.withIP.ignore_domain.d.json = cJSON_CreateArray();
+	conf->dns.blocking.withIP.ignore_domain.f = FLAG_ADVANCED_SETTING;
+
 	// struct dns
 	conf->dns.upstreams.k = "dns.upstreams";
 	conf->dns.upstreams.h = "Array of upstream DNS servers used by Pi-hole\n Example: [ \"8.8.8.8\", \"127.0.0.1#5353\", \"docker-resolver\" ]";
--- a/src/config/config.h
+++ b/src/config/config.h
@@ -149,6 +149,13 @@ struct config {
 		struct {
 			struct conf_item active;
 			struct conf_item mode;
+			struct conf_item block_domain;
+			struct conf_item whitelist_domain;
+			struct conf_item whitelist_client;
+			struct {
+				struct conf_item client;
+				struct conf_item ignore_domain;
+			} withIP;
 		} blocking;
 		struct {
 			struct conf_item mozillaCanary;
--- a/src/config/config_uci.c
+++ b/src/config/config_uci.c
@@ -424,13 +424,41 @@ static void set_uci_type_name(struct con
 		if(strcmp(item->p[level - 4], "webserver") == 0) {
 			*section = "api";
 			*option = concat(3, item->p[level - 2], delim, item->p[level - 1]);
+		}
+		else if(strcmp(item->p[level - 2], "withIP") == 0)
+		{
+			if(strcmp(item->p[level - 1], "client") == 0)
+			{
+				*section = "block_with_ip";
+				*option = strdup("client");
+			}
+			else if(strcmp(item->p[level - 1], "ignore_domain") == 0)
+			{
+				*section = "block_with_ip";
+				*option = strdup("ignore_domain");
+			}
 		} else
 			// dns.reply.xxx.xxx
 			*option = concat(5, item->p[level - 3], delim, item->p[level - 2], delim, item->p[level - 1]);
 	}
 	else if(level == 3)
 	{
-		if(strcmp(item->p[level - 3], "webserver") == 0)
+		if(strcmp(item->p[level - 1], "block_domain") == 0)
+		{
+			*section = "blacklist";
+			*option = strdup("domain");
+		}
+		else if(strcmp(item->p[level - 1], "whitelist_domain") == 0)
+		{
+			*section = "whitelist";
+			*option = strdup("domain");
+		}
+		else if(strcmp(item->p[level - 1], "whitelist_client") == 0)
+		{
+			*section = "whitelist";
+			*option = strdup("client");
+		}
+		else if(strcmp(item->p[level - 3], "webserver") == 0)
 		{
 			if(strcmp(item->p[level - 2], "api") == 0)
 				*section = "api";
--- a/src/dnsmasq_interface.c
+++ b/src/dnsmasq_interface.c
@@ -57,6 +57,7 @@
 #include "config/config.h"
 // FTL_fork_and_bind_sockets()
 #include "main.h"
+#include <uci.h>
 
 // Private prototypes
 static void print_flags(const unsigned int flags);
@@ -1166,17 +1167,26 @@ static bool check_domain_blocked(const c
 		return false;
 
 	// check domain in uci config
-	if(is_in_uci_list(uci_pihole, "@blacklist[0]", "domain", domain))
+	if(config.dns.blocking.block_domain.v.json != NULL &&
+	   cJSON_GetArraySize(config.dns.blocking.block_domain.v.json) > 0)
 	{
-		// Set new status
-		*new_status = QUERY_DENYLIST;
-		blockingreason = "exactly blacklisted";
+		cJSON *line = NULL;
+		cJSON_ArrayForEach(line, config.dns.blocking.block_domain.v.json)
+		{
+			if(line != NULL && cJSON_IsString(line) &&
+				strcmp(line->valuestring, domain) == 0)
+			{
+				// Set new status
+				*new_status = QUERY_DENYLIST;
+				blockingreason = "exactly blacklisted";
 
-		// Mark domain as exactly blacklisted for this client
-		set_dnscache_blockingstatus(dns_cache, client, DENYLIST_BLOCKED, domain);
+				// Mark domain as exactly blacklisted for this client
+				set_dnscache_blockingstatus(dns_cache, client, DENYLIST_BLOCKED, domain);
 
-		// We block this domain
-		return true;
+				// We block this domain
+				return true;
+			}
+		}
 	}
 
 	// Check domains against exact blacklist
@@ -1470,13 +1480,32 @@ static bool _FTL_check_blocking(int quer
 	// Check exact whitelist for match
 	query->flags.allowed = in_allowlist(domainstr, dns_cache, client) == FOUND;
 
-	if(!query->flags.allowed)
+	if(config.dns.blocking.whitelist_domain.v.json != NULL &&
+	   cJSON_GetArraySize(config.dns.blocking.whitelist_domain.v.json) > 0)
 	{
-		if(is_in_uci_list(uci_pihole, "@whitelist[0]", "domain", domainstr) ||
-		   is_in_uci_list(uci_pihole, "@whitelist[0]", "client", getstr(client->ippos)) ||
-		   is_in_uci_list(uci_pihole, "@whitelist[0]", "client", getstr(client->namepos)))
+		cJSON *whiteDomain = NULL;
+		cJSON_ArrayForEach(whiteDomain, config.dns.blocking.whitelist_domain.v.json)
 		{
-			query->flags.allowed = true;
+			if(whiteDomain != NULL && cJSON_IsString(whiteDomain) &&
+				strcmp(whiteDomain->valuestring, domainstr) == 0)
+			{
+				query->flags.allowed = true;
+			}
+		}
+	}
+
+	if(config.dns.blocking.whitelist_client.v.json != NULL &&
+	   cJSON_GetArraySize(config.dns.blocking.whitelist_client.v.json) > 0)
+	{
+		cJSON *whiteClient = NULL;
+		cJSON_ArrayForEach(whiteClient, config.dns.blocking.whitelist_client.v.json)
+		{
+			if(whiteClient != NULL && cJSON_IsString(whiteClient) &&
+				(strcmp(whiteClient->valuestring, getstr(client->ippos)) == 0 ||
+				strcmp(whiteClient->valuestring, getstr(client->namepos)) == 0))
+			{
+				query->flags.allowed = true;
+			}
 		}
 	}
 
@@ -1504,17 +1533,45 @@ static bool _FTL_check_blocking(int quer
 	unsigned char new_status = QUERY_UNKNOWN;
 	bool db_okay = true;
 	bool blockDomain = check_domain_blocked(domainstr, clientID, client, query, dns_cache, &new_status, &db_okay);
+	bool block_with_ip = false;
 
-	if(blockDomain && query->type == TYPE_A &&
-	   !is_in_uci_list(uci_pihole, "@block_with_ip[0]", "ignore_domain", domainstr))
+	if(blockDomain && query->type == TYPE_A)
 	{
-		if(is_in_uci_list(uci_pihole, "@block_with_ip[0]", "client", getstr(client->ippos)) ||
-		   is_in_uci_list(uci_pihole, "@block_with_ip[0]", "client", getstr(client->namepos)))
+		if(config.dns.blocking.withIP.client.v.json != NULL &&
+		   cJSON_GetArraySize(config.dns.blocking.withIP.client.v.json) > 0)
 		{
-			force_next_DNS_reply = REPLY_IP;
-			if(db_okay)
-				dns_cache->force_reply = REPLY_IP;
+			cJSON *blockIP = NULL;
+			cJSON_ArrayForEach(blockIP, config.dns.blocking.withIP.client.v.json)
+			{
+				if(blockIP != NULL && cJSON_IsString(blockIP) &&
+					(strcmp(blockIP->valuestring, getstr(client->ippos)) == 0 ||
+					strcmp(blockIP->valuestring, getstr(client->namepos)) == 0))
+				{
+					block_with_ip = true;
+				}
+			}
 		}
+
+		if(config.dns.blocking.withIP.ignore_domain.v.json != NULL &&
+		   cJSON_GetArraySize(config.dns.blocking.withIP.ignore_domain.v.json) > 0)
+		{
+			cJSON *ignored = NULL;
+			cJSON_ArrayForEach(ignored, config.dns.blocking.withIP.ignore_domain.v.json)
+			{
+				if(ignored != NULL && cJSON_IsString(ignored) &&
+					(strcmp(ignored->valuestring, domainstr) == 0))
+				{
+					block_with_ip = false;
+				}
+			}
+		}
+	}
+
+	if(block_with_ip)
+	{
+		force_next_DNS_reply = REPLY_IP;
+		if(db_okay)
+			dns_cache->force_reply = REPLY_IP;
 	}
 
 	// Check blacklist (exact + regex) and gravity for _esni.domain if enabled
